%%
%% Toolbox Language Manual
%% $Id: lang_man.tex,v 1.81 2005/10/24 01:48:38 vdmtools Exp $
%% 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PDF compatibility code. 

\makeatletter
\newif\ifpdflatex@
\ifx\pdftexversion\@undefined
\pdflatex@false
%\message{Not using pdf}
\else
\pdflatex@true
%\message{Using pdf}
\fi

\newcommand{\latexpdf}[2]{
  \ifpdflatex@ #1
  \else #2
  \fi
}

\newcommand{\latexorpdf}[2]{
  \ifpdflatex@ #2
  \else #1
  \fi
}

\newcommand{\pformat}{a4paper}

\makeatother

\newcommand{\RuleTarget}[1]{\hypertarget{rule:#1}{}}
\newcommand{\Ruledef}[2]
{
  \RuleTarget{#1}\Rule{#1}{#2}%
  }
\newcommand{\Ruleref}[1]{
  \hyperlink{rule:#1}{#1}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\latexorpdf{
\documentclass[\pformat,12pt]{article}
}{
% pdftex option is used by graphic[sx],hyperref,toolbox.sty
\documentclass[\pformat,pdftex,12pt]{article}
}

\usepackage{toolbox}
\usepackage{vdmsl-2e}
\usepackage{makeidx}
\usepackage{alltt}
%\usepackage{epsfig}
\usepackage{here}
\usepackage{array}
\usepackage{longtable}
\usepackage{ifthen}
% plainpages=false: avoid warning
%   destination with the same identifier already exists
%   but it do not seem to work a the first pages
% Ueki change start
%\usepackage[dvipdfm,bookmarks=true,bookmarksnumbered=true,colorlinks,plainpages=true]{hyperref}
\usepackage[bookmarks=true,bookmarksnumbered=true,colorlinks,plainpages=true]{hyperref}
% Ueki change end

% Ueki delete start
%\latexorpdf{
%\usepackage[plainpages=true,colorlinks,linkcolor=black,citecolor=black,pagecolor=black, urlcolor=black]{hyperref}
%}{
%\usepackage[plainpages=true,colorlinks]{hyperref}
%}
% Ueki delete end


\newcommand{\vdmslpp}[2]{%
#1
}

\newcommand{\vdmsl}{VDM-SL}
\newcommand{\vdmpp}{VDM++}
\newcommand{\Index}[1]{#1\index{#1}}

% The use of /VDMPP ifdef's have basicly been exchanged with the
% use of LaTeX ifthenelse's.  For this two LaTeX boolean value  and
% VDMpp have been defined  (Lowercase p's are used to avoid conflict with
% the VDMPP environment variable.  The typical use are:
%   \ifthenelse{\boolean{VDMsl}}{vdmsl-text}{vdmpp-text}
%   \ifthenelse{\boolean{VDMsl}}{vdmsl-text}{}
%   \ifthenelse{\boolean{VDMpp}}{vdmpp-text}{}
% The advantage of this as opposed to ifdef's is that within a general
% paragraph specific VDM-SL and VDM++ parts can be distinguished without
% problematic empty lines.
% 
% The values are initialised such that exactly one of the values is true
% and the other is false.  This should hopefully avoid strange behaviour
% due to possible preprossing errors.  The default case is VDM-SL.
\newboolean{VDMsl}
\setboolean{VDMsl}{true}
\newboolean{VDMpp}
\setboolean{VDMpp}{false}
\setboolean{VDMsl}{true}
\setboolean{VDMpp}{false}

%\latexpdf{\usepackage[pdftex,colorlinks=true,bookmarks=true]{hyperref}}{}

\newcommand{\vdmtoolsver}{v8.3}

\newcommand{\MYEQUIV}{$\equiv$}
\newlength{\nonstandlen}
\newcommand{\nonstandard}[1]{%
\setlength{\nonstandlen}{#1\baselineskip}%
  \marginpar{\hspace*{-3mm}\raisebox{\nonstandlen}[0pt][0pt]{\fbox{{\footnotesize Non standard}}}}%
}
\newenvironment{TypeSemantics}{\begin{longtable}[r]{|p{3.5cm}|p{9cm}|}\hline%
  Operator Name & Semantics Description \\ \hline\hline \endhead}% 
  {\hline\end{longtable}}
  
%\renewcommand{\vdmpp}{{\small VDM}$^{++}$}

\makeatletter
% ------------- TOC manipulation ------------
\def\docglbldepth{1}
%\setcounter{secnumdepth}{\docglbldepth}
%\setcounter{tocdepth}{\docglbldepth}
\def\@pnumwidth{3.0em}
% more space for for >10 subsections
%\def\l@section{\@dottedtocline{1}{1.5em}{3.1em}}
\def\l@subsection{\@dottedtocline{2}{1.5em}{2.8em}}
%\def\l@subsubsection{\@dottedtocline{3}{4.3em}{3.6em}}
%\def\l@paragraph{\@dottedtocline{4}{7.9em}{4.1em}}
%\def\l@subparagraph{\@dottedtocline{5}{10em}{5em}}
\makeatother

\makeindex
%\latexpdf{\pdfinfo{
% /Title (The  VDM-SL Language)
% /Author (The VDM Tool Group, The Institute of Applied Computer Science)
%}}{}


\begin{document}
%\latexpdf{\pdfcatalog{/PageMode /UseOutlines} openaction goto page 1 {/Fit}}{}

%\vdmtoolsmanual{The  VDM-SL Language}
\vdmtoolsmanualscsk{The VDM-SL Language Manual}{2.1}
        {2.0}


\newcommand{\Lit}[1]{`{\tt #1}\Quote}
\newcommand{\Rule}[2]{
  \begin{quote}\begin{tabbing}
    #1\index{#1}\ \ \= = \ \ \= #2  ; %    Adds production rule to index
    
  \end{tabbing}\end{quote}
  }
\newcommand{\SeqPt}[1]{\{\ #1\ \}}
\newcommand{\lfeed}{\\ \> \>}
\newcommand{\dsepl}{\ $|$\ }
\newcommand{\dsep}{\\ \> $|$ \>}
\newcommand{\Lop}[1]{`{\sf #1}\Quote}
\newcommand{\blankline}{\vspace{\baselineskip}}
\newcommand{\Brack}[1]{(\ #1\ )}
\newcommand{\nmk}{\footnotemark}
\newcommand{\ntext}[1]{\footnotetext{{\bf Note: } #1}}
\newlength{\kwlen}
\newcommand{\Keyw}[1]{\settowidth{\kwlen}{\tt #1}\makebox[\kwlen][l]{\sf
    #1}}
\newcommand{\keyw}[1]{{\sf #1}}
\newcommand{\id}[1]{{\tt #1}}
\newcommand{\metaiv}[1]{\begin{alltt}\input{#1}\end{alltt}}

\newcommand{\OptPt}[1]{[\ #1\ ]}
\newcommand{\MAP}[2]{\kw{map }#1\kw{ to }#2}
\newcommand{\INMAP}[2]{\kw{inmap }#1\kw{ to }#2}
\newcommand{\SEQ}[1]{\kw{seq of }#1}
\newcommand{\NSEQ}[1]{\kw{seq1 of }#1}
\newcommand{\SET}[1]{\kw{set of }#1}
\newcommand{\PROD}[2]{#1 * #2}
\newcommand{\TO}[2]{$#1 \To #2$}
\newcommand{\FUN}[2]{#1 \To #2}
\newcommand{\PUBLIC}{\ifthenelse{\boolean{VDMpp}}{public\mbox{}}{\mbox{}}}
\newcommand{\PRIVATE}{\ifthenelse{\boolean{VDMpp}}{private}{\mbox{}}}
\newcommand{\PROTECTED}{\ifthenelse{\boolean{VDMpp}}{protected}{\mbox{}}}


% No line numbering
%\nolinenumbering
%\setindent{outer}{\parindent}
%\setindent{inner}{0.0em}


\section{Introduction}


This document describes the syntax and semantics of the  VDM-SL
language which is essentially standard ISO/VDM-SL \cite{ISOVDM96}
with a modular extension
\footnote{A few other extensions are also included.}.
Notice that all syntactically correct VDM-SL specifications are also correct in
 VDM-SL. 
Even though we have tried to present the language in a
clear and understandable way the document is not a complete VDM-SL
reference manual. 
For a more thorough presentation of the language we refer to the
existing literature\footnote{A more tutorial like
presentation is given in \cite{Fitzgerald&98} whereas proofs in VDM-SL
are treated best in \cite{Jones90a} and \cite{Bicarregui&94}.}.
Wherever the  VDM-SL notation differs from
the VDM-SL standard notation the semantics will of course be carefully
explained.

The  VDM-SL language is the language supported by the  VDM-SL
Toolbox (see \cite{UserMan-SCSK}). This Toolbox contains a syntax checker,
a static semantics checker, an interpreter\footnote{In addition the
Toolbox provides pretty printing facilities, debugging facilities and
support for test coverage, but these are the basic components.} and a
code generator to C++. Because ISO/VDM-SL in general is a
non-executable language the interpreter supports only a subset of the
language. This document will focus particularly on the points where
the semantics of VDM-SL differs from the semantics used in the
interpreter. In this document we will use the term ``the interpreter"
whenever we refer to the interpreter from the  VDM-SL Toolbox, and
we will refer to ``VDM-SL" whenever the semantics of some language
construct is totally identical to the dynamic semantics for the VDM-SL
standard.

Consequently we will use the ASCII (also called the interchange)
concrete syntax but we will display all reserved words in a special
keyword font. This is done because the document works as a language
manual to the  VDM-SL Toolbox where the ASCII notation is used as
input. The mathematical concrete syntax can be generated automatically
by the Toolbox so a nicer looking syntax can be produced.

Section~\ref{conformance} indicates how the language presented here and the
corresponding  VDM-SL Toolbox conform to the VDM-SL standard.
Section~\ref{syntax-notation} presents the BNF notation used
for the description of syntactic constructs.  The  VDM-SL
notation is described in section~\ref{typedef} to
section~\ref{top-level}.
Section~\ref{diff} provides a complete list of the differences between
ISO/VDM-SL and  VDM-SL while section~\ref{static} contains a
short explanation of the static semantics of VDM-SL.
The complete syntax of the language is described in Appendix~\ref{app-a}, the
lexical specification in Appendix~\ref{app-b} and the operator precedence
in Appendix~\ref{app-c}. Appendix~\ref{sec:diff} presents a list of the
differences between symbols in the mathematical syntax and the ASCII
concrete syntax. In Appendex~\ref{stdlib} details of the Standard
library and how to use it are given. Finally, an index of the defining
occurrences of 
all the syntax rules in the document is given. 

\section{Conformance Issues}
\label{conformance}

The VDM-SL standard has a conformance clause which specifies a number
of levels of conformity. The lowest level of conformity deals with
syntax conformance. The  \vdmslpp{\vdmsl}{\vdmpp} Toolbox accepts
specifications which follow the syntax description in the
\vdmslpp{standard.}{standard with the exceptions described in section
\ref{diff}.}

In addition it accepts a number of extensions (see section \ref{diff})
which should be rejected according to the conformance clause.

Level one in the conformance clause deals with the static semantics
for possible correctness (see section~\ref{static}). 
In this part we have chosen to reject more
specifications than the standard prescribes as being possibly
well-formed\footnote{For example with a set comprehension where a
  predicate is present the standard does not check the element
  expression at all (in the possibly well-formedness check) because
  the predicate could yield false (and thus the whole expression would
  just be another way to write an empty set). We believe that a user
  will be interested in getting such parts tested as well.}.

Level two and the following levels (except the last one) deal with the
definite well-formedness static semantics check and a number of
possible extended checks which can be added to the static semantics.
The definitely well-formedness check is present in the
Toolbox. However, we do not consider it to be of major value for real
examples because almost no ``real'' specifications will be able to
pass this test.

The last conformance level deals with the dynamic semantics. Here it
is required that an accompanying document provides details about the
deviations from the standard dynamic semantics (which is not
executable). This is actually done in this document by explaining
which constructs can be interpreted by the Toolbox and what the
deviations are for a few constructs. Thus, this level of conformance
is satisfied by the  \vdmslpp{VDM-SL}{\vdmpp} Toolbox.

To sum up, we can say that  \vdmslpp{VDM-SL}{\vdmpp} (and its
supporting Toolbox) is quite close conforming to the standard, but we
have not yet invested the time in ensuring this.

\section{Concrete Syntax Notation}
\label{syntax-notation}


Wherever the syntax for parts of the language is presented in the
document it will be described in a BNF dialect. The BNF notation
used employs the following special symbols:

\newcommand{\singleQuote}{\texttt{\symbol{34}}}
\begin{tabular}{l@{\hspace{1cm}}p{10cm}}
  , &  the concatenate symbol \\
  = & the define symbol \\
  \dsepl & the definition separator symbol (alternatives)\\
  \OptPt{} & enclose optional syntactic items \\
  \SeqPt{} & enclose syntactic items which may occur zero or more times \\
  \Lit{ } & single quotes are used to enclose terminal symbols \\
    meta identifier & non-terminal symbols are written in lower-case letters
    (possibly including spaces) \\
  ;  & terminator symbol to denote the end of a rule \\
  (\ ) & used for grouping, e.g. ``a, (b\dsepl c)'' is equivalent to
    ``a, b\dsepl a, c''. \\
  -- & denotes subtraction from a set of terminal symbols 
    (e.g. ``character -- (\Lit{\singleQuote})'' denotes all characters
    excepting the double quote character.)
\end{tabular}

\section{Data Type Definitions}
\label{typedef}

As in traditional programming languages it is possible to define data
types in \vdmslpp{\vdmsl}{\vdmpp}\ and give them appropriate names.
Such an equation might look like:

\begin{alltt}
  Amount = \keyw{nat}
\end{alltt}
Here we have defined a data type with the name ``{\tt Amount}'' and
stated that the values which belong to this type are natural numbers
(\keyw{nat} is one of the basic types described below). One general
point about the type system of \vdmslpp{\vdmsl}{\vdmpp}\ which is
worth mentioning at this point is that equality and inequality can be
used between any value. In programming languages it is often required
that the operands have the same type. Because of a 
construct called a union type (described below) this is not the case
for \vdmslpp{\vdmsl.}{\vdmpp.}

In this section we will present the syntax of data type
definitions. In addition, we will show how values belonging to a type
can be constructed and manipulated (by means of built-in operators).
We will present the basic data types first and then we will proceed
with the compound types.

\subsection{Basic Data Types}

In the following a number of basic types will be presented. Each of
them will contain:

\begin{itemize}
\item Name of the construct.
\item Symbol for the construct.
\item Special values belonging to the data type.
\item Built-in operators for values belonging to the type.
\item Semantics of the built-in operators.
\item Examples illustrating how the built-in operators can be used.%
  \footnote{In these examples the Meta symbol `$\equiv$' will be used
    to indicate what the given example is equivalent to.}
\end{itemize}
For each of the built-in operators the name, the symbol used and the
type of the operator will be given together with a description of its
semantics (except that the semantics of Equality and Inequality is not
described, since it follows the usual semantics). In the semantics
description identifiers refer to those used in the corresponding
definition of operator type, e.g.\ {\tt a}, {\tt b}, {\tt x}, {\tt y}
etc.

The basic types are the types defined by the language with distinct
values that cannot be analysed into simpler values. There are five
fundamental basic types: booleans, numeric types,
characters, tokens and quote types. The basic types will be explained one by
one in the following.

\subsubsection{The Boolean Type}\label{bool}

In general \vdmslpp{\vdmsl}{\vdmpp} allows one to specify systems in
which computations may fail to terminate or to deliver a result. To
deal with such potential undefinedness, 
\vdmslpp{\vdmsl}{\vdmpp} employs a three valued logic: values may be
true, false or bottom (undefined). 
The semantics of the interpreter differs from \vdmsl\ in that it does
not have an LPF (Logic of Partial Functions) three valued logic where
the order of the operands is  
unimportant (see \cite{Jones90a}).  The \keyw{and} operator, the
\keyw{or} operator and the imply operator, though, have a conditional
semantics meaning that if the first operand is sufficient to determine
the final result, the second operand will not be evaluated. In a sense
the semantics of the logic in the interpreter can still be considered
to be three-valued as for VDM-SL. However, bottom values may
either result in infinite computation or a run-time error in the
interpreter.

\begin{description}
\item[Name:] \Index{Boolean}
\item[Symbol:] \Index{\keyw{bool}}
\item[Values:] \Index{\keyw{true}}, \Index{\keyw{false}}
\item[Operators:] Assume that {\tt a} and {\tt b} in the following
  denote arbitrary boolean expressions:

  \begin{tabular}{|l|l|l|}\hline
    Operator       & Name       & Type                       \\ \hline
    {\tt \keyw{not} b}& Negation   & \TO{\keyw{bool}}{\keyw{bool}} \\
    {\tt a \keyw{and} b}& Conjunction & \TO{\PROD{\keyw{bool}}{\keyw{bool}}}{\keyw{bool}} \\
    {\tt a \keyw{or} b}& Disjunction & \TO{\PROD{\keyw{bool}}{\keyw{bool}}}{\keyw{bool}} \\
    {\tt a => b}& Implication & \TO{\PROD{\keyw{bool}}{\keyw{bool}}}{\keyw{bool}} \\
    {\tt a <=> b}& Biimplication & \TO{\PROD{\keyw{bool}}{\keyw{bool}}}{\keyw{bool}} \\
    {\tt a = b} & Equality   & \TO{\PROD{\keyw{bool}}{\keyw{bool}}}{\keyw{bool}} \\
    {\tt a <> b}& Inequality & \TO{\PROD{\keyw{bool}}{\keyw{bool}}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\keyw{not}}\index{Negation}\index{\keyw{and}}\index{Conjunction}%
\index{\keyw{or}}\index{Disjunction}%
\index{\texttt{=>}}\index{Implication}\index{\texttt{<=>}}\index{Biimplication}%
\index{\texttt{=}!boolean equality}\index{Equality!boolean type}\index{\texttt{<>}!boolean inequality}\index{Inequality!boolean type}


\item[Semantics of Operators:] Semantically {\tt <=>} and {\tt =} are
  equivalent when we deal with boolean values. There is a conditional
  semantics for \keyw{and}, \keyw{or} and {\tt=>}.

  We denote undefined terms (e.g. \ applying a map with a key outside
  its domain)  by $\perp$. The truth tables for the boolean operators
  are then%
  \footnote{Notice that in standard VDM-SL all these truth tables
  (except {\tt =>}) would be symmetric.}:
     
  \begin{tabular}{ll}
    Negation {\tt \keyw{not} b} &
    \begin{tabular}{|l|l|l|l|}\hline
      $ b $   & \keyw{true}  & \keyw{false} & $\perp$ \\ \hline
      {\tt \keyw{not} b}  & \keyw{false}  & \keyw{true} & $\perp$ \\ \hline
    \end{tabular}\\
    \mbox{} & \\
    Conjunction {\tt a \keyw{and} b} &
    \begin{tabular}{|l|l|l|l|}\hline
      $a \backslash b $   & \keyw{true}  & \keyw{false} & $\perp$ \\ \hline
      \keyw{true}  & \keyw{true}  & \keyw{false} & $\perp$ \\
      \keyw{false} & \keyw{false} & \keyw{false} & \keyw{false} \\
      $\perp$& $\perp$&$\perp$&$\perp$\\\hline
    \end{tabular}\\
    \mbox{} & \\
    Disjunction {\tt a \keyw{or} b} &
    \begin{tabular}{|l|l|l|l|}\hline
      $a \backslash b $   & \keyw{true}  & \keyw{false} & $\perp$ \\ \hline
      \keyw{true}  & \keyw{true}  & \keyw{true} & \keyw{true} \\
      \keyw{false} & \keyw{true} & \keyw{false} & $\perp$ \\
      $\perp$& $\perp$&$\perp$&$\perp$\\\hline
    \end{tabular}\\
    \mbox{} & \\
    Implication {\tt a => b} &
    \begin{tabular}{|l|l|l|l|}\hline
      $a \backslash b $   & \keyw{true}  & \keyw{false} & $\perp$ \\ \hline
      \keyw{true}  & \keyw{true}  & \keyw{false} & $\perp$ \\
      \keyw{false} & \keyw{true} & \keyw{true} & \keyw{true} \\
      $\perp$& $\perp$&$\perp$&$\perp$\\\hline
    \end{tabular}\\
    \mbox{} & \\
    Biimplication {\tt a <=> b} &
    \begin{tabular}{|l|l|l|l|}\hline
      $ a \backslash b$    & \keyw{true}  & \keyw{false} & $\perp$ \\ \hline
      \keyw{true}  & \keyw{true}  & \keyw{false} & $\perp$ \\
      \keyw{false} & \keyw{false} & \keyw{true}  & $\perp$ \\
      $\perp$&$\perp$ &$\perp$ & $\perp$ \\ \hline
    \end{tabular}\\
  \end{tabular}     

\item[Examples:] 
  Let {\tt a = \keyw{true}} and {\tt b = \keyw{false}} then:
  
  \begin{tabular}{lcl}
    {\tt \keyw{not} a} & $\equiv$ & \keyw{false} \\
    {\tt a \keyw{and} b} & $\equiv$ & \keyw{false} \\
    {\tt b \keyw{and} $\perp$} & $\equiv$ & \keyw{false} \\
    {\tt a \keyw{or} b} & $\equiv$ & \keyw{true} \\
    {\tt a \keyw{or} $\perp$} & $\equiv$ & \keyw{true} \\
    {\tt a => b} & $\equiv$ & \keyw{false} \\
    {\tt b => b} & $\equiv$ & \keyw{true} \\
    {\tt b => $\perp$} & $\equiv$ & \keyw{true} \\
    {\tt a <=> b} & $\equiv$ & \keyw{false} \\
    {\tt a = b} & $\equiv$ & \keyw{false} \\
    {\tt a <> b} & $\equiv$ & \keyw{true} \\
    {\tt $\perp$ \keyw{or} \keyw{not} $\perp$} & $\equiv$ & $\perp$\\
    {\tt (b \keyw{and} $\perp$) \keyw{or} ($\perp$ \keyw{and}
    \keyw{false})} & $\equiv$ & $\perp$
  \end{tabular}
\end{description}

\subsubsection{The Numeric Types}\label{numeric}

There are five basic numeric types: positive naturals, naturals,
integers, rationals and reals.  Except for three, all the
numerical operators can have mixed operands of the three types. The
exceptions are integer division, modulo and the remainder operation.

The five numeric types denote a hierarchy where \Index{\keyw{real}} is
the most general type followed by \Index{\keyw{rat}}\footnote{From the
   \vdmslpp{\vdmsl}{\vdmpp}\ Toolbox's point of view there is no
  difference between \keyw{real} and \keyw{rat} because only rational
  numbers can be represented in a computer.}, \Index{\keyw{int}},
\Index{\keyw{nat}} and \Index{\keyw{nat1}}.

\vspace{1ex}
\begin{tabular}{|l|l|} \hline
  Type & Values \\ \hline
  \keyw{nat1}& {\tt 1, 2, 3, \ldots}\\
  \keyw{nat} & {\tt 0, 1, 2, \ldots}\\
  \keyw{int} & {\tt \ldots, -2, -1, 0, 1, \ldots}\\
  \keyw{real} & {\tt \ldots, -12.78356, \ldots, 0, \ldots, 3, \ldots, 1726.34, \ldots}\\ \hline
\end{tabular}

\mbox{}\\
This means that any number of type \keyw{int} is also automatically of type
\keyw{real} but not necessarily of type \keyw{nat}.  Another way to
illustrate this is to say that the positive natural numbers are a subset of
the natural numbers which again are a subset of the integers which again
are a subset of the rational numbers which finally are a subset of the real
numbers. The following table shows some numbers and their associated
type:

\vspace{1ex}
\begin{tabular}{|c|l|} \hline
  Number & Type \\ \hline
  {\tt 3}      & \keyw{real, rat, int, nat, nat1} \\
  {\tt 3.0}    & \keyw{real, rat, int, nat, nat1} \\
  {\tt 0}      & \keyw{real, rat, int, nat} \\
  {\tt -1}     & \keyw{real, rat, int}\\
  {\tt 3.1415} & \keyw{real, rat} \\ \hline
\end{tabular}

\mbox{}\\
Note that all numbers are necessarily of type \keyw{real} (and
\keyw{rat}).

\begin{description}
\item[Names:] real, rational, integer, natural and positive natural
  numbers.
\item[Symbols:] \keyw{real}, \keyw{rat}, \keyw{int}, \keyw{nat},
  \keyw{nat1}
\item[Values:] {\tt \ldots, -3.89, \ldots, -2, \ldots, 0, \ldots, 4,
    \ldots, 1074.345, \ldots}
\item[Operators:] Assume in the following that {\tt x} and {\tt y} denote
  numeric expressions. No assumptions are made regarding their type.

  \begin{tabular}{|l|l|l|}\hline
    Operator       & Name & Type \\ \hline
    {\tt -x}& Unary minus & \TO{\keyw{real}}{\keyw{real}} \\
    {\tt \keyw{abs} x}& Absolute value & \TO{\keyw{real}}{\keyw{real}} \\
    {\tt \keyw{floor} x}& Floor  & \TO{\keyw{real}}{\keyw{int}} \\
    {\tt x + y}& Sum    & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{real}} \\
    {\tt x - y}& Difference & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{real}} \\
    {\tt x * y}& Product  & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{real}} \\
    {\tt x / y}& Division & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{real}} \\
    {\tt x \keyw{div} y}& Integer division & \TO{\PROD{\keyw{int}}{\keyw{int}}}{\keyw{int}} \\
    {\tt x \keyw{rem} y}& Remainder & \TO{\PROD{\keyw{int}}{\keyw{int}}}{\keyw{int}} \\
    {\tt x \keyw{mod} y}& Modulus   & \TO{\PROD{\keyw{int}}{\keyw{int}}}{\keyw{int}} \\
    {\tt x**y}& Power & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{real}} \\
    {\tt x < y}& Less than & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{bool}} \\
    {\tt x > y}& Greater than & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{bool}} \\
    {\tt x <= y}& Less or equal & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{bool}} \\
    {\tt x >= y}& Greater or equal & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{bool}} \\
    {\tt x = y}& Equal  & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{bool}} \\
    {\tt x <> y}& Not equal & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{bool}} \\
    \hline     
  \end{tabular}%
\index{\texttt{-}}\index{Unary minus}\index{\keyw{abs}}\index{Absolute value}%
\index{\keyw{floor}}\index{Floor}\index{\texttt{+}}\index{Sum}\index{Difference!numeric}%
\index{\texttt{*}}\index{Product}\index{\texttt{/}}\index{Division}%
\index{\keyw{div}}\index{Integer division}\index{\keyw{mod}}\index{Remainder}%
\index{\keyw{mod}}\index{Modulus}\index{\texttt{**}!numeric power}\index{Power}%
\index{\texttt{<}}\index{Less than}\index{\texttt{>}}\index{Greater than}%
\index{\texttt{<=}}\index{Less or equal}\index{\texttt{>=}}\index{Greater or equal}%
\index{\texttt{=}!numeric equality}\index{Equality!numeric type}\index{\texttt{<>}!numeric inequality}\index{Inequality!numeric type}

  The types stated for operands are the most general types allowed.  This
  means for instance that unary minus works for operands of all five types
  (\keyw{nat1}, \keyw{nat}, \keyw{int} \keyw{rat} and \keyw{real}).
     
\input{sem-numtypes}

\item[Examples:] Let {\tt a = 7, b = 3.5, c = 3.1415, d = -3, e = 2} then:

  \begin{longtable}{lcl}
    {\tt - a}&$\equiv$& -7                     \\
    {\tt \keyw{abs} a}&$\equiv$& 7                    \\
    {\tt \keyw{abs} d}&$\equiv$& 3                    \\
    {\tt \keyw{floor} a <= a}&$\equiv$& \keyw{true}   \\
    {\tt a + d}&$\equiv$& $4$                  \\
    {\tt a * b}&$\equiv$& $24.5$               \\
    {\tt a / b}&$\equiv$& $2$                \\
    {\tt a \keyw{div} e}&$\equiv$& $3$                \\
    {\tt a \keyw{div} d}&$\equiv$& $-2$               \\
    {\tt a \keyw{mod} e}&$\equiv$& $1$                \\
    {\tt a \keyw{mod} d}&$\equiv$& $-2$               \\
    {\tt -a \keyw{mod} d}&$\equiv$& $-1$               \\
    {\tt a \keyw{rem} e}&$\equiv$& $1$                \\
    {\tt a \keyw{rem} d}&$\equiv$& $1$                \\
    {\tt -a \keyw{rem} d}&$\equiv$& $-1$              \\
    {\tt 3**2 + 4**2 = 5**2} &$\equiv$ &\keyw{true}   \\
    {\tt b < c}&$\equiv$& \keyw{false}                \\
    {\tt b > c}&$\equiv$& \keyw{true}                 \\
    {\tt a <= d}&$\equiv$& \keyw{false}               \\
    {\tt b >= e}&$\equiv$& \keyw{true}                \\
    {\tt a = e}&$\equiv$& \keyw{false}                \\
    {\tt a = 7.0}&$\equiv$& \keyw{true}               \\
    {\tt c <> d}&$\equiv$& \keyw{true}                \\
    {\tt \keyw{abs} c < 0} & $\equiv$ & \keyw{false}  \\
    {\tt (a \keyw{div} e) * e} & $\equiv$ & 6       
  \end{longtable}
\end{description}

\subsubsection{The Character Type}

The character type contains all the single character
elements of the VDM character set
(see Table~\ref{charSetTable} on page~\pageref{charSetTable}).

\begin{description}
\item[Name:] \Index{Char}
\item[Symbol:] \Index{\keyw{char}}
\item[Values:] {\tt 'a', 'b',} \ldots, {\tt '1', '2',} \ldots {\tt
                '+', '-'} \ldots
\item[Operators:] Assume that {\tt c1} and {\tt c2} in the following denote arbitrary
  characters:

  \begin{tabular}{|l|l|l|}\hline
    Operator       & Name      & Type \\ \hline
    {\tt c1 = c2}  & Equal     & \TO{\PROD{\keyw{char}}{\keyw{char}}}{\keyw{bool}} \\
    {\tt c1 <> c2} & Not equal & \TO{\PROD{\keyw{char}}{\keyw{char}}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{=}!char equality}\index{Equality!char}\index{\texttt{<>}!char inequality}\index{Inequality!char}


\item[Examples:] \mbox{}

  \begin{tabular}{lcl}
    {\tt 'a' = 'b'} &$\equiv$& \keyw{false}\\
    {\tt '1' = 'c'} &$\equiv$& \keyw{false}\\
    {\tt 'd' <> '7'} &$\equiv$& \keyw{true}\\
    {\tt 'e' = 'e'} &$\equiv$& \keyw{true}\\
  \end{tabular}
\end{description}

\subsubsection{The Quote Type}

The quote type corresponds to enumerated types in a programming
language like Pascal. However, instead of writing the different quote
literals between curly brackets in \vdmslpp{\vdmsl}{\vdmpp}\ it is done
by letting a quote type consist of a single quote literal and
then let them be a part of a union type.
%Quote literals are recognized
%by being a sequence of $\const{distinguished letters}$ (which cannot be
%used for any other purpose).

\begin{description}
\item[Name:] \Index{Quote}
\item[Symbol:] e.g. {\tt <QuoteLit>}\index{\texttt{<>}!quote value}
\item[Values:] {\tt <RED>, <CAR>, <QuoteLit>,} \ldots
\item[Operators:] Assume that \texttt{q} and \texttt{r} in the
  following denote arbitrary quote values belonging to an enumerated
  type {\tt T}: 

  \begin{tabular}{|l|l|l|}\hline
    Operator     & Name      & Type \\ \hline
    {\tt q = r}  & Equal     & \TO{\PROD{T}{T}}{\keyw{bool}} \\
    {\tt q <> r} & Not equal & \TO{\PROD{T}{T}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{=}!quote equality}\index{Equality!quote type}\index{\texttt{<>}!quote inequality}\index{Inequality!quote}


\item[Examples:] Let \texttt{T} be the type defined as:

  \begin{tabular}{l}
    {\tt T = <France> | <Denmark> | <SouthAfrica> | <SaudiArabia>} \\
  \end{tabular}

  If for example {\tt a = <France>}
  then:

  \begin{tabular}{lcl}
     {\tt <France> = <Denmark>} & $\equiv$ & \keyw{false}\\
     {\tt <SaudiArabia> <> <SouthAfrica>} & $\equiv$ & \keyw{true}\\
     {\tt a <> <France>} & $\equiv$ & \keyw{false}
  \end{tabular}
\end{description}

\subsubsection{The Token Type}

The token type consists of a countably infinite set of distinct
values, called tokens. The only operations that can be carried out on
tokens are equality and inequality. In \vdmslpp{\vdmsl,}{\vdmpp,}
tokens cannot be individually represented whereas they can be written
with a \keyw{mk\_token} around an arbitrary expression. This is a way
of enabling testing of specifications which contain token
types. However, in order to resemble the \vdmsl\ standard these token
values cannot be decomposed by means of any pattern matching and they
cannot be used for anything other than equality and inequality
comparisons.

\begin{description}
\item[Name:] \Index{Token}
\item[Symbol:] \Index{\keyw{token}}
\item[Values:] \index{\keyw{mk\_}!token value}{\tt \keyw{mk\_token}(5)},
  {\tt \keyw{mk\_token}(\{9, 3\})}, {\tt
    \keyw{mk\_token}([\keyw{true}, \{\}])}, \ldots%\index
\item[Operators:] Assume that {\tt s} and {\tt  t} in the following denote arbitrary
  token values:

  \begin{tabular}{|l|l|l|}\hline
    Operator     & Name      & Type \\ \hline
    {\tt s = t}  & Equal     & \TO{\PROD{\keyw{token}}{\keyw{token}}}{\keyw{bool}} \\
    {\tt s <> t} & Not equal & \TO{\PROD{\keyw{token}}{\keyw{token}}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{=}!token equality}\index{Equality!token type}\index{\texttt{<>}!token inequality}\index{Inequality!token type}

\item[Examples:] Let for example {\tt s = \keyw{mk\_token}(6)} and let {\tt t
    = \keyw{mk\_token}(1)} in:

  \begin{tabular}{lcl}
    {\tt s = t} &$\equiv$& \keyw{false} \\
    {\tt s <> t} &$\equiv$& \keyw{true} \\
    {\tt s = \keyw{mk\_token}(6)} & $\equiv$& \keyw{true} \\
  \end{tabular}
\end{description}

\subsection{Compound Types}

In the following compound types will be presented. Each of
them will contain:
\begin{itemize}
\item The syntax for the compound type definition.
\item An equation illustrating how to use the construct.
\item Examples of how to construct values belonging to the type. In
  most cases there will also be given a forward reference to the
  section where the syntax of the basic constructor expressions is given.
\item Built-in operators for values belonging to the
  type \footnote{These operators are used in either unary or binary
    expressions which are given with all the operators in
    section~\ref{unandbin}.}.
\item Semantics of the built-in operators.
\item Examples illustrating how the built-in operators can be used.
\end{itemize}
For each of the built-in operators the name, the symbol used and the
type of the operator will be given together with a description of its
semantics (except that the semantics of Equality and Inequality is not
described, since it follows the usual semantics). In the semantics
description identifiers refer to those used in the corresponding
definition of operator type, e.g.\ {\tt m}, {\tt m1}, {\tt s}, {\tt
  s1} etc.

\subsubsection{Set Types}
\label{sets}

A set is an unordered collection of values, all of the same
type\footnote{Note however that it is always possible to find a common
  type for two values by the use of a union type (see
  section~\ref{unions}.)}, which is treated as a whole. All sets in 
\vdmslpp{\vdmsl}{\vdmpp}\ are finite, i.e.\ they contain only a finite
number of elements. The elements of a set type can be arbitrarily
complex, they could for example be sets themselves.

In the following this convention will be used: {\tt A} is an arbitrary
type, {\tt S} is a set type, {\tt s}, {\tt s1}, {\tt s2} are set
values, {\tt ss} is a set of set values, {\tt e}, {\tt e1}, {\tt e2}
and {\tt en} are elements from the sets, {\tt bd1,} {\tt bd2}, \ldots,
{\tt bdm} are bindings of identifiers to sets or types, and {\tt P} is
a logical predicate.

\begin{description}
\item[Syntax:] 
  \Rule{type}{
   \Ruleref{set type} \dsep
    \ldots
    }
  
  \Rule{set type}{\Lop{set of}, \Ruleref{type}}

\item[Equation:] {\tt S = \keyw{set of} A}\index{\keyw{set of}}

\item[Constructors:] \mbox{}

  \begin{description}
  \item[Set enumeration:] \verb|{e1, e2, ..., en}| constructs a set of the
    enumerated elements. The empty set is denoted by {\tt \{\}}.
  
  \item[Set comprehension:] \verb+{e | bd1, bd2, ..., bdm & P}+
    constructs a set by evaluating the expression {\tt e} on all the
    bindings for which the predicate {\tt P} evaluates to \keyw{true}.
    A binding is either a set binding or a type
    binding\footnote{Notice that type bindings cannot be executed by
      the interpreter because in general
      they are not executable (see section~\ref{bind} for further
      information about this).}.  A set bind {\tt bdn} has the form
    {\tt pat1, \ldots, patp \keyw{in set} s}, where {\tt pati} is a
    pattern (normally simply an identifier), and {\tt s} is a set
    constructed by an expression. A type binding is similar, in the
    sense that \keyw{in set} is replaced by a colon and {\tt s} is
    replaced with a type expression.
  \end{description}
  The syntax and semantics for all set expressions are given in
  section~\ref{setexpr}.%
\index{\texttt{\{\}}!set enumeration}\index{\texttt{\{"|\}}!set comprehension}\index{\texttt{\&}!set comprehension}
\item[Operators:] \mbox{}

  \begin{tabular}{|l|l|l|}\hline
    Operator & Name & Type \\ \hline 
    {\tt e \keyw{in set} s1} & Membership & \TO{\PROD{A}{\SET{A}}}{\keyw{bool}} \\
    {\tt e \keyw{not in set} s1} & Not membership & \TO{\PROD{A}{\SET{A}}}{\keyw{bool}} \\
    {\tt s1 \keyw{union} s2}& Union & \TO{\PROD{\SET{A}}{\SET{A}}}{\SET{A}} \\
    {\tt s1 \keyw{inter} s2}& Intersection & \TO{\PROD{\SET{A}}{\SET{A}}}{\SET{A}} \\
    {\tt s1 {\tt \char'134} s2}& Difference & \TO{\PROD{\SET{A}}{\SET{A}}}{\SET{A}} \\
    {\tt s1 \keyw{subset} s2}& Subset & \TO{\PROD{\SET{A}}{\SET{A}}}{\keyw{bool}} \\
    {\tt s1 \keyw{psubset} s2} & Proper subset & \TO{\PROD{\SET{A}}{\SET{A}}}{\keyw{bool}} \\
    {\tt s1 = s2}& Equality & \TO{\PROD{\SET{A}}{\SET{A}}}{\keyw{bool}} \\
    {\tt s1 <> s2}& Inequality & \TO{\PROD{\SET{A}}{\SET{A}}}{\keyw{bool}} \\
    {\tt \keyw{card} s1}& Cardinality & \TO{\SET{A}}{\keyw{nat}} \\
    {\tt \keyw{dunion} ss}& Distributed union& \TO{\SET{\SET{A}}}{\SET{A}} \\
    {\tt \keyw{dinter} ss}&Distributed intersection & \TO{\SET{\SET{A}}}{\SET{A}} \\
    {\tt \keyw{power} s1}&Finite power set & \TO{\SET{A}}{\SET{\SET{A}}} \\
    \hline
  \end{tabular}%
\index{\keyw{in set}}\index{Membership}\index{\keyw{not in set}}\index{Not membership}%
\index{\keyw{union}}\index{Union}\index{\keyw{inter}}\index{Intersection}%
\index{\texttt{\char'134}}\index{Difference!set}\index{\keyw{subset}}\index{Subset}%
\index{\keyw{psubset}}\index{Proper subset}\index{\texttt{=}!set equality}\index{Equality!set type}%
\index{\texttt{<>}!set inequality}\index{Inequality!set type}\index{\keyw{card}}\index{Cardinality}%
\index{\keyw{dunion}}\index{Distributed union}\index{\keyw{dinter}}\index{Distributed intersection}%
\index{\keyw{power}}\index{Finite power set}

  Note that the types {\tt A, \SET{A}} and {\tt \SET{\SET{A}}} are only 
  meant to illustrate the structure of the type. For instance it is
  possible to make
  a union between two arbitrary sets {\tt s1} and {\tt s2} and the type of
  the resultant set is the union type of the two set types. Examples
  of this will be given in section \ref{unions}.
      
\input{sem-settypes}

\item[Examples:]%
 Let {\tt s1 = \{<France>,<Denmark>,<SouthAfrica>,<SaudiArabia>\}}, 
{\tt s2 = \{2, 4, 6, 8, 11\}} and {\tt s3 = \{\}} then: 

  \begin{longtable}{lcl}
    {\tt <England> \keyw{in set} s1} & $\equiv$ & \keyw{false}\\
    {\tt 10 \keyw{not in set} s2}    & $\equiv$ & \keyw{true}\\
    {\tt s2 \keyw{union} s3}         & $\equiv$ & \texttt{\{2, 4, 6, 8, 11\}}\\
    \texttt{s1 \keyw{inter} s3}      & $\equiv$ & \texttt{\{\}}\\
    \texttt{(s2 \char'134 \ \{2,4,8,10\}) union \{2,4,8,10\} = s2} &
    $\equiv$ & \keyw{false}\\
    \texttt{s1 \keyw{subset} s3} & $\equiv$ & \keyw{false}\\
    \texttt{s3 \keyw{subset} s1} & $\equiv$ & \keyw{true}\\
    \texttt{s2 \keyw{psubset} s2} & $\equiv$ & \keyw{false}\\
    \texttt{s2 <> s2 \keyw{union} \{2, 4\}} & $\equiv$ & \keyw{false}\\
    \texttt{\keyw{card} s2 \keyw{union} \{2, 4\}} & $\equiv$ & \texttt{5}\\
    \texttt{\keyw{dunion} \{s2, \{2,4\}, \{4,5,6\}, \{0,12\}\}} &
    $\equiv$ & \texttt{\{0,2,4,5,6,8,11,12\}}\\
    \texttt{\keyw{dinter} \{s2, \{2,4\}, \{4,5,6\}\}} & $\equiv$ &
    \texttt{\{4\}}\\
    \texttt{\keyw{dunion} \keyw{power} \{2,4\}} & $\equiv$ &
    \texttt{\{2,4\}}\\
    \texttt{\keyw{dinter} \keyw{power} \{2,4\}} & $\equiv$ & \texttt{\{\}}
  \end{longtable}
\end{description}

\subsubsection{Sequence Types}
\label{sequences}

A sequence value is an ordered collection of elements of some type
indexed by {\tt 1, 2, \ldots, n}; where {\tt n} is the length of the
sequence. A sequence type is the type of finite sequences of elements
of a type, either including the empty sequence (seq0 type) or
excluding it (seq1 type). The elements of a sequence type can be
arbitrarily complex; they could e.g.\ be sequences themselves.

In the following this convention will be used: {\tt A} is an arbitrary
type, {\tt L} is a sequence type, {\tt S} is a set type, {\tt l}, {\tt
  l1}, {\tt l2} are sequence values, {\tt ll} is a sequence of
sequence values.  {\tt e1}, {\tt e2} and {\tt en} are elements in
these sequences, {\tt i} will be a natural number, {\tt P} is a
predicate and {\tt e} is an arbitrary expression.

\begin{description}
\item[Syntax:] 
  \Rule{type}{
    \Ruleref{seq type} \dsep
    \ldots
    }

  \Rule{seq type}{\Ruleref{seq0 type} \dsep
    \Ruleref{seq1 type}}

  \Rule{seq0 type}{\Lop{seq of}, \Ruleref{type}}
  
  \Rule{seq1 type}{\Lop{seq1 of}, \Ruleref{type}}
\item[Equation:] {\tt L = \keyw{seq of} A} or {\tt L = \keyw{seq1 of} A}%
\index{\keyw{seq of}}\index{\keyw{seq1 of}}

%                 $L = \seqof*{A}$ or
%                 $L = \seqof+{A}$ where the notation has been adopted
%                 from regular expressions. Thus $\seqof*{A}$ means the type 
%                 containing sequences of $A$ elements (also the empty
%                 sequence), while $\seqof+{A}$ means the type containing
%                 non-empty sequences of $A$ elements. 

\item[Constructors:] \mbox{}

  \begin{description}
  \item[Sequence enumeration:] \verb+[e1, e2,..., en]+ constructs a
    sequence of the enumerated elements. The empty sequence will be written
    as \verb+[]+.  A text literal is a shorthand for enumerating a sequence
    of characters (e.g.\ {\tt "ifad" = ['i','f','a','d']}).

  \item[Sequence comprehension:] {\tt [e | id \keyw{in set} S \& P]}
    constructs a sequence by evaluating the expression {\tt e} on all the
    bindings for which the predicate {\tt P} evaluates to \keyw{true}. The
    expression {\tt e} will use the identifier {\tt id}. {\tt S} is a set
    of numbers and {\tt id} will be matched to the numbers in the
    normal order (the smallest number first).
  \end{description}
  The syntax and semantics of all sequence expressions are given in
  section~\ref{seqexpr}.%
\index{\texttt{[]}!sequence enumeration}\index{\texttt{["|]}!sequence comprehension}\index{\texttt{\&}!sequence comprehension}

      
\item[Operators:] \mbox{}

  \begin{tabular}{|l|l|l|}\hline
    Operator & Name & Type \\ \hline 
    {\tt \keyw{hd} l} & Head & \TO{\NSEQ{A}}{A} \\
    {\tt \keyw{tl} l} & Tail & \TO{\NSEQ{A}}{\SEQ{A}} \\
    {\tt \keyw{len} l} & Length & \TO{\SEQ{A}}{\keyw{nat}} \\
    {\tt \keyw{elems} l} & Elements & \TO{\SEQ{A}}{\SET{A}} \\
    {\tt \keyw{inds} l} & Indexes & \TO{\SEQ{A}}{\SET{\keyw{nat1}}} \\
    {\tt l1 \char'136\ l2} & Concatenation & \TO{\PROD{(\SEQ{A})}{(\SEQ{A})}}{\SEQ{A}} \\
    {\tt \keyw{conc} ll} & Distributed concatenation & \TO{\SEQ{\SEQ{A}}}{\SEQ{A}}\\
    {\tt l ++ m} & Sequence modification & \TO{\PROD{\SEQ{A}}{\MAP{\keyw{nat1}}{A}}}{\SEQ{A}}\\
    {\tt l(i)} & Sequence application & \TO{\PROD{\SEQ{A}}{\keyw{nat1}}}{A} \\
    {\tt l1 = l2} & Equality & \TO{\PROD{(\SEQ{A})}{(\SEQ{A})}}{\keyw{bool}} \\
    {\tt l1 <> l2} & Inequality & \TO{\PROD{(\SEQ{A})}{(\SEQ{A})}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\keyw{hd}}\index{Head}\index{\keyw{tl}}\index{Tail}%
\index{\keyw{len}}\index{Length}\index{\keyw{elems}}\index{Elements}%
\index{\keyw{inds}}\index{Indexes}\index{\texttt{\char'136}}\index{Concatenation}%
\index{\keyw{conc}}\index{Distributed concatenation}%
\index{\texttt{++}!sequence modification}\index{Sequence modification}%
\index{\texttt{()}!sequence apply}\index{Sequence application}%
\index{\texttt{=}!sequence equality}\index{Equality!sequence type}\index{\texttt{<>}!sequence inequality}\index{Inequality!sequence type}%


  The type {\tt A} is an arbitrary type and the operands for the
  concatenation and distributed concatenation operators do not have
  to be of the same ({\tt A}) type. The type of the resultant sequence
  will be the union type of the types of the operands. Examples will
  be given in section \ref{unions}.

\input{sem-seqtypes}

\item[Examples:] Let \texttt{l1 = [3,1,4,1,5,9,2]}, \texttt{ l2 =
    [2,7,1,8]}, \newline
    \texttt{ l3 = [<England>, <Rumania>, <Colombia>,
    <Tunisia>]} then: 

  \begin{longtable}{lcl}
    \texttt{\keyw{len} l1}        & $\equiv$ & \texttt{7}\\
    \texttt{\keyw{hd} (l1\char'136 l2)}    & $\equiv$ & \texttt{3}\\
    \texttt{\keyw{tl} (l1\char'136 l2)}    & $\equiv$ &
      \texttt{[1,4,1,5,9,2,2,7,1,8]}\\
    \texttt{l3(\keyw{len} l3)}    & $\equiv$ & \texttt{<Tunisia>}\\
    \texttt{"England"(2)}       & $\equiv$ & \texttt{'n'}\\
    \texttt{\keyw{conc} [l1,l2] = l1\char'136 l2} 
                                  & $\equiv$ & \keyw{true}\\
    \texttt{\keyw{conc} [l1,l1,l2] = l1\char'136 l2} 
                                  & $\equiv$ & \keyw{false}\\
    \texttt{\keyw{elems} l3}      & $\equiv$ & \{
      \parbox[t]{5cm}{\texttt{<England>, <Rumania>, }\\
                      \texttt{<Colombia>,<Tunisia>\}}}\\
    \texttt{(\keyw{elems} l1) \keyw{inter} (\keyw{elems} l2)} 
                                  & $\equiv$ & \texttt{\{1,2\}}\\
    \texttt{\keyw{inds} l1}       & $\equiv$ & \texttt{\{1,2,3,4,5,6,7\}}\\
    \texttt{(\keyw{inds} l1) \keyw{inter} (\keyw{inds} l2)}
                                  & $\equiv$ & \texttt{\{1,2,3,4\}}\\
    \texttt{l3 ++ \{2 |-> <Germany>,4 |-> <Nigeria>\}}
                                  & $\equiv$ & [
      \parbox[t]{5cm}{\texttt{<England>, <Germany>, }\\
                      \texttt{<Colombia>, <Nigeria>]}}
  \end{longtable}
\end{description}

\subsubsection{Map Types}\label{maps}

A map type from a type {\tt A} to a type {\tt B} is a type that
associates with each element of {\tt A} (or a subset of {\tt A}) an
element of {\tt B}.  A map value can be thought of as an unordered
collection of pairs.  The first element in each pair is called a key,
because it can be used as a key to get the second element (called the
information part) in that pair. All key elements in a map must therefore
be unique. The set of all key elements is called the domain of the map,
while the set of all information values is called the range of the map.
All maps in \vdmslpp{\vdmsl}{\vdmpp}\ are finite. The domain and range
elements of a map type can be arbitrarily complex, they could e.g. be
maps themselves.

A special kind of map is the injective map. An injective map is one
for which no element of the range is associated with more than one
element of the domain. For an injective map it is possible to invert
the map.

In the following this convention will be used: {\tt m}, {\tt m1} and {\tt
  m2} are maps from an arbitrary type {\tt A} to another arbitrary type
{\tt B}, {\tt ms} is a set of map values, {\tt a}, {\tt a1}, {\tt a2} and
{\tt an} are elements from {\tt A} while {\tt b}, {\tt b1}, {\tt b2} and
{\tt bn} are elements from {\tt B} and {\tt P} is a logic predicate. {\tt
  e1} and {\tt e2} are arbitrary expressions and {\tt s} is an arbitrary
set.

\begin{description}
\item[Syntax:] 
  \Rule{type}{
    \Ruleref{map type} \dsep
    \ldots
    }
  
  \Rule{map type}{\Ruleref{general map type} \dsep
    \Ruleref{injective map type}}
  
  \Rule{general map type}{\Lop{map}, \Ruleref{type}, \Lop{to}, \Ruleref{type}}
  
  \Rule{injective map type}{\Lop{inmap}, \Ruleref{type}, \Lop{to}, \Ruleref{type}}

\item[Equation:] {\tt M = \keyw{map} A \keyw{to} B} or {\tt M =
    \keyw{inmap} A \keyw{to} B}\index{\keyw{map to}}\index{\keyw{inmap to}}

\item[Constructors:] \mbox{}

  \begin{description}
  \item[Map enumeration:] {\tt \{a1 |-> b1, a2 |-> b2, \ldots, an |-> bn\}}
    con\-structs a mapping of the enumerated maplets. The empty map will be
    written as {\tt \{|->\}}.

  \item[Map comprehension:] {\tt \{ed |-> er | bd1, \ldots, bdn \& P\}}
    constructs a mapping by evaluating the expressions {\tt ed} and {\tt
      er} on all the possible bindings for which the predicate {\tt P}
    evaluates to \keyw{true}. {\tt bd1, \ldots, bdn} are bindings of
    free identifiers from the expressions {\tt ed} and {\tt er} to sets or types.
  \end{description}
  The syntax and semantics of all map expressions are given in
  section~\ref{mapexpr}.%
\index{\texttt{\{\}}!map enumeration}\index{\texttt{\{"|\}}!map comprehension}\index{\texttt{\&}!map comprehension}


\item[Operators:]\mbox{}

  \begin{tabular}{|l|l|l|}\hline
    Operator & Name & Type \\ \hline 
    {\tt \keyw{dom} m} & Domain & \TO{(\MAP{A}{B})}{\SET{A}} \\
    {\tt \keyw{rng} m} & Range & \TO{(\MAP{A}{B})}{\SET{B}} \\
    {\tt m1 \keyw{munion} m2} & Merge & \TO{\PROD{(\MAP{A}{B})}{(\MAP{A}{B})}}{\MAP{A}{B}} \\
    {\tt m1 ++ m2} & Override & \TO{\PROD{(\MAP{A}{B})}{(\MAP{A}{B})}}{\MAP{A}{B}} \\
    {\tt \keyw{merge} ms} & Distributed merge & \TO{\SET{(\MAP{A}{B})}}{\MAP{A}{B}} \\
    {\tt s <: m} & Domain restrict to & \TO{\PROD{(\SET{A})}{(\MAP{A}{B})}}{\MAP{A}{B}} \\
    {\tt s <-: m} & Domain restrict by & \TO{\PROD{(\SET{A})}{(\MAP{A}{B})}}{\MAP{A}{B}} \\
    {\tt m :> s} & Range restrict to & \TO{\PROD{(\MAP{A}{B})}{(\SET{B})}}{\MAP{A}{B}} \\
    {\tt m :-> s} & Range restrict by & \TO{\PROD{(\MAP{A}{B})}{(\SET{B})}}{\MAP{A}{B}} \\
    {\tt m(d)} & Map apply & \TO{\PROD{(\MAP{A}{B})}{A}}{B} \\
    {\tt m1 \keyw{comp} m2} & Map composition & \TO{\PROD{(\MAP{B}{C})}{(\MAP{A}{B})}}{\MAP{A}{C}} \\
    {\tt m ** n} & Map iteration & \TO{\PROD{(\MAP{A}{A})}{\keyw{nat}}}{\MAP{A}{A}} \\
    {\tt m1 = m2} & Equality & \TO{\PROD{(\MAP{A}{B})}{(\MAP{A}{B})}}{\keyw{bool}} \\
    {\tt m1 <> m2} & Inequality & \TO{\PROD{(\MAP{A}{B})}{(\MAP{A}{B})}}{\keyw{bool}} \\
    {\tt \keyw{inverse} m} & Map inverse & \TO{\INMAP{A}{B}}{\INMAP{B}{A}} \\
    \hline
  \end{tabular}%
\index{\keyw{dom}}\index{Domain}\index{\keyw{rng}}\index{Range}%
\index{\keyw{munion}}\index{Merge}\index{\texttt{++}!map override}\index{Override}%
\index{\keyw{merge}}\index{Distribute merge}\index{\texttt{<:}}\index{Domain restrict to}%
\index{\texttt{<-:}}\index{Domain restrict by}\index{\texttt{:>}}\index{Range restrict to}%
\index{\texttt{:->}}\index{Range restrict by}\index{\texttt{()}!map apply}\index{Map apply}%
\index{\keyw{comp}!map composition}\index{Map composition}\index{\texttt{**}}\index{Map iteration}%
\index{\texttt{=}!map equality}\index{Equality!map type}\index{\texttt{<>}!map inequality}\index{Inequality!map type}%
\index{\keyw{inverse}}\index{Map inverse}

\input{sem-maptypes}

\item[Examples:] Let 

  {\ttfamily\selectfont
  \begin{tabular}{l}
    m1 = \{ <France> |-> 9, <Denmark> |-> 4, \\
          \mbox{\hspace{3em}}  <SouthAfrica> |-> 2, <SaudiArabia> |-> 1\}, \\
    m2 = \{ 1 |-> 2, 2 |-> 3, 3 |-> 4, 4 |-> 1 \}, \\
    Europe = \{ <France>, <England>, <Denmark>, <Spain> \}
  \end{tabular}}

  then:

  \begin{longtable}{lcl}
    \texttt{\keyw{dom} m1}           & $\equiv$ & 
       \texttt{\{}\parbox[t]{5.3cm}{%
           \texttt{<France>, <Denmark>,}\\
           \texttt{<SouthAfrica>, <SaudiArabia>\}}}\\
    \\
    \texttt{\keyw{rng} m1}           & $\equiv$ & \texttt{\{1,2,4,9\}}\\
    \\
    \texttt{m1 \keyw{munion} \{<England> |-> 3\}}
                                     & $\equiv$ & 
       \texttt{\{}%
       \parbox[t]{5.3cm}{\ttfamily\selectfont
          <France> |-> 9, \\
          <Denmark> |-> 4,\\
          <England> |-> 3, \\ 
          <SaudiArabia> |-> 1,\\
          <SouthAfrica> |-> 2\}}\\
    \\
    \texttt{m1 ++ \{\parbox[t]{4cm}{\ttfamily\selectfont
       <France> |-> 8,\\ <England> |-> 4\}}}
                                     & $\equiv$ &
       \texttt{\{}%
           \parbox[t]{5.3cm}{\ttfamily\selectfont
              <France> |-> 8, \\
              <Denmark> |-> 4,\\
              <SouthAfrica> |-> 2, 
              <SaudiArabia> |-> 1,\\
              <England> |-> 4\}}\\
    \\
    
    \texttt{\keyw{merge}\{}
         \parbox[t]{5.7cm}{\ttfamily\selectfont
                 \{<France> |-> 9, \\
                   \mbox{\hspace{0.0cm}} <Spain> |-> 4\} \\
                 \{<France> |-> 9, \\
                    \mbox{\hspace{0.0cm}} <England> |-> 3, \\
                    \mbox{\hspace{0.0cm}} <UnitedStates> |-> 1\}\}}
                                     & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont%
         <France> |-> 9, \\
         <England> |-> 3, \\
         <Spain> |-> 4,\\
         <UnitedStates> |-> 1\}}\\ \\
    \\
    \texttt{Europe <: m1}            & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont
          <France> |-> 9, \\
          <Denmark> |-> 4\}}\\
    \\
    \texttt{Europe <-: m1}           & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont
          <SouthAfrica> |-> 2,\\
          <SaudiArabia> |-> 1\}}\\
    \\
    \texttt{m1 :> \{2,...,10\}}      & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont
          <France> |-> 9, \\
          <Denmark> |-> 4, \\
          <SouthAfrica> |-> 2\}}\\
    \\
    \texttt{m1 :-> \{2,...,10\}}     & $\equiv$ &
       \texttt{\{<SaudiArabia> |-> 1\}}\\
    \\
    \texttt{m1 \keyw{comp} (\{"France" |-> <France>\})}
                                     & $\equiv$ & 
       \texttt{\{"France" |-> 9\}}\\
    \\
    \texttt{m2 ** 3}                 & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont
            1 |-> 4, 2 |-> 1, \\
            3 |-> 2, 4 |-> 3 \}}\\
    \\
    \texttt{\keyw{inverse} m2}       & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont
            2 |-> 1, 3 |-> 2, \\
            4 |-> 3, 1 |-> 4 \}}\\
    \\
    \texttt{m2 \keyw{comp} (\keyw{inverse} m2)} & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont
            1 |-> 1, 2 |-> 2,\\
            3 |-> 3, 4 |-> 4 \}}
  \end{longtable}
\end{description}



\subsubsection{Product Types}\label{tuples}

The values of a product type are called tuples. A tuple is a fixed
length list where the i'th element of the tuple must belong to the
i'th element of the product type.

\begin{description}
\item[Syntax:] 
  \Rule{type}{
    \Ruleref{product type} \dsep
    \ldots
    }

  \Rule{product type}{
    \Ruleref{type}, \Lop{{\tt *}}, \Ruleref{type}, \SeqPt{\Lop{{\tt *}}, \Ruleref{type}}
    }

  A product type consists of at least two subtypes.

\item[Equation:] {\tt T = A1 * A2 * \ldots\ * An}\index{\texttt{*}!tuple type}

\item[Constructors:] The tuple constructor: {\tt \keyw{mk\_}(a1, a2,
    \ldots, an)}\index{\keyw{mk\_}!tuple constructor}

    The syntax and semantics for the tuple constructor are given in
    section~\ref{tupexpr}. 
\item[Operators:] \mbox{}

  \begin{tabular}{|l|l|l|} \hline
    Operator & Name & Type \\ \hline
    \texttt{t.\#n}   & Select     & \TO{\PROD{T}{\keyw{nat}}}{Ti}\\
    {\tt t1 = t2}  & Equality   & \TO{\PROD{T}{T}}{\keyw{bool}} \\
    {\tt t1 <> t2} & Inequality & \TO{\PROD{T}{T}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{=}!tuple equality}\index{Equality!tuple}\index{\texttt{<>}!tuple inequality}\index{Inequality!tuple}


  The only operators working on tuples are component select, equality
  and inequality. Tuple components may be accessed using the select
  operator or by matching against a tuple pattern. Details of the
  semantics of the tuple select operator and an example of its use are
  given in section \ref{app-expr}. 

\item[Examples:] Let {\tt a = \keyw{mk\_}(1, 4, 8)}, {\tt b =
    \keyw{mk\_}(2, 4, 8)} then:

  \begin{tabular}{lcl}
    {\tt a = b}     &$\equiv$& \keyw{false}\\
    {\tt a <> b}    &$\equiv$& \keyw{true}\\
    {\tt a = \keyw{mk\_}(2,4)} &$\equiv$& \keyw{false}\\
  \end{tabular}
\end{description}

\subsubsection{Composite Types}\label{records}

Composite types correspond to record types\index{record type} in programming languages.
Thus, elements of this type are somewhat similar to the tuples
described in the section about product types above. The difference
between the record type and the product type is that the different
components of a record can be directly selected by means of
corresponding selector functions. In addition records are tagged with
an identifier which must be used when manipulating the record. The
only way to tag a type is by defining it as a record. It is therefore
common usage to define records with only one field in order to give it
a tag. This is another difference to tuples as a tuple must have at
least two entries whereas records can be empty.

In \vdmslpp{\vdmsl,}{\vdmpp,} \keyw{is\_} is a reserved prefix for names
and it is used in an {\it is expression}. This is a built-in operator
which is used to determine which record type a record value belongs to.
It is often used to discriminate between the subtypes of a union type
and will therefore be explained further in section~\ref{unions}. In
addition to record types the \keyw{is\_} operator can also determine if
a value is of one of the basic types.
 
In the following this convention will be used: {\tt A} is a record
type, {\tt A1, \ldots, Am} are arbitrary types, {\tt r}, {\tt r1}, and
{\tt r2} are record values, {\tt i1, \ldots, im} are selectors from
the {\tt r} record value, {\tt e1, \ldots, em} are arbitrary
expressions.

\begin{description}
\item[Syntax:] 
  \Rule{type}{
    \Ruleref{composite type} \dsep
    \ldots
    }
  
  \Rule{composite type}{
    \Lop{compose}, \Ruleref{identifier}, \Lop{of}, \Ruleref{field list},
    \Lop{end}
    }
  
  \Rule{field list}{\SeqPt{\Ruleref{field}}}
  
  \Rule{field}{\OptPt{\Ruleref{identifier}, \Lit{:}}, \Ruleref{type}
  \dsep  \OptPt{\Ruleref{identifier}, \Lit{:-}}, \Ruleref{type}
  }
  
  or the shorthand notation
  
  \Rule{composite type}{
    \Ruleref{identifier}, \Lit{::}, \Ruleref{field list}}
  
  where identifier denotes both the type name and the tag name.

\item[Equation:]\mbox{}\label{a-type}
  \begin{alltt}
    A :: selfirst : A1
         selsec   : A2
  \end{alltt}%
\index{\texttt{::}}

  or

  \begin{alltt}
    A :: selfirst :  A1
         selsec   :- A2
  \end{alltt}%
\index{\texttt{:-}}

  or

  \begin{alltt}
    A :: A1 A2
  \end{alltt}

  In the second notation, an {\it equality abstraction\/} field
  \index{equality abstraction field} is
  used for the second field {\tt selsec}. The minus indicates that
  such a field is ignored when comparing records using the equality
  operator.  In the last notation the fields of {\tt A} can only be
  accessed by pattern matching (like it is done for tuples) as the
  fields have not been named.
  
  In the last notation the fields of {\tt A} can only be accessed by
  pattern matching (as is done for tuples) since the fields have not
  been named.

  The shorthand notation {\tt ::} used in the two previous examples
   where the tag name equals the type
  name, is the notation most used.
  The more general \keyw{compose} notation is typically used if a
  composite type has to be specified directly as a component of a more
  complex type:
  \begin{alltt}
    T = \keyw{map} S \keyw{to compose} A \keyw{of} A1 A2 \keyw{end}
  \end{alltt}
  It should be noted however that composite types can only be used in
  type definitions, and not e.g.\ in signatures to functions or
  operations. 

  Typically composite types are used as alternatives in a union type
  definition (see~\ref{unions}) such as:

  \begin{alltt}
   MasterA = A | B | ...
  \end{alltt}
  where \texttt{A} and \texttt{B} are defined as composite types
  themselves. In this situation the \keyw{is\_} predicate can be used
  to distingush the alternatives.

\item[Constructors:] The record constructor: {\tt \keyw{mk\_}A(a, b)} where
  {\tt a} belongs to the type {\tt A1} and {\tt b} belongs to the type {\tt
    A2}.

  The syntax and semantics for all record expressions are given in
  section~\ref{recexpr}.%
\index{\keyw{mk\_}!record constructor}

\item[Operators:] \mbox{}

  \begin{tabular}{|l|l|l|} \hline
    Operator & Name & Type \\ \hline
    {\tt r.i} & Field select & \TO{\PROD{A}{Id}}{Ai} \\
    {\tt r1 = r2} & Equality & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    {\tt r1 <> r2} & Inequality & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    {\tt \keyw{is\_}A(r1)} & Is & \TO{\PROD{Id}{MasterA}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{.}!record field selector}\index{Field select}%
\index{\texttt{=}!record equality}\index{Equality!record}\index{\texttt{<>}!record inequality}\index{Inequality!record}

\input{sem-comtypes}

\item[Examples:] Let \texttt{Score} be defined as
\begin{alltt}\label{scoredef}
   Score :: team : Team
            won : \keyw{nat}
            drawn : \keyw{nat}
            lost : \keyw{nat}
            points : \keyw{nat};
   Team = <Brazil> | <France> | ...
\end{alltt}
and let 

\begin{tabular}{l}
\texttt{sc1 = \keyw{mk\_}Score (<France>, 3, 0, 0, 9)}, \\
\texttt{sc2 = \keyw{mk\_}Score (<Denmark>, 1, 1, 1, 4)},\\
\texttt{sc3 = \keyw{mk\_}Score (<SouthAfrica>, 0, 2, 1, 2)} and \\
\texttt{sc4 = \keyw{mk\_}Score (<SaudiArabia>, 0, 1, 2, 1)}.
\end{tabular}

\noindent%
Then

  \begin{tabular}{lcl}
    \texttt{sc1.team}            & $\equiv$ & \texttt{<France>}\\
    \texttt{sc4.points}          & $\equiv$ & \texttt{1}\\
    \texttt{sc2.points > sc3.points} 
                                 & $\equiv$ & \keyw{true}\\
    \texttt{\keyw{is\_}Score(sc4)} 
                                 & $\equiv$ & \keyw{true}\\
    \texttt{\keyw{is\_bool}(sc3)}
                                 & $\equiv$ & \keyw{false}\\
    \texttt{\keyw{is\_int}(sc1.won)}
                                 & $\equiv$ & \keyw{true}\\
    \texttt{sc4 = sc1}           & $\equiv$ & \keyw{false}\\
    \texttt{sc4 <> sc2}          & $\equiv$ & \keyw{true}  
  \end{tabular}

  The equality abstraction field, written using `{\tt :-}' instead of
  `{\tt :}', may be useful, for example, when working with lower level
  models of an abstract syntax of a programming language. For example,
  one may wish to add a position information field to a type of
  identifiers without affecting the true identity of identifiers:

\begin{alltt}
  Id :: name :  seq of char
        pos  :- nat
\end{alltt}

The effect of this will be that the {\tt pos} field is
ignored in equality comparisons, e.g.\
the following would evaluate to true:

\begin{alltt}
  mk_Id("x",7) = mk_Id("x",9)
\end{alltt}

In particular this can be useful when looking up in an environment
which is typically modelled as a map of the following form:

\begin{alltt}
  Env = map Id to Val
\end{alltt}

Such a map will contain at most one index for a specific identifier,
and a map lookup will be independent of the {\tt pos} field.

Moreover, the equality abstraction field will affect set expressions.
For example, 
\begin{alltt}
  \{mk_Id("x",7),mk_Id("y",8),mk_Id("x",9)\}
\end{alltt}

will be equal to

\begin{alltt}
  \{mk_Id("x",?),mk_Id("y",8)\}
\end{alltt}

where the question mark stands for 7 or 9.

Finally, note that for equality abstraction fields valid patterns are
limited to don't care and identifier patterns. Since equality
abstraction fields are ignored when comparing two values, it does not
make sense to use more complicated patterns.
\end{description}

\subsubsection{Union and Optional Types}\label{unions}

The union type corresponds to a set-theoretic union, i.e.\ the type
defined by means of a union type will contain all the elements from
each of the components of the union type. It is possible to use types
that are not disjoint in the union type, even though such usage
would be bad practice.  However, the union type is normally used when
something belongs to one type from a set of possible types.  The
types which constitute the union type are often composite types.  This
makes it possible, using the \keyw{is\_} operator, to decide which of
these types a given value of the union type belongs to.

The optional type {\tt [T]} is a kind of shorthand for a union type {\tt T |
  \keyw{nil}}, where \keyw{nil} is used to denote the absence of a
value. However, it is not possible to use the set {\tt \{\keyw{nil}\}}
as a type so the only types \keyw{nil} will belong to will be optional
types. 


\begin{description}
\item[Syntax:] 
  \Rule{type}{
    \Ruleref{union type} \dsep
    \Ruleref{optional type} \dsep
    \ldots
    }
  
  \Rule{union type}{
    \Ruleref{type}, \Lit{|}, \Ruleref{type}, \SeqPt{\Lit{|}, \Ruleref{type}}
    }
  
  \Rule{optional type}{\Lit{[}, \Ruleref{type}, \Lit{]}}

\item[Equation:] {\tt B = A1 | A2 | \ldots\ | An}%
\index{\texttt{|}!union type}\index{\texttt{[]}!optional type}

\item[Constructors:] None.

\item[Operators:] \mbox{}

  \begin{tabular}{|l|l|l|}\hline
    Operator & Name & Type \\ \hline
    {\tt t1 = t2} & Equality & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    {\tt t1 <> t2} & Inequality & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{=}!union equality}\index{Equality!union type}%
\index{\texttt{<>}!union inequality}\index{Inequality!union type}%
\index{\texttt{=}!optional equality}\index{Equality!optional type}%
\index{\texttt{<>}!optional inequality}\index{Inequality!optional type}


\item[Examples:] In this example {\tt Expr} is a union type whereas
  {\tt Const}, {\tt Var}, {\tt Infix} and {\tt Cond} are composite
  types defined using the shorthand {\tt ::} notation.

  \begin{alltt}\label{exprdef}
    Expr  = Const | Var | Infix | Cond;
    Const :: \keyw{nat} | \keyw{bool};
    Var   :: id:Id
             tp: [<Bool> | <Nat>];
    Infix :: Expr * Op * Expr;
    Cond  :: test : Expr
             cons : Expr
             altn : Expr
  \end{alltt}    
  and let {\tt expr = \keyw{mk\_}Cond(\keyw{mk\_}Var("b",<Bool>),%
    \keyw{mk\_}Const(3),}\\ {\tt \keyw{mk\_}Var("v",\keyw{nil}))} then:

  \begin{tabular}{lcl}\label{exprIsExs}
    {\tt \keyw{is\_}Cond(expr)} &$\equiv$& \keyw{true}\\
    {\tt \keyw{is\_}Const(expr.cons)} &$\equiv$& \keyw{true}\\
    {\tt \keyw{is\_}Var(expr.altn)}   &$\equiv$& \keyw{true}\\
    {\tt \keyw{is\_}Infix(expr.test)}  &$\equiv$& \keyw{false}\\
  \end{tabular}

  Using union types we can extend the use of previously defined
    operators. For instance, interpreting \texttt{=} as a test over
    \texttt{\keyw{bool} | \keyw{nat}} we have
 
 \begin{tabular}{lcl}
    \texttt{1 = \keyw{false}}    & $\equiv$ & \keyw{false}
  \end{tabular}

  Similarly we can take use union types for taking unions of sets and
    concatenating sequences:
  
  \begin{tabular}{lcl}
     \texttt{ \{1,2\} \keyw{union} \{\keyw{false},\keyw{true}\}}
                                 & $\equiv$ & 
        \texttt{\{1,2, \keyw{false},\keyw{true}\}}\\
     \texttt{ ['a','b']\char'136 [<c>,<d>]}
                                 & $\equiv$ &
        \texttt{['a','b', <c>,<d>]}
  \end{tabular}

  In the set union, we take the union over sets of type
    \texttt{\keyw{nat} | \keyw{bool}}; for the sequence concatenation
    we are manipulating sequences of type \texttt{\keyw{char} | <c> |
    <d>}. 
\end{description}


\subsubsection{Function Types}

In \vdmslpp{\vdmsl}{\vdmpp} function types can also be used in type
definitions.  A function type from a type {\tt A} (actually a list of
types) to a type {\tt B} is a type that associates with each element
of {\tt A} an element of {\tt B}. A function value can be thought of
as a function in a programming language which has no side-effects
(i.e.\ it does not use any global variables).

Such usage can be considered advanced in the sense
that functions are used as values (thus this section
may be skipped during the first reading). Function values may be created by
lambda expressions (see below), or by function definitions, which are
described in section~\ref{functiondef}.  Function values can be of
higher order in the sense that they can take functions as arguments or
return functions as results. In this way functions can be Curried such
that a new function is returned when the first set of parameters are
supplied (see the examples below).

%Type definitions may not be recursive {\it through} function types, though
%they may be recursive {\it over} them. That is, no chain of
%definitions derived from a set of recursive type definitions from a
%type back to itself may pass through a function type operator (see the
%next subsection for more information about recursive type
%definitions). Thus, a type definition like {\tt A = A -> A |
%\keyw{bool}} is illegal while a type definition like: {\tt A = A * A |
%(\keyw{nat} -> \keyw{nat})} is legal.

\begin{description}
\item[Syntax:]
  \Rule{type}{
    \Ruleref{partial function type} \dsep
    \ldots
    }
  
  \Rule{function type}{
    \Ruleref{partial function type} \dsep
    \Ruleref{total function type}
    }

  \Rule{partial function type}{
    \Ruleref{discretionary type}, \Lit{->}, \Ruleref{type}}
  
  \Rule{total function type}{
    \Ruleref{discretionary type}, \Lit{+>}, \Ruleref{type}}
  
  \Rule{discretionary type}{\Ruleref{type} \dsepl \Lit{(},\Lit{)}} 
  
\item[Equation:] {\tt F = A +> B}\footnote{Note that the total
function arrow can only be used in signatures of totally defined
functions and thus not in a type definition.} or {\tt F = A -> B}%
\index{\texttt{->}}\index{\texttt{+>}}

\item[Constructors:] In addition to the traditional function
  definitions the only way to construct functions is by the lambda
  expression: {\tt \keyw{lambda} pat1 : T1, \ldots, patn : Tn \& body}
  where the {\tt patj} are patterns, the {\tt Tj} are type expressions, and
  {\tt body} is the body expression which may use the pattern
  identifiers from all the patterns.

  The syntax and semantics for the lambda expression are given in
  section~\ref{lambda}.
\item[Operators:] \mbox{}

  \begin{tabular}{|l|l|l|} \hline
    Operator & Name & Type \\ \hline
    {\tt f(a1,\ldots,an)} & Function apply & \TO{A1 * \cdots * An}{B} \\
    {\tt f1 \keyw{comp} f2}& Function composition & \TO{\PROD{(\FUN{B}{C})}{(\FUN{A}{B})}}{(\FUN{A}{C})} \\
    {\tt f ** n} & Function iteration & \TO{\PROD{(\FUN{A}{A})}{\keyw{nat}}}{(\FUN{A}{A})} \\
    {\tt t1 = t2} & Equality & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    {\tt t1 <> t2} & Inequality & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{=}!function equality}\index{Equality!function type}\index{\texttt{<>}!function inequality}\index{Inequality!function type}%
\index{\keyw{comp}!function composition}\index{Function composition}%
\index{\texttt{**}!function iteration}\index{Function iteration}%
\index{\texttt{()}!function apply}\index{Function apply}
  
  Note that equality and inequality between type values should be used
  with great care. In \vdmslpp{\vdmsl}{\vdmpp}\ this corresponds to the
  mathematical equality (and inequality) which is not computable for
  infinite values like general functions. Thus, in the
  interpreter the
  equality is on the abstract syntax of the function value (see {\tt
    inc1} and {\tt inc2} below).

\input{sem-functypes}

\item[Examples:] Let the following function values be defined:
  \begin{alltt}
    f1 = \keyw{lambda} x : \keyw{nat} \& \keyw{lambda} y : \keyw{nat} \& x + y
    f2 = \keyw{lambda} x : \keyw{nat} \& x + 2
    inc1 = \keyw{lambda} x : \keyw{nat} \& x + 1
    inc2 = \keyw{lambda} y : \keyw{nat} \& y + 1
  \end{alltt}
  then the following holds:
  
  \begin{tabular}{lcl}
    {\tt f1(5)} &$\equiv$& {\tt \keyw{lambda} y :\keyw{nat} \& 5 + y}\\
    {\tt f2(4)} &$\equiv$& {\tt 6}\\
    {\tt f1 \keyw{comp} f2}&$\equiv$& {\tt \keyw{lambda} x :\keyw{nat} \&
      \keyw{lambda} y :\keyw{nat} \& (x + 2) + y}\\
    {\tt f2 ** 4}&$\equiv$& {\tt \keyw{lambda} x :\keyw{nat} \& x + 8}\\
    {\tt inc1 = inc2}&$\equiv$& \keyw{false}\\
  \end{tabular}
  
  Notice that the equality test does not yield the expected result with
  respect to the semantics of \vdmslpp{\vdmsl}{\vdmpp}. Thus, one should
  be {\bf very} careful with the usage of equality for infinite values
  like functions.
\end{description}

%\subsection{Recursive Types}
%
%In the data type equations given so far we have only used the equations in
%a hierarchical manner (the data type identifiers occurring on the
%right-hand-side in the equations have already been defined).  However,
%there are occasions when it is appropriate to use a collection of
%equations which are mutually recursive. 
%
%Without going into the mathematical details about how such recursive
%equations are solved, it will shortly be explained what they denote and how
%their usage must be restricted. We define that the semantics of such a
%collection of mutually recursive equations is that the data types become
%the set of all those values which can be constructed by using the equations
%a finite number of times. Thus, types containing infinite values cannot be
%constructed by means of recursive definitions.
%
%In order to achieve this, the recursive equations need to fulfill two
%requirements:
%\begin{enumerate}
%\item There must exist at least one alternative in a union type which is
%  fully defined elsewhere (a so-called base case).
%
%\item It must not be possible for a data value to belong to two different
%  alternatives in a union type. Thus, for recursive equations the
%  alternatives in union types must be disjunct.
%\end{enumerate}
%If these two requirements are fulfilled then the recursive type definitions
%are interpreted as the collection of finite values which are constructed by
%a finite number of steps in this process.
%
%To illustrate the use of recursive type definitions here is an example
%modelling a forest using recursive type definitions.
%
%\begin{alltt}
%  Forest = Forest * Node * Forest;
%  Node = \keyw{nat} | Forest
%\end{alltt}
%
%\noindent It is clear that the first requirement (1) cannot be fulfilled,
%because there is no base case for the forest type. Thus, these type
%definitions only specify infinite forests, and thus are not valid in
%\vdmslpp{\vdmsl}{\vdmpp}.
%
%Let us try to repair this by letting a node be the base case in the
%first definition:
%
%\begin{alltt}
%  Forest = Node | (Forest * Node * Forest);
%  Node = \keyw{nat} | Forest
%\end{alltt}
%
%\noindent However, these two definitions do not fulfill the second
%requirement. This can be seen from the fact that a forest can be a node, and that
%node in turn can be a forest, etc. In this case it is not possible to say
%which alternative a given value belongs to. Thus, these definitions are
% not valid in \vdmslpp{\vdmsl}{\vdmpp}\ either.
%
%Now let us try to repair it by letting the base case be empty (i.e.\ 
%a nil value):
%
%\begin{alltt}
%  Forest = [Forest * Node * Forest];
%  Node = \keyw{nat} | Forest
%\end{alltt}
%
%\noindent These definitions are valid, but they specify something slightly
%different than the intention behind the definitions above. With these
%definitions an empty forest exists, and this is not the case for the
%definitions above.
%
%Finally we try to repair it by means of tagging:
%
%\begin{alltt}
%  Forest = Node | (Forest * Node * Forest);
%  Node :: \keyw{nat} | Forest
%\end{alltt}
%
%\noindent By making {\tt Node} a composite type, the definitions are valid,
%because the second requirement is also fulfilled here, due to tagging of
%the node. With these definitions an empty forest will not exist.
%
\subsection{Invariants}

If the data types specified by means of equations as described above
contain values which should not be allowed, then it is possible to restrict
the values in a type by means of an invariant. The result is that the type
is restricted to a subset of its original values. Thus, by means of a
predicate the acceptable values of the defined type are limited to those
where this expression is true.

The general scheme for using invariants looks like this:

\begin{alltt}
  Id = Type
  \keyw{inv} pat == expr
\end{alltt}

\noindent where {\tt pat} is a pattern matching the values belonging to the type
{\tt Id}, and {\tt expr} is a truth-valued expression, involving some or
all of the identifiers from the pattern {\tt pat}.

If an invariant is defined, a new (total) function is implicitly
created with the signature:
\begin{alltt}
  \keyw{inv\_}Id : Type +> \keyw{bool}
\end{alltt}
This function can be used within other invariant, function or operation
definitions.

For instance, recall the record type \texttt{Score} defined on page
\pageref{scoredef}. We can ensure that the number of points awarded
is consistent with the number of games won and drawn using an invariant:
\begin{alltt}
  Score :: team : Team
           won : nat
           drawn : nat
           lost : nat
           points : nat
  inv sc == sc.points = 3 * sc.won + sc.drawn;
\end{alltt}
The invariant function implicitly created for this type is:
\begin{alltt}
  \keyw{inv\_}Score : Score +> \keyw{bool}
  \keyw{inv\_}Score (sc) == 
    sc.points = 3 * sc.won + sc.drawn;
\end{alltt}

\section{Algorithm Definitions}
\label{algorithm}


In \vdmslpp{\vdmsl}{\vdmpp} algorithms can be defined by both
functions and operations.  However, they do not directly correspond to
functions in traditional programming languages. What separates
functions from operations in \vdmslpp{\vdmsl}{\vdmpp} is the use of
local and global variables. Operations can manipulate both the global
variables and any local variables.  Both
local and global variables will be described later. Functions are pure in
the sense that they cannot access global variables and they are not
allowed to define local variables. Thus, functions are purely
applicative while operations are imperative.

Functions and operations can be defined both explicitly (by means of
an explicit algorithm definition) or implicitly (by means of a
pre-condition and/or a post condition).  An explicit algorithm
definition for a function is called an expression while for an
operation it is called a statement.  A pre-condition is a truth-valued
expression which specifies what must hold before the
function/operation is evaluated. A pre-condition can only refer to
parameter values and global variables (if it is an operation).  A
post-condition is also a truth valued expression which specifies what
must hold after the function/operation is evaluated. A post-condition
can refer to the result identifier, the parameter values, the current
values of global variables and the old values of global variables. The
old values of global variables are the values of the variables as they
were before the operation was evaluated.  Only operations can refer to
the old values of global variables in a post-condition as functions
are not allowed to change the global variables.

However, in order to be able to execute both functions and operations
by the interpreter they must be defined explicitly\footnote{Implicitly
specified functions and operations cannot in general be executed
because their post-condition does not need to directly relate the
output to the input. Often it is done by specifying the properties the
output must satisfy.}. In \vdmslpp{ VDM-SL}{\vdmpp} it is also
possible for explicit function and operation definitions to specify an
additional pre- and a post-condition.  In the post-condition of 
explicit function and operation definitions the result value must be
referred to by the reserved word \keyw{RESULT}.
 
\section{Function Definitions}\label{functiondef}

In \vdmslpp{ VDM-SL}{\vdmpp} we can define first order and higher order
functions. A higher order function is either a Curried function
(a function that returns a function as result), or a function that takes
functions as arguments. Furthermore, both first order and higher order
functions can be polymorphic. In general, the syntax for the definition of a
function is:

\Rule{function definitions}{
  \Lop{functions}, 
  \OptPt{\ifthenelse{\boolean{VDMpp}}{\Ruleref{access function definition}}%
                                     {\Ruleref{function definition}}, \lfeed
         \SeqPt{\Lit{;}, 
                \ifthenelse{\boolean{VDMpp}}{\Ruleref{access function definition}}%
                                     {\Ruleref{function definition}}}, 
         \OptPt{\Lit{;}}
        }
  }

\ifthenelse{\boolean{VDMpp}}{
  \Rule{access function definition}{
    (\OptPt{\Ruleref{access}}, \OptPt{\Lop{static}})  \dsepl\  (\OptPt{\Lop{static}}, \OptPt{\Ruleref{access}}), \lfeed
      \Ruleref{function definition}
  }}{}


\ifthenelse{\boolean{VDMpp}}{
  \Rule{access}{
    \Lop{public} \dsep \Lop{private} \dsep \Lop{protected}
  }
}{}

\Rule{function definition}{
  \Ruleref{explicit function definition} \dsep
  \Ruleref{implicit function definition} \dsep
  \Ruleref{extended explicit function definition}
  }

\Rule{explicit function definition}{
  \Ruleref{identifier}, 
\lfeed
  \OptPt{\Ruleref{type variable list}}, 
  \Lit{:}, \Ruleref{function type}, \lfeed
  \Ruleref{identifier}, \Ruleref{parameters list}, \Lit{$==$}, \lfeed
  \Ruleref{function body}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{expression}}, \lfeed
  \OptPt{\Lop{measure}, \Ruleref{name}}
  }                                 

\Rule{implicit function definition}{
  \Ruleref{identifier}, 
  \OptPt{\Ruleref{type variable list}},\lfeed
  \Ruleref{parameter types}, \Ruleref{identifier type pair list}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
  \Lop{post}, \Ruleref{expression}
}

\Rule{extended explicit function definition}{
  \Ruleref{identifier}, \OptPt{\Ruleref{type variable list}}, \lfeed
  \Ruleref{parameter types},\lfeed
  \Ruleref{identifier type pair list}, \lfeed
  \Lit{==}, \Ruleref{function body}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{expression}}
}

\Rule{type variable list}{
  \Lit{[}, \Ruleref{type variable identifier}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{type variable identifier}}, \Lit{]}
  }

\Rule{identifier type pair list}{
  \Ruleref{identifier}, \Lit{:}, \Ruleref{type}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{identifier}, \Lit{:}, \Ruleref{type}}
}

\Rule{parameter types}{
  \Lit{(}, \OptPt{\Ruleref{pattern type pair list}}, \Lit{)}
  }

\Rule{pattern type pair list}{
  \Ruleref{pattern list}, \Lit{:}, \Ruleref{type}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{pattern list},\Lit{:}, \Ruleref{type}}
  }

\Rule{function type}{
  \Ruleref{partial function type} \dsep
  \Ruleref{total function type}
  }

\Rule{partial function type}{
  \Ruleref{discretionary type}, \Lit{->}, \Ruleref{type}
  }

\Rule{total function type}{
  \Ruleref{discretionary type}, \Lit{+>}, \Ruleref{type}
  }

\Rule{discretionary type}{
  \Ruleref{type} \dsepl \Lit{(},\Lit{)}
  }

\Rule{parameters}{
  \Lit{(}, \OptPt{\Ruleref{pattern list}}, \Lit{)}
  }

\Rule{pattern list}{
  \Ruleref{pattern},\SeqPt{\Lit{,}, \Ruleref{pattern}}
  }

\Rule{function body}{
  \Ruleref{expression} \dsep 
  \Lop{is not yet specified}\index{\keyw{is not yet specified}!functions}
  }

Here \keyw{is not yet specified} may be used as the function body
during development of a model%
.


A simple example of an explicit function definition is the function
\texttt{map\_inter} which takes two compatible maps over natural
numbers and returns those maplets common to both
\begin{alltt}
  map_inter: (\keyw{map nat to nat}) * (\keyw{map nat to nat}) -> \keyw{map nat to nat}
  map_inter (m1,m2) ==
    (\keyw{dom} m1 \keyw{inter} \keyw{dom} m2) <: m1
  \Keyw{pre} \keyw{forall} d \keyw{in set dom} m1 \keyw{inter dom} m2 & m1(d) = m2(d)
\end{alltt}
Note that we could also use the optional post condition to allow
assertions about the result of the function:
\begin{alltt}
  map_inter: (\keyw{map nat to nat}) * (\keyw{map nat to nat}) -> \keyw{map nat to nat}
  map_inter (m1,m2) ==
    (\keyw{dom} m1 \keyw{inter} \keyw{dom} m2) <: m1
  \Keyw{pre} \keyw{forall} d \keyw{in set dom} m1 \keyw{inter dom} m2 & m1(d) = m2(d)
  \Keyw{post} \keyw{dom} \keyw{RESULT} = \keyw{dom} m1 \keyw{inter} \keyw{dom} m2
\end{alltt}

The same function can also be defined implicitly:
\begin{alltt}
  map_inter2 (m1,m2: \keyw{map nat to nat}) m: \keyw{map nat to nat}
  \Keyw{pre} \keyw{forall} d \keyw{in set dom} m1 \keyw{inter dom} m2 & m1(d) = m2(d)
  \Keyw{post} \keyw{dom} m = \keyw{dom} m1 \keyw{inter dom} m2 and
       \keyw{forall} d \keyw{in set dom} m & m(d) = m1(d);
\end{alltt}

A simple example of an extended explicit function definition
(non-standard) is the function \texttt{map\_disj} which takes a pair of
compatible maps over natural numbers and returns the map consisting of
those maplets unique to one or other of the given maps:

\begin{alltt}\label{mapdisj}
  map_disj (m1:\keyw{map nat to nat},m2:\keyw{map nat to nat}) res : \keyw{map nat to nat} ==
    (\keyw{dom} m1 \keyw{inter dom} m2) <-: m1 \keyw{munion}
    (\keyw{dom} m1 \keyw{inter dom} m2) <-: m2
  \Keyw{pre} \keyw{forall} d \keyw{in set dom} m1 \keyw{inter dom} m2 & m1(d) = m2(d)
  \Keyw{post} \keyw{dom} res = (\keyw{dom} m1 \keyw{union dom} m2) \verb+\+ (\keyw{dom} m1 \keyw{inter dom} m2) 
       and
       \keyw{forall} d \keyw{in set dom} res & res(d) = m1(d) or res(d) = m2(d)
\end{alltt}
(Note here that an attempt to interpret the post-condition could
potentially result in a run-time error since \texttt{m1(d)} and
\texttt{m2(d)} need not both be defined simultaneously.)

The functions {\tt map\_inter} and {\tt map\_disj} can be evaluated by the
interpreter, but the implicit function {\tt map\_inter2} cannot be evaluated.
However, in all three cases the pre- and post-conditions can be used
in other functions; for instance from the definition of
\texttt{map\_inter2} we get functions \texttt{\keyw{pre\_}map\_inter2}
and \texttt{\keyw{post\_}map\_inter2} with the following signatures:

\begin{alltt}
  \keyw{pre\_}map_inter2 : (\keyw{map nat to nat}) * (\keyw{map nat to nat}) +> \keyw{bool}
  \keyw{post\_}map_inter2 : (\keyw{map nat to nat}) * (\keyw{map nat to nat}) *
                   (\keyw{map nat to nat}) +> \keyw{bool}
\end{alltt}
These kinds of functions are automatically created by the
interpreter and they can be used in other definitions (this technique
is called quoting). In general, for a function \texttt{f} with
signature
\begin{alltt}
  f : T1 * ... * Tn -> Tr
\end{alltt}
defining a pre-condition for the function causes creation of a
function \texttt{\keyw{pre\_}f} with signature
\begin{alltt}
  \keyw{pre\_}f : T1 * ... * Tn +> bool
\end{alltt}
and defining a post-condition for the function causes creation of a
function \texttt{\keyw{post\_}f} with signature
\begin{alltt}
  \keyw{post\_}f : T1 * ... * Tn * Tr +> bool
\end{alltt}

Functions can also be defined using recursion (i.e.\ by calling
themselves). When this is done one is recommended to add
a \Lop{measure} function that can be used in the proof obligations
generated from the model such that termination proofs can be carried
out. A simple example here could be the traditional factorial function
defined as:
\begin{alltt}
functions

fac: nat +> nat
fac(n) ==
  if n = 0
  then 1
  else n * fac(n - 1)
measure id
\end{alltt}
where \texttt{id} would be defined as:
\begin{alltt}
id: nat +> nat
id(n) == n
\end{alltt}

\subsection{Polymorphic Functions}

Functions can also be polymorphic. This means that we can create
generic functions that can be used on values of several different
types. For this purpose type parameters (or type variables which are
written like normal identifiers prefixed with a {\tt @} sign) are
used. Consider the polymorphic function to create an empty
bag:\footnote{The examples for polymorphic functions are taken from
\cite{Dawes91}. Bags are modelled as maps from the elements to their
multiplicity in the bag. The multiplicity is at least 1, i.e.\ a
non-element is not part of the map, rather than being mapped to 0.}
\begin{alltt}
  empty_bag[@elem] : () +> (\keyw{map} @elem \keyw{to nat1})
  empty_bag() ==
    \{ |-> \}
\end{alltt}
Before we can use the above function, we have to instantiate the
function {\tt empty\_bag} with a type, for example integers (see also
section~\ref{app-expr}):
\begin{alltt}
  emptyInt = empty_bag[int]
\end{alltt}
Now we can use the function {\tt emptyInt} to create a new bag to store
integers. More examples of polymorphic functions are:
\begin{alltt}
  num_bag[@elem] : @elem * (\keyw{map} @elem \keyw{to nat1}) +> \keyw{nat}
  num_bag(e, m) ==
    \keyw{if} e \keyw{in set dom} m
    \Keyw{then} m(e)
    \Keyw{else} 0;

  plus_bag[@elem] : @elem * (\keyw{map} @elem \keyw{to nat1}) +> (\keyw{map} @elem \keyw{to nat1})
  plus_bag(e, m) ==
    m ++ \{ e |-> num_bag[@elem](e, m) + 1 \}
\end{alltt} 
If pre- and or post-conditions are defined for polymorphic functions, the
corresponding predicate functions are also polymorphic. For instance
if \texttt{num\_bag} was defined as
\begin{alltt}
  num_bag[@elem] : @elem * (\keyw{map} @elem \keyw{to nat1}) +> \keyw{nat}
  num_bag(e, m) ==
    m(e)
  \Keyw{pre} e \keyw{in set dom} m
\end{alltt}
then the pre-condition function would be
\begin{alltt}
  \keyw{pre\_}num_bag[@elem] :@elem * (\keyw{map} @elem \keyw{to nat1}) +> \keyw{bool}
\end{alltt}

In case functions are defined polymorphic a \keyw{measure} should also be
used.

\subsection{Higher Order Functions}

Functions are allowed to receive other functions as arguments. A
simple example of this is the function \texttt{nat\_filter} which
takes a sequence of natural numbers, and a predicate, and returns the
subsequence that satisfies this predicate:
\begin{alltt}
  nat_filter : (\keyw{nat} -> \keyw{bool}) * \keyw{seq of nat} -> \keyw{seq of nat}
  nat_filter (p,ns) ==
    [ns(i) | i \keyw{in set inds} ns & p(ns(i))];
\end{alltt}
Then 
  \texttt{nat\_filter (\keyw{lambda} x:\keyw{nat} \& x \keyw{mod} 2 = 0, [1,2,3,4,5])} $\equiv$ \texttt{[2,4]}.
In fact, this algorithm is not specific to natural numbers, so we may
define a polymorphic version of this function:
\begin{alltt}\label{filterdef}
  filter[@elem]: (@elem -> \keyw{bool}) * \keyw{seq of} @elem -> \keyw{seq of} @elem
  filter (p,l) ==
    [l(i) | i \keyw{in set inds} l & p(l(i))];
\end{alltt}
so \texttt{filter[\keyw{real}](\keyw{lambda} x:\keyw{real} \&
  \keyw{floor} x = x, [2.3,0.7,-2.1,3])} $\equiv$  \texttt{[3]}.


Functions may also return functions as results. An example of this is
the function \texttt{fmap}:
\begin{alltt}
  fmap[@elem]: (@elem -> @elem) -> \keyw{seq} of @elem -> \keyw{seq} of @elem
  fmap (f)(l) ==
    \keyw{if} l = []
    \keyw{then} []
    else [f(\keyw{hd} l)]\verb+^+(fmap[@elem] (f)(\keyw{tl} l));
\end{alltt}
So \texttt{fmap[\keyw{nat}](\keyw{lambda} x:\keyw{nat} \& x * x)([1,2,3,4,5])} $\equiv$ 
\texttt{[ 1,4,9,16,25 ]}

\section{Expressions}

In this subsection we will describe the different kinds of expressions
one by one. Each of them will be described by means of:
\begin{itemize}
\item A syntax description in BNF.
\item An informal semantics description.
\item An example illustrating its usage.
\end{itemize}

\subsection{Let Expressions}\label{let-exp}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \Ruleref{let expression} \dsep
    \Ruleref{let be expression} \dsep
    \ldots
    }

  \Rule{let expression}{
    \Lop{let}, 
    \Ruleref{local definition}
    \SeqPt{\Lit{,}, \Ruleref{local definition}}, \lfeed
    \Lop{in}, \Ruleref{expression}
    }

  \Rule{let be expression}{ 
    \Lop{let}, \Ruleref{bind},
    \OptPt{\Lop{be}, \Lop{st}, \Ruleref{expression}}, \Lop{in}, \lfeed
    \Ruleref{expression}
    } 

  \Rule{local definition}{
    \Ruleref{value definition} \dsep
    \Ruleref{function definition}
    }

  \Rule{value definition}{ 
    \Ruleref{pattern}, \OptPt{\Lit{:}, \Ruleref{type}}, \Lit{=}, \Ruleref{expression}
    }

  \noindent where the ``function definition'' component is described in
  section~\ref{functiondef}.

\item[Semantics:] A simple {\it let expression} has the form:
  \begin{alltt}
    \keyw{let} p1 = e1, \ldots, pn = en \keyw{in} e
  \end{alltt}
  where {\tt p1, \ldots, pn} are patterns, {\tt e1, \ldots, en} are
  expressions which match the corresponding pattern {\tt pi}, and
  {\tt e} is an expression, of any type, involving the pattern
  identifiers of {\tt p1, \ldots, pn}. It denotes the value of the
  expression {\tt e} in the context in which the patterns {\tt p1,
    \ldots, pn} are matched against the corresponding expressions {\tt
    e1, \ldots, en}.

  More advanced let expressions can also be made by using local
  function definitions. The semantics of doing so is simply that the
  scope of such locally defined functions is restricted to the body of
  the let expression.

  In standard \vdmsl\ the collection of definitions may be mutually
  recursive.  However, in  \vdmslpp{\vdmsl}{\vdmpp} this is not
  supported by the interpreter.  Furthermore, the definitions must be
  ordered such that all constructs are defined before they are used.
     
  A {\it let-be-such-that expression} has the form:
  \begin{alltt}
    \keyw{let} b \keyw{be st} e1 \keyw{in} e2
  \end{alltt}%
  where {\tt b} is a binding of a pattern to a set value (or a type),
  {\tt e1} is a boolean expression, and {\tt e2} is an expression, of
  any type, involving the pattern identifiers of the pattern in {\tt
    b}. The {\tt \keyw{be st} e1} part is optional. The expression
  denotes the value of the expression {\tt e2} in the context in which
  the pattern from {\tt b} has been matched against either an element
  in the set from {\tt b} or against a value from the type in {\tt b}%
  \footnote{Remember that only the set bindings can be executed by
    means of the interpreter.}.
  If the {\tt \keyw{st} e1} expression is present, only such bindings
  where {\tt e1} evaluates to true in the matching context are used.

\item[Examples:] {\it Let expressions} are useful for improving
  readability especially by contracting complicated expressions used
  more than once. For instance, we can improve the function
  \texttt{map\_disj} from page \pageref{mapdisj}:
\begin{alltt}
  map_disj : (\keyw{map nat to nat}) * (\keyw{map nat to nat}) -> \keyw{map nat to nat}
  map_disj (m1,m2) ==
    \keyw{let} inter_dom = \keyw{dom} m1 \keyw{inter dom} m2
    \keyw{in}
      inter_dom <-: m1 \keyw{munion}
      inter_dom <-: m2
  \Keyw{pre} \keyw{forall} d \keyw{in set dom} m1 \keyw{inter dom} m2 & m1(d) = m2(d)
\end{alltt}
  They are also convenient for decomposing complex
  structures into their components. For instance, using the previously
  defined record type \texttt{Score} (page \pageref{scoredef}) we can
  test whether one score is greater than another:
  \begin{alltt}
    \keyw{let} \keyw{mk\_}Score(-,w1,-,-,p1) = sc1,
       \keyw{mk\_}Score(-,w2,-,-,p2) = sc2
    \keyw{in} (p1 > p2) \keyw{or} (p1 = p2 \keyw{and} w1 > w2)
  \end{alltt}
  In this
  particular example we extract the second and fifth components of the
  two scores. Note that don't care
  patterns (page \pageref{patterns}) are used to indicate that the
  remaining components are irrelevant 
  for the processing done in the body of this expression.
  
  {\it Let-be-such-that expressions} are useful for abstracting away
  the non-essential choice of an element from a set, in particular in
  formulating recursive definitions over sets. An example of this is a
  version of the sequence filter function (page \pageref{filterdef})
  over sets:\label{setfilterdef}
  \begin{alltt}
    set_filter[@elem] : (@elem -> \keyw{bool}) -> (\keyw{set of} @elem) -> 
                        (\keyw{set of} @elem)
    set_filter(p)(s) ==
      \keyw{if} s = \{\}
      \keyw{then} \{\}
      \keyw{else let} x \keyw{in set} s
          \keyw{in} (\keyw{if} p(x) \keyw{then} \{x\} \keyw{else} \{\}) \keyw{union}
             set_filter[@elem](p)(s \verb+\+ \{x\});
   \end{alltt}
   We could alternatively have defined this function using a set
  comprehension (described in section \ref{setexpr}):
  \begin{alltt}
    set_filter[@elem] : (@elem -> \keyw{bool}) -> (\keyw{set of} @elem) -> 
                        (\keyw{set of} @elem)
    set_filter(p)(s) ==
      \{ x | x \keyw{in set} s & p(x)\};
  \end{alltt} 

   The last example shows how the optional ``be such that'' part
   (\keyw{be st}) can be used. This part is especially useful when it
   is known that an element with some property exists but an explicit
   expression for such an element is not known or difficult to
  write. For instance we can exploit this expression to write a
  selection sort algorithm:
   \begin{alltt}\label{selectionSortdef}
   remove : \keyw{nat} * \keyw{seq of nat} -> \keyw{seq of nat}
   remove (x,l) ==
     \keyw{let} i \keyw{in set inds} l \keyw{be st} l(i) = x
     \keyw{in} l(1,...,i-1)\verb+^+l(i+1,...,\keyw{len} l)
   \Keyw{pre} x \keyw{in set elems} l;

   selection_sort : \keyw{seq of nat} -> \keyw{seq of nat}
   selection_sort (l) ==
     \keyw{if} l = []
     \keyw{then} []
     \keyw{else let} m \keyw{in set elems} l \keyw{be st}
         \keyw{forall} x \keyw{in set elems} l & m <= x
         \keyw{in} [m]\verb+^+(selection_sort (remove(m,l)))
   \end{alltt}
   Here the first function removes a given element from the given
   list; the second function repeatedly removes the least element in
   the unsorted portion of the list, and places it at the head of the
   sorted portion of the list.
\end{description}

\subsection{The Define Expression} \label{define-exp}

This expression can only be used inside operations which will be
described in section~\ref{op-def}. In order to deal with global variables
inside the expression part an extra expression construct is available
inside operations.

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep 
    \Ruleref{def expression} \dsep
    \ldots
    }

\Rule{def expression}{
  \Lop{def}, 
  \Ruleref{pattern bind}, \Lit{=}, \Ruleref{expression}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{pattern bind}, \Lit{=}, \Ruleref{expression}}, \OptPt{\Lit{;}},
  \lfeed
  \Lop{in}, \Ruleref{expression}
  } 

\item[Semantics:] A {\it define expression} has the form:
  \begin{alltt}
    \Keyw{def} pb1 = e1;
        \ldots
        pbn = en
    \Keyw{in}
      e
  \end{alltt}
  The {\it define expression} corresponds to a let expression except
  that the right hand side expressions may depend on the value of the
  local and/or
  global variable and that it may not be mutually recursive.
  It denotes the value of the expression {\tt e} in the
  context in which the patterns (or binds) {\tt pb1, \ldots, pbn} are
  matched against the corresponding expressions {\tt e1, \ldots,
    en}\footnote{If binds are used, it simply means that the values
    which can match the pattern are further constrained by the type or
    set expression as explained in section~\ref{patterns}.}.

\item[Examples:] The {\it define expression} is
  used in a pragmatic way, in order to make the reader aware of the fact that
  the value of the expression depends upon the global variable.

  This can be illustrated by a small example:
  \begin{alltt}
    \Keyw{def} user = lib(copy) \keyw{in}
      \keyw{if} user = <OUT>
      \Keyw{then} \keyw{true}
      \Keyw{else} \keyw{false}
  \end{alltt}      
  where {\tt copy} is defined in the context, {\tt lib} is global
  variable (thus {\tt lib(copy)} can be considered as looking up the
  contents of a part of the variable).

  The operation \texttt{GroupRunnerUp\_expl} in section \ref{letstmt}
  also gives an example of a define expression.
\end{description}

\subsection{Unary and Binary Expressions}\label{unandbin}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{unary expression} \dsep \Ruleref{binary expression} \dsep \ldots
    }

\Rule{unary expression}{
  \Ruleref{prefix expression} \dsep
  \Ruleref{map inverse}
  }

\Rule{prefix expression}{
  \Ruleref{unary operator}, \Ruleref{expression}
  }

  \Rule{unary operator}{
    \Lit{+} \dsepl \Lit{-} \dsepl \Lop{abs} \dsepl
    \Lop{floor} \dsepl \Lop{not} \dsep
    \Lop{card} \dsepl \Lop{power} \dsepl \Lop{dunion} \dsepl
    \Lop{dinter} \dsep
    \Lop{hd} \dsepl \Lop{tl} \dsepl \Lop{len} \dsepl \Lop{elems} \dsepl
    \Lop{inds} \dsepl \Lop{conc} \dsep
    \Lop{dom} \dsepl \Lop{rng} \dsepl \Lop{merge} 
    }

\Rule{map inverse}{
  \Lop{inverse}, \Ruleref{expression}
  }

  \Rule{binary expression}{
    \Ruleref{expression}, \Ruleref{binary operator}, \Ruleref{expression}}

  \Rule{binary operator}{
    \Lit{+} \dsepl \Lit{-} \dsepl \Lit{*} \dsepl \Lit{/} \dsep
    \Lop{rem} \dsepl \Lop{div} \dsepl \Lop{mod} \dsepl \Lit{**} \dsep
    \Lop{union} \dsepl \Lop{inter} \dsepl \Lit{\char'134} \dsepl
    \Lop{subset} \dsep
    \Lop{psubset} \dsepl \Lop{in set} \dsepl \Lop{not in set} \dsep
    \Lit{\char'136} \dsep
    \Lit{++} \dsepl \Lop{munion} \dsepl \Lit{<:} \dsepl \Lit{<-:} \dsepl \Lit{:>} \dsepl \Lit{:->} \dsep
    \Lop{and} \dsepl \Lop{or} \dsep
    \Lit{=>} \dsepl \Lit{<=>} \dsepl \Lit{=} \dsepl \Lit{<>} \dsep
    \Lit{<} \dsepl \Lit{<=} \dsepl \Lit{>} \dsepl \Lit{>=} \dsep
    \Lop{comp}
    }

\item[Semantics:] Unary and binary expressions are a combination of
  operands and operators denoting a value of a specific type. The
  signature of all these operators is already given in
  section~\ref{typedef}, so no further explanation will be provided
  here. The map inverse unary operator is treated separately because
  it is written with postfix notation in the mathematical syntax.

\item[Examples:] Examples using these operators were given in
  section~\ref{typedef}, so none will be provided here.
\end{description}

\subsection{Conditional Expressions}
\label{if-exp} \label{cases-exp}
\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{if expression} \dsep \Ruleref{cases expression} \dsep \ldots
    }

  \Rule{if expression}{
    \Lop{if}, \Ruleref{expression}, \Lop{then}, \Ruleref{expression},\lfeed
    \SeqPt{\Ruleref{elseif expression}}, \Lop{else}, \Ruleref{expression}
    }

  \Rule{elseif expression}{
    \Lop{elseif}, \Ruleref{expression}, \Lop{then}, \Ruleref{expression}
    }
                     
  \Rule{cases expression}{
    \Lop{cases}, \Ruleref{expression}, \Lit{:}, \lfeed
    \Ruleref{cases expression alternatives}, \lfeed
    \OptPt{\Lit{,}, \Ruleref{others expression}}, \Lop{end}
    }

  \Rule{cases expression alternatives}{
    \Ruleref{cases expression alternative},\lfeed
    \SeqPt{\Lit{,}, \Ruleref{cases expression alternative}}
    }

  \Rule{cases expression alternative}{
    \Ruleref{pattern list}, \Lit{->}, \Ruleref{expression}
    } 

  \Rule{others expression}{
    \Lop{others}, \Lit{->}, \Ruleref{expression}
    }

\item[Semantics:] {\it If expressions} and {\it cases expressions}
  allow the choice of one from a number of expressions on the basis of
  the value of a particular expression.

  The {\it if expression} has the form:
  \begin{alltt}
    \keyw{if} e1
    \Keyw{then} e2
    \Keyw{else} e3
  \end{alltt}
  where {\tt e1} is a boolean expression, while {\tt e2} and {\tt e3}
  are expressions of any type. The if expression denotes the value of
  {\tt e2} evaluated in the given context if {\tt e1} evaluates to
  true in the given context. Otherwise the if expression denotes the
  value of {\tt e3} evaluated in the given context. The use of an
  \keyw{elseif} expression is simply a shorthand for a nested if then
  else expression in the \keyw{else} part of the expression.

  The {\it cases expression} has the form
  \begin{alltt}
    \keyw{cases} e :
      p11, p12, ..., p1n -> e1,
      ...                -> ...,
      pm1, pm2, ..., pmk -> em,
      \Keyw{others}             -> emplus1
    \keyw{end}
  \end{alltt}
  where {\tt e} is an expression of any type, all {\tt pij}'s are patterns
  which are matched one by one against the expression {\tt e}.  The {\tt
    ei}'s are expressions of any type, and the keyword \keyw{others} and
  the corresponding expression {\tt emplus1} are optional. The cases
  expression denotes the value of the {\tt ei} expression evaluated in the
  context in which one of the {\tt pij} patterns has been matched against
  {\tt e}. The chosen {\tt ei} is the first entry where it has been
  possible to match the expression {\tt e} against one of the patterns. If
  none of the patterns match {\tt e} an \keyw{others} clause must be
  present, and then the cases expression denotes the value of {\tt emplus1}
  evaluated in the given context.
     
\item[Examples:] The if expression in \vdmslpp{\vdmsl}{\vdmpp}\ 
  corresponds to what is used in most programming languages, while the
  cases expression in \vdmslpp{\vdmsl}{\vdmpp}\ is more general than
  most programming languages. This is shown by the fact that real
  pattern matching is taking place, but also because the patterns do not
  have to be constants as in most programming languages.

  An example of the use of conditional expressions is provided by the
  specification of the mergesort algorithm:
  \begin{alltt}
  lmerge : \keyw{seq of nat} * \keyw{seq of nat} -> \keyw{seq of nat}
  lmerge (s1,s2) ==
    \keyw{if} s1 = [] \keyw{then} s2
    \keyw{elseif} s2 = [] \keyw{then} s1
    \keyw{elseif} (\keyw{hd} s1) < (\keyw{hd} s2)
    \keyw{then} [\keyw{hd} s1]\verb+^+(lmerge (\keyw{tl} s1, s2))
    \keyw{else} [\keyw{hd} s2]\verb+^+(lmerge (s1, \keyw{tl} s2));

  mergesort : \keyw{seq of nat} -> \keyw{seq of nat}
  mergesort (l) ==
    \keyw{cases} l:
      [] -> [],
      [x] -> [x],
      l1\verb+^+l2 -> lmerge (mergesort(l1), mergesort(l2))
    \keyw{end}
  \end{alltt}
The pattern matching provided by cases expressions is useful for
  manipulating members of type unions. For instance, using the type
  definition \texttt{Expr} from page \pageref{exprdef} we have:
  \begin{alltt}\label{printExprDef}
  print_Expr : Expr -> \keyw{seq1 of char}
  print_Expr (e) ==
    \keyw{cases} e:
      \keyw{mk\_}Const(-) -> "Const of"\verb+^+(print_Const(e)),
      \keyw{mk\_}Var(id,-) -> "Var of"\verb+^+id,
      \keyw{mk\_}Infix(\keyw{mk\_}(e1,op,e2)) -> "Infix of"\verb+^+print_Expr(e1)^","
                                      \verb+^+print_Op(op)\verb+^+","
                                      \verb+^+print_Expr(e2),
      \keyw{mk\_}Cond(t,c,a) -> "Cond of"\verb+^+print_Expr(t)\verb+^+","
                                 \verb+^+print_Expr(c)\verb+^+","
                                 \verb+^+print_Expr(a)
    end;

  print_Const : Const -> \keyw{seq1 of char}
  print_Const(\keyw{mk\_}Const(c)) ==
    \keyw{if} \keyw{is\_nat}(c)
    \keyw{then} "nat"
    \keyw{else} -- must be bool
         "bool";
  \end{alltt}
  The function \texttt{print\_Op} would be defined similarly.
\end{description}

\subsection{Quantified Expressions}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep \Ruleref{quantified expression} 
    \dsep \ldots
    }

  \Rule{quantified expression}{
    \Ruleref{all expression} \dsep
    \Ruleref{exists expression} \dsep
    \Ruleref{exists unique expression}
    } 

  \Rule{all expression}{
    \Lop{forall}, \Ruleref{bind list}, \Lit{\char'046}, \Ruleref{expression}
    }
    
  \Rule{exists expression}{
      \Lop{exists}, \Ruleref{bind list}, \Lit{\char'046}, \Ruleref{expression}
    }

  \Rule{bind list}{
    \Ruleref{multiple bind}, \SeqPt{\Lit{,}, \Ruleref{multiple bind}}
    }

  \Rule{exists unique expression}{
    \Lop{exists1}, \Ruleref{bind}, \Lit{\char'046}, \Ruleref{expression}
    }

\item[Semantics:] There are three forms of quantified expressions:
  {\it universal} (written as \keyw{forall}), {\it existential} (written
  as \keyw{exists}), and {\it unique existential} (written as
  \keyw{exists1}). Each yields a boolean value \keyw{true} or \keyw{false}, as
  explained in the following.

  The {\it universal quantification} has the form:
  \begin{alltt}
    \keyw{forall} mbd1, mbd2, \ldots, mbdn \& e
  \end{alltt}
  where each {\tt mbdi} is a multiple bind {\tt pi \keyw{in set} s} (or
  if it is a type bind {\tt pi : type}), and {\tt e} is a boolean
  expression involving the pattern identifiers of the {\tt mbdi}'s. It
  has the value \keyw{true} if {\tt e} is \keyw{true} when evaluated in the
  context of every choice of bindings from {\tt mbd1, mbd2, \ldots,
    mbdn} and \keyw{false} otherwise.

  The {\it existential quantification} has the form:
  \begin{alltt}
    \keyw{exists} mbd1, mbd2, \ldots, mbdn \& e
  \end{alltt}
  where the {\tt mbdi}'s and the {\tt e} are as for a universal
  quantification. It has the value \keyw{true} if {\tt e} is \keyw{true} when
  evaluated in the context of at least one choice of bindings from
  {\tt mbd1, mbd2, \ldots, mbdn}, and \keyw{false} otherwise.

  The {\it unique existential quantification} has the form:
  \begin{alltt}
    \keyw{exists1} bd \& e
  \end{alltt}
  where {\tt bd} is either a set bind or a type bind and {\tt e} is a
  boolean expression involving the pattern identifiers of {\tt bd}. It
  has the value \keyw{true} if {\tt e} is \keyw{true} when evaluated in the
  context of exactly one choice of bindings, and \keyw{false} otherwise.

  All quantified expressions have the lowest possible precedence. This
  means that the longest possible constituent expression is taken. The
  expression is continued to the right as far as it is syntactically
  possible. 
  

\item[Examples:] 
  An example of an existential quantification is given in the function
  shown below, \texttt{QualificationOk}. This function, taken from the
  specification of a nuclear tracking system in \cite{Fitzgerald&98},
  checks whether a set of experts has a required qualification.
  \begin{alltt}
  types

  ExpertId = \keyw{token};
  Expert :: expertid : ExpertId
            quali : \keyw{set of} Qualification
  \keyw{inv} ex == ex.quali <> {};
  Qualification = <Elec> | <Mech> | <Bio> | <Chem>

  functions

  QualificationOK: \keyw{set of} Expert * Qualification -> \keyw{bool}
  QualificationOK(exs,reqquali) ==
      \keyw{exists} ex \keyw{in set} exs & reqquali \keyw{in set} ex.quali
  \end{alltt}
  The function \texttt{min} gives us an example of a universal
  quantification: 
  \begin{alltt}
  min(s:\keyw{set of nat}) x:\keyw{nat}
  \Keyw{pre} s <> \{\} 
  \Keyw{post} x \keyw{in set} s \keyw{and}
       \keyw{forall} y \keyw{in set} s \verb+\+ \{x\} & y < x
  \end{alltt}
  We can use unique existential quantification to state the functional
  property satisfied by all maps \texttt{m}:
  \begin{alltt}
  \keyw{forall} d \keyw{in set dom} m &
    \keyw{exists1} r \keyw{in set rng} m & m(d) = r
  \end{alltt}


\end{description}

\subsection{The Iota Expression}\label{iotaexpr}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{iota expression} \dsep
    \ldots
    }

  \Rule{iota expression}{
    \Lop{iota}, \Ruleref{bind}, \Lit{\char'046}, \Ruleref{expression}
    }

\item[Semantics:] An {\it iota expression} has the form:
  \begin{alltt}
    \keyw{iota} bd \& e
  \end{alltt}
  where {\tt bd} is either a set bind or a type bind, and {\tt e} is a
  boolean expression involving the pattern identifiers of {\tt bd}.
  The \keyw{iota} operator can only be used if a unique value exists
  which matches the bind and makes the body expression {\tt e} yield
  \keyw{true} (i.e.\ {\tt \keyw{exists1} bd \& e} must be \keyw{true}). The
  semantics of the iota expression is such that it returns the unique
  value which satisfies the body expression ({\tt e}).

\item[Examples:]
  Using the values \texttt{sc1,...,sc4} defined by
  \begin{alltt}
    sc1 = \keyw{mk\_}Score (<France>, 3, 0, 0, 9);
    sc2 = \keyw{mk\_}Score (<Denmark>, 1, 1, 1, 4);
    sc3 = \keyw{mk\_}Score (<SouthAfrica>, 0, 2, 1, 2);
    sc4 = \keyw{mk\_}Score (<SaudiArabia>, 0, 1, 2, 1);
  \end{alltt}
  we have
  
  \begin{tabular}{lcl}
    \texttt{ \keyw{iota} x \keyw{in set} \{sc1,sc2,sc3,sc4\} \& 
      x.team = <France>} & $\equiv$ & \texttt{sc1}\\
    \texttt{ \keyw{iota} x \keyw{in set} \{sc1,sc2,sc3,sc4\} \& 
      x.points > 3} & $\equiv$ & $\perp$\\
    \texttt{ \keyw{iota} x : Score \& x.points < x.won} & $\equiv$ &
  $\perp$
  \end{tabular}

  \noindent Notice that the last example cannot be executed and that
  the last two expressions are undefined - in the former case because
  there is more than value satisfying the expression, and in the
  latter because no value satisfies the expression.
\end{description}

\subsection{Set Expressions}\label{setexpr}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep \Ruleref{set enumeration} \dsep \Ruleref{set comprehension} \dsep
    \Ruleref{set range expression} \dsep \ldots
    }
  
  \Rule{set enumeration}{
    \Lit{\{}, \OptPt{\Ruleref{expression list}}, \Lit{\}}
    }

  \Rule{expression list}{
    \Ruleref{expression}, \SeqPt{\Lit{,}, \Ruleref{expression}}
    }

  \Rule{set comprehension}{
    \Lit{\{}, \Ruleref{expression}, \Lit{$|$}, \Ruleref{bind list}, \lfeed
    \OptPt{\Lit{\char'046}, \Ruleref{expression}}, \Lit{\}}
    }

  \Rule{set range expression}{
    \Lit{\{}, \Ruleref{expression}, \Lit{,}, \Lit{\Range},
    \Lit{,}, \lfeed
    \Ruleref{expression}, \Lit{\}}
    }

\item[Semantics:] A {\it Set enumeration} has the form:
  \begin{alltt}
    \{e1, e2, e3, \ldots, en\}
  \end{alltt}
  where {\tt e1} up to {\tt en} are general expressions. It constructs
  a set of the values of the enumerated expressions. The empty set
  must be written as \verb+{}+.

  The {\it set comprehension} expression has the form:
  \begin{alltt}
    \{e | mbd1, mbd2, \ldots, mbdn \& P\}
  \end{alltt}
  It constructs a set by evaluating the expression {\tt e} on all the
  bindings for which the predicate {\tt P} evaluates to \keyw{true}. A
  multiple binding can contain both set bindings and type bindings.
  Thus {\tt mbdn} will look like {\tt pat1 \keyw{in set} s1, pat2 : tp1,
    \ldots \keyw{in set} s2}, where {\tt pati} is a pattern (normally
  simply an identifier), and {\tt s1} and {\tt s2} are sets
  constructed by expressions (whereas {\tt tp1} is used to illustrate
  that type binds can also be used). Notice however that type binds
  cannot be executed by the interpreter.

  The {\it set range expression} is a special case of a set
  comprehension. It has the form
  \begin{alltt}
    \{e1, \ldots, e2\}
  \end{alltt}
  where {\tt e1} and {\tt e2} are numeric expressions. The set range
  expression denotes the set of integers from {\tt e1} to {\tt e2}
  inclusive. If {\tt e2} is smaller than {\tt e1} the set range
  expression denotes the empty set. 

\item[Examples:]
  Using  the values \texttt{Europe=\{<France>,<England>,<Denmark>,%
  <Spain>\}} and \texttt{GroupC = \{sc1,sc2,sc3,sc4\}} (where
  \texttt{sc1,...,sc4} are as defined in the preceding example) we have

  \begin{tabular}{lcl}
    \texttt{\{<France>, <Spain>\} \keyw{subset} Europe} & $\equiv$ &
      \keyw{true}\\
    \parbox[t]{7cm}{\raggedright
      \texttt{\{<Brazil>, <Chile>, <England>\}}\\
      \mbox{\hspace{3em}}\texttt{\keyw{subset} Europe} }
      & $\equiv$ &  \keyw{false}\\
    \parbox[t]{7cm}{\raggedright
      \texttt{\{<France>, <Spain>, {\char'042}France{\char'042}\}} \\
      \mbox{\hspace{3em}}\keyw{subset} \texttt{Europe}} &
      $\equiv$ & \keyw{false}\\
    \parbox[t]{7cm}{\raggedright\texttt{\{sc.team | sc \keyw{in set} GroupC }\\
                    \mbox{\hspace{3em}}\texttt{\& sc.points > 2\}}} &
      $\equiv$ & \texttt{\{\parbox[t]{4cm}{<France>,\\ <Denmark>\}}}\\
    \parbox[t]{7cm}{\raggedright
        \texttt{\{sc.team | sc \keyw{in set} GroupC }\\
        \mbox{\hspace{3em}}\texttt{\& sc.lost > sc.won \}}}
      & $\equiv$ & \texttt{\{\parbox[t]{4cm}{<SouthAfrica>, \\<SaudiArabia>\}}}\\
    \texttt{\{2.718,...,3.141\}} & $\equiv$ & \texttt{\{3\}}\\
    \texttt{\{3.141,...,2.718\}} & $\equiv$ & \texttt{\{\}}\\
    \texttt{\{1,...,5\}} & $\equiv$ & \texttt{\{1,2,3,4,5\}}\\
    \texttt{\{ x | x:\keyw{nat} \& x < 10 \keyw{and} x \keyw{mod} 2 = 0\}}
      & $\equiv$ & \texttt{\{0,2,4,6,8\}}
  \end{tabular}
\end{description}

\subsection{Sequence Expressions} \label{seqexpr}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{sequence enumeration} \dsep \Ruleref{sequence comprehension} \dsep
    \Ruleref{subsequence} \dsep \ldots
    }

  \Rule{sequence enumeration}{
    \Lit{[}, \OptPt{\Ruleref{expression list}}, \Lit{]}
    }

  \Rule{sequence comprehension}{
    \Lit{[}, \Ruleref{expression}, \Lit{|}, \Ruleref{set bind}, \lfeed
    \OptPt{\Lit{\char'046}, \Ruleref{expression}}, \Lit{]}
    }

  \Rule{subsequence}{
    \Ruleref{expression}, \lfeed
    \Lit{(}, \Ruleref{expression},
    \Lit{,}, \Lit{\Range},
    \Lit{,}, \lfeed
    \Ruleref{expression}, \Lit{)}
    }

\item[Semantics:] A {\it sequence enumeration} has the form:
  \begin{alltt}
    [e1, e2, \ldots, en]
  \end{alltt}
  where {\tt e1} through {\tt en} are general expressions. It constructs a
  sequence of the enumerated elements. The empty sequence must be written
  as {\tt []}.

  A {\it sequence comprehension} has the form:
  \begin{alltt}
    [e | pat \keyw{in set} S \& P]
  \end{alltt}
  where the expression {\tt e} will use the identifiers from the
  pattern {\tt pat} (normally this pattern will simply be an
  identifier, but the only real requirement is that exactly one pattern
  identifier must be present in the pattern). {\tt S} is
  a set of values (normally natural numbers). The bindings of the
  pattern identifier must be to some kind of numeric values which then
  are used to indicate the ordering of the elements in
  the resulting sequence. It constructs a sequence by evaluating the
  expression {\tt e} on all the bindings for which the predicate {\tt P}
  evaluates to \keyw{true}.

  A {\it subsequence} of a sequence {\tt l} is a sequence formed from
  consecutive elements of {\tt l}; from index {\tt n1} up to and including
  index {\tt n2}. It has the form:
  \begin{alltt}
    l(n1, ..., n2)
  \end{alltt}
  where {\tt n1} and {\tt n2} are positive integer expressions.
  If the lower bound {\tt n1} is smaller than
  1 (the first index in a non-empty sequence) the subsequence
  expression will start from the first element of the sequence.
  If the upper bound {\tt n2} is larger
  than the length of the sequence (the largest index which can be used
  for a non-empty sequence) the subsequence expression will end at the
  last element of the sequence.

%  A {\it sequence modifier} has the form:
%  \begin{alltt}
%    l ++ \{n1 |-> e1, n2 |-> e2, \ldots, nm |-> em\}
%  \end{alltt}
%  where {\tt l} is an expression denoting a sequence (which is going to be
%  modified), {\tt n1, n2, \ldots, nm} are positive integer expressions
%  (less than the length of {\tt l}) and {\tt e1, e2, \ldots, em} are
%  expressions of any type. The sequence modifier expression denotes the
%  sequence {\tt l} modified in a way so that element {\tt ni} has been
%  replaced by {\tt ei}.

\item[Examples:] Given that \texttt{GroupA} is equal to the sequence 
  \begin{alltt}\label{GroupAdef}
    [ \keyw{mk\_}Score(<Brazil>,2,0,1,6), 
      \keyw{mk\_}Score(<Norway>,1,2,0,5),
      \keyw{mk\_}Score(<Morocco>,1,1,1,4),
      \keyw{mk\_}Score(<Scotland>,0,1,2,1) ]
  \end{alltt} then:

  \begin{tabular}{lcl}
  \parbox[t]{5.4cm}{\ttfamily\selectfont
            [GroupA(i).team \\
            | i \keyw{in set inds} GroupA \\
                  \mbox{\hspace{1em}} \& GroupA(i).won <> 0]}
    &$\equiv$ & 
        \texttt{[}\parbox[t]{4cm}{\ttfamily\selectfont
                                 <Brazil>, \\
                                 <Norway>, \\
                                 <Morocco>]}\\
  \parbox[t]{5.4cm}{\ttfamily\selectfont
            [GroupA(i) \\
            | i \keyw{in set inds} GroupA\\
            \mbox{\hspace{1em}} \& GroupA(i).won = 0]}
    &$\equiv$ & \texttt{[\keyw{mk\_}Score(<Scotland>,0,1,2,1)]}\\
  \texttt{GroupA(1,...,2)} 
    &$\equiv$ & 
    \texttt{[}\parbox[t]{4cm}{\ttfamily\selectfont
         \keyw{mk\_}Score(<Brazil>,2,0,1,6), \\
         \keyw{mk\_}Score(<Norway>,1,2,0,5)]}\\
  \parbox[t]{5.65cm}{\ttfamily\selectfont
            [GroupA(i) \\
            | i \keyw{in set inds} GroupA \\
            \mbox{\hspace{1em}} \& GroupA(i).points = 9]}
    &$\equiv$ & \texttt{[]}
  \end{tabular}
\end{description}

\subsection{Map Expressions} \label{mapexpr}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{map enumeration} \dsep \Ruleref{map comprehension} \dsep \ldots
    }

  \Rule{map enumeration}{
    \Lit{\{}, \Ruleref{maplet}, \SeqPt{\Lit{,}, \Ruleref{maplet}}, \Lit{\}} \dsep
    \Lit{\{}, \Lit{|->}, \Lit{\}}
    } 
  
  \Rule{maplet}{
    \Ruleref{expression}, \Lit{|->}, \Ruleref{expression}
    }
  
  \Rule{map comprehension}{
    \Lit{\{}, \Ruleref{maplet}, \Lit{|}, \Ruleref{bind list},\lfeed
    \OptPt{\Lit{\char'046}, \Ruleref{expression}}, \Lit{\}}
    }

\item[Semantics:] A {\it map enumeration} has the form:
  \begin{alltt}
    \{d1 |-> r1, d2 |-> r2, \ldots, dn |-> rn\}
  \end{alltt}
  where all the domain expressions {\tt di} and range expressions {\tt ri}
  are general expressions. The empty map
  must be written as {\tt \{|->\}}.
      
  A {\it map comprehension} has the form:
  \begin{alltt}
    \{ed |-> er | mbd1, \ldots, mbdn \& P\}
  \end{alltt}
  where constructs {\tt mbd1, \ldots, mbdn} are multiple bindings of
  variables from the expressions {\tt ed} and {\tt er} to sets (or types).
  The {\it map comprehension} constructs a mapping by evaluating the
  expressions {\tt ed} and {\tt er} on all the possible bindings for which
  the predicate {\tt P} evaluates to \keyw{true}.

\item[Examples:] Given that \texttt{GroupG} is equal to the map 
  \begin{alltt}\label{GroupGdef}
    \{ <Romania> |-> mk_(2,1,0), <England> |-> mk_(2,0,1),
      <Colombia> |-> mk_(1,0,2), <Tunisia> |-> mk_(0,1,2) \}
  \end{alltt}
  then:

  \begin{tabular}{lcl}
  \parbox[t]{8cm}{\ttfamily\selectfont
    \{ t |-> \keyw{let} \keyw{mk\_}(w,d,-) = GroupG(t)\\
             \mbox{\hspace{4em}}\keyw{in} w * 3 + d \\
             | t \keyw{in set dom} GroupG\}}
    & $\equiv$ & \texttt{\{}\parbox[t]{5cm}{\ttfamily\selectfont
                   <Romania> |-> 7,\\
                   <England> |-> 6,\\
                   <Colombia> |-> 3,\\
                   <Tunisia> |-> 1\}}\\
  \parbox[t]{8cm}{\ttfamily\selectfont
    \{ t |-> w * 3 + d \\
    | t \keyw{in set dom} GroupG, w,d,l:\keyw{nat} \\
    \ \& \keyw{mk\_}(w,d,l) = GroupG(t) \\
    \mbox{\hspace{.7em}}\keyw{and} w > l\}}
   & $\equiv$ & \texttt{\{}\parbox[t]{5cm}{\ttfamily\selectfont
                   <Romania> |-> 7,\\
                   <England> |-> 6\}}
  \end{tabular}
\end{description}

\subsection{Tuple Constructor Expressions} \label{tupexpr}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep \Ruleref{tuple constructor} \dsep \ldots
    }

  \Rule{tuple constructor}{
    \Lop{mk\_}, \Lit{(}, \Ruleref{expression}, \Lit{,}, \Ruleref{expression list}, \Lit{)}
    }

\item[Semantics:] The {\it tuple constructor expression}  has the form:
  \begin{alltt}
    \keyw{mk\_}(e1, e2, \ldots, en)
  \end{alltt}
  where {\tt ei} is a general expression. It can only be used by the
  equality and inequality operators.
     
\item[Examples:] Using the map \texttt{GroupG} defined in the preceding 
example, we have:

  \begin{tabular}{lcl}
  \texttt{\keyw{mk\_}(2,1,0) \keyw{in set rng} GroupG} & $\equiv$ \keyw{true}\\
  \texttt{\keyw{mk\_}({\char'042}Romania{\char'042},2,1,0) \keyw{not in set rng} GroupG} 
       & $\equiv$ \keyw{true}\\
  \texttt{\keyw{mk\_}(<Romania>,2,1,0) <> \keyw{mk\_}({\char'042}Romania{\char'042},2,1,0)}
       & $\equiv$ \keyw{true}
  \end{tabular}
\end{description}

\subsection{Record Expressions} \label{recexpr}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep 
    \Ruleref{record constructor} \dsep
    \Ruleref{record modifier} \dsep \ldots
    }

  \Rule{record constructor}{
    \Lop{mk\_}, \Ruleref{name}, \Lit{(}, 
    \OptPt{\Ruleref{expression list}}, \Lit{)}
    }

  \Rule{record modifier}{
    \Lop{mu}, \Lit{(}, \Ruleref{expression}, \Lit{,}, 
    \Ruleref{record modification}, \lfeed \SeqPt{\Lit{,}, \Ruleref{record modification}}
    \Lit{)}
    }

  \Rule{record modification}{
    \Ruleref{identifier}, \Lit{|->}, \Ruleref{expression}
    }

\item[Semantics:] The {\it record constructor} has the form:
  \begin{alltt}
    \keyw{mk\_}T(e1, e2, \ldots, en)
  \end{alltt}
  where the type of the expressions {\tt (e1, e2, \ldots, en)} matches the
  type of the corresponding entrances in the composite type {\tt T}.

  The {\it record modification} has the form:
  \begin{alltt}
    \keyw{mu} (e, id1 |-> e1, id2 |-> e2, \ldots, idn |-> en)
  \end{alltt}
  where the evaluation of the expression {\tt e} returns the record value
  to be modified. All the identifiers {\tt idi} must be distinct named
  entrances in the record type of {\tt e}.
     
\item[Examples:] If \texttt{sc} is the value \texttt{\keyw{mk\_}Score(<France>,3,0,0,9)} then
  \begin{alltt}
    \keyw{mu}(sc, drawn |-> sc.drawn + 1, points |-> sc.points + 1)
    \MYEQUIV \keyw{mk\_}Score(<France>,3,1,0,10)
  \end{alltt}
  Further examples are demonstrated in the function \texttt{win}. This
  function takes two teams and a set of scores. From the set of scores
  it locates the scores corresponding to the given teams (\texttt{wsc}
  and \texttt{lsc} for the winning and losing team respectively), then
  updates these using the \keyw{mu} operator. The set of teams is then
  updated with the new scores replacing the original ones.
  \begin{alltt}
  win : Team * Team * \keyw{set of} Score -> \keyw{set of} Score
  win (wt,lt,gp) ==
    \keyw{let} wsc = \keyw{iota} sc \keyw{in set} gp & sc.team = wt,
       lsc = \keyw{iota} sc \keyw{in set} gp & sc.team = lt
    \keyw{in let} new_wsc = \keyw{mu}(wsc, won |-> wsc.won + 1,
                            points |-> wsc.points + 3),
         new_lsc = \keyw{mu}(lsc, lost |-> lsc.lost + 1)
      \keyw{in} (gp \verb+\+ \{wsc,lsc\}) \keyw{union} \{new_wsc, new_lsc\}
  \Keyw{pre} \keyw{forall} sc1, sc2 \keyw{in set} gp &
          sc1 <> sc2 <=> sc1.team <> sc2.team
          \keyw{and} \{wt,lt\} \keyw{subset} \{sc.team | sc \keyw{in set} gp\}
  \end{alltt}

\end{description}

\subsection{Apply Expressions}\label{app-expr}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep 
    \Ruleref{apply} \dsep
    \Ruleref{field select} \dsep
    \Ruleref{tuple select} \dsep
    \Ruleref{function type instantiation} \dsep
    \ldots
    }

  \Rule{apply}{
    \Ruleref{expression}, \Lit{(}, \OptPt{\Ruleref{expression list}}, \Lit{)}
    }

  \Rule{field select}{
    \Ruleref{expression}, \Lit{.}, \Ruleref{identifier}
    }

  \Rule{tuple select}{
    \Ruleref{expression}, \Lit{.\#}, \Ruleref{numeral}
    }

  \Rule{function type instantiation}{
    \Ruleref{name}, \Lit{[}, \Ruleref{type}, \SeqPt{\Lit{,}, \Ruleref{type}}, \Lit{]}
    }
    
\item[Semantics:] The {\it field select expression} can be used for records
  and it has already been explained in section~\ref{records} so no further
  explanation will be given here.
     
  The {\it apply} is used for looking up in a map, indexing in a
  sequence, and finally for calling a function. In section~\ref{maps} it
  has already been shown what it means to look up in a map. Similarly in
  section~\ref{sequences} it is illustrated how indexing in a sequence is
  performed.

  In  \vdmslpp{VDM-SL}{\vdmpp} an operation can also be called 
  here. This is not allowed in standard VDM-SL and because this kind of
  operation call can modify the state such usage should be done with
  care in complex expressions. Note however that such operation calls
  are not allowed to throw exceptions.

  With such operation calls the order of evaluation can become
  important. Therefore the type checker will allow the user to enable
  or disable operation calls inside expressions.

  The tuple select expression is used to extract a particular
  component from a tuple. The meaning of the expression is if
  \texttt{e} evaluates to some tuple
  \keyw{mk\_}\texttt{(v1,...,vN)} and \texttt{M} is an integer in the
  range \verb+{1,...,N}+ then \texttt{e.\#M} yields \texttt{vM}. If
  \texttt{M} lies outside \verb+{1,...,N}+ the expression is undefined.

  The {\it function type instantiation\/} is used for instantiating
  polymorphic functions with the proper types. It has the form:
  \begin{alltt}
    pf [ t1, ..., tn ]
  \end{alltt}
  where {\tt pf} is the name of a polymorphic function, and {\tt t1,
    \ldots, tn} are types. The resulting function uses the types {\tt
    t1, \ldots, tn} instead of the variable type names given in the
  function definition.

\item[Examples:] Recall that \texttt{GroupA} is a sequence (page 
  \pageref{GroupAdef}), \texttt{GroupG} is a map (page \pageref{GroupGdef}) 
  and \texttt{selection\_sort} is a function (page \pageref{selectionSortdef}):

  \begin{tabular}{lcl}
  \texttt{GroupA(1)} & $\equiv$ & 
                           \texttt{\keyw{mk\_}Score(<Brazil>,2,0,1,6)}\\
  \texttt{GroupG(<Romania>)} & $\equiv$ &
                           \texttt{\keyw{mk\_}(2,1,0)}\\
  \texttt{GroupG(<Romania>).\#2} & $\equiv$ &
                           \texttt{1}\\
  \texttt{selection\_sort([3,2,9,1,3])} & $\equiv$ &
                           \texttt{[1,2,3,3,9]}
  \end{tabular}

  As an example of the use of polymorphic functions and function type
  instantiation, we use the example functions from
  section~\ref{functiondef}:
  \begin{alltt}
    \keyw{let} emptyInt = empty_bag[int] \keyw{in}
      plus_bag[int](-1, emptyInt())

  \MYEQUIV

    \{ -1 |-> 1 \}
  \end{alltt}

\end{description}


\subsection{The Lambda Expression}\label{lambda}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep \Ruleref{lambda expression} \dsep \ldots
    }

  \Rule{lambda expression}{
    \Lop{lambda}, \Ruleref{type bind list}, \Lit{\&}, \Ruleref{expression}
    }

\Rule{type bind list}{
  \Ruleref{type bind}, \SeqPt{\Lit{,}, \Ruleref{type bind}}
  }

  \Rule{type bind}{
    \Ruleref{pattern}, \Lit{:}, \Ruleref{type}
    }
        
\item[Semantics:] A {\it lambda expression} is of the form:
  \begin{alltt}
    \keyw{lambda} pat1 : T1, \ldots, patn : Tn \& e
  \end{alltt}
  where the {\tt pati} are patterns, the {\tt Ti} are type expressions, and
  {\tt e} is the body expression. The scope of the pattern identifiers in
  the patterns {\tt pati} is the body expression. A lambda expression
  cannot be polymorphic, but apart from that, it corresponds semantically
  to an explicit function definition as explained in
  section~\ref{functiondef}. A function defined by a lambda expression can
  be Curried by using a new lambda expression in the body of it in a nested
  way. When lambda expressions are bound to an identifier they can also
  define a recursive function.

\item[Examples:] An increment function can be defined by means of a lambda
  expression like:
  \begin{alltt}
    Inc = \keyw{lambda} n : \keyw{nat} \& n + 1
  \end{alltt}
  and an addition function can be Curried by:
  \begin{alltt}
    Add = \keyw{lambda} a : \keyw{nat} \& \keyw{lambda} b : \keyw{nat} \& a + b
  \end{alltt}
  which will return a new lambda expression if it is applied to only one
  argument:
  \begin{alltt}
    Add(5) \(\equiv\) \keyw{lambda} b : \keyw{nat} \& 5 + b
  \end{alltt}
  Lambda expression can be useful when used in conjunction with higher-order 
  functions. For instance using the function \texttt{set\_filter}
  defined on page \pageref{setfilterdef}:
  \begin{alltt}
  set_filter[nat](lambda n:nat & n mod 2 = 0)(\{1,...,10\})
  \MYEQUIV \{2,4,6,8,10\}
  \end{alltt}
\end{description}

\subsection{Narrow Expressions}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{narrow expression} \dsep
    \ldots
    }

  \Rule{narrow expression}{
    \Lop{narrow\_},  \Lit{(}, \Ruleref{expression},  \Lit{,}, \Ruleref{type}, \Lit{)} 
    }

    \item[Semantics:] The {\it narrow expression} convert the given {\tt expression} value into given {\tt type}.
	Downcasting in class inheritance, and narrowing Union type are permit.
	However, conversions between unrelated types become type errors.
    
    \item[Examples:] In following examples, there is no difference in the results of running the Test() and Test'(), 
	But, there is a type error (DEF) in Test().

\begin{alltt}
types
C1 :: a : nat;
C2 :: b : nat;
S = C1 | C2;

operations
Test: () ==> nat
Test() ==
 let s : S = mk_C1(1)
 in
   let c : C1 = s
   in
     return c.a;

Test': () ==> nat
Test'() ==
 let s : S = mk_C1(1)
 in
   let c : C1 = narrow_(s, C1)
   in
     return c.a;
\end{alltt}

\end{description}


\subsection{Is Expressions}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{general is expression} \dsep
    \ldots
    }

  \Rule{general is expression}{
    \Ruleref{is expression} \dsep
    \Ruleref{type judgement}
    }


  \Rule{is expression}{
    \Lop{is\_}, \Ruleref{name}, \Lit{(}, \Ruleref{expression}, \Lit{)} \dsep
    \Ruleref{is basic type}, \Lit{(}, \Ruleref{expression}, \Lit{)}
    }

  \Rule{is basic type}{
    \Lop{is\_}, 
    \Brack{%
      \Lop{bool} \dsepl
      \Lop{nat} \dsepl 
      \Lop{nat1} \dsepl 
      \Lop{int} \dsep 
      \Lop{rat} \dsepl 
      \Lop{real} \dsep
      \Lop{char} \dsepl
      \Lop{token}
      }
    }

  \Rule{type judgement}{
    \Lit{\keyw{is}\_}, \Lit{(}, \Ruleref{expression}, \Lit{,}, \Ruleref{type}, \Lit{)}
  }

\item[Semantics:] The {\it is expression} can be used with values
     that are either basic or record values (tagged values belonging
     to some composite type). The is expression yields true if the
     given value belongs to the basic type indicated or if the value
     has the indicated  tag. Otherwise it yields false.

     A type judgement is a more general form which can be used for
     expressions whose types can not be statically determined. The
     expression \texttt{\keyw{is}\_(e,t)} is equal to true if and only
     if \texttt{e} is of type \texttt{t}.
     
\item[Examples:] Using the record type \texttt{Score} defined on page 
  \pageref{scoredef} we have:
     
  \begin{tabular}{lcl}
    \texttt{\keyw{is\_}Score(\keyw{mk\_}Score(<France>,3,0,0,9))}
      & $\equiv$ & \keyw{true}\\
% Ueki mod start (Kagemai#54)
%    \texttt{\keyw{is\_}Score(\keyw{mk\_}Score(<France>,3,0,0,8))}
%      & $\equiv$ & \keyw{false}\\
% Ueki mod end
    \texttt{\keyw{is\_bool}(\keyw{mk\_}Score(<France>,3,0,0,9))}
      & $\equiv$ & \keyw{false}\\
    \texttt{\keyw{is\_real}(0)} & $\equiv$ & \keyw{true}\\
    \texttt{\keyw{is\_nat1}(0)} & $\equiv$ & \keyw{false}
  \end{tabular}

  An example of a type judgement:
  \begin{alltt}
    Domain : \keyw{map nat to nat} | \keyw{seq of (nat*nat)} -> \keyw{set of nat}
    Domain(m) ==
      \keyw{if is}\_(m, \keyw{map nat to nat})
      \keyw{then dom} m
      \keyw{else} \{d | \keyw{mk}\_(d,-) \keyw{in set elems} m\}
  \end{alltt}
     In addition there are examples on page \pageref{exprIsExs}.
\end{description}


\subsection{Literals and Names}

\begin{description}
\item[Syntax:]
  \Rule{expression}{    \ldots \dsep
    \Ruleref{name} \dsep
    \Ruleref{old name} \dsep
    \Ruleref{symbolic literal} \dsep
    \ldots
    }

  \Rule{name}{
    \Ruleref{identifier}, \OptPt{\Lit{`}, \Ruleref{identifier}}
    }

  \Rule{name list}{
    \Ruleref{name}, \SeqPt{\Lit{,}, \Ruleref{name}}
    }

  \Rule{old name}{
    \Ruleref{identifier}, \Lit{\char'176}
    }

\item[Semantics:] {\it Names\/} and {\it old names\/} are used to access
  definitions of functions, operations, values and state components. A {\it
    name\/} has the form:
  \begin{alltt}
    id1`id2
  \end{alltt}
  where {\tt id1} and {\tt id2} are simple identifiers. If a name consists
  of only one identifier, the identifier is defined within scope, i.e.\ it
  is defined either locally as a pattern identifier or variable,
  or globally within the current module as a function, operation,
  value or global variable. 
  Otherwise, the identifier {\tt id1} indicates the
module name
where the
  construct is defined (see also
  section~\ref{modules}
and appendix \ref{ap:lexis}.)

  An {\it old name\/} is used to access the old value of global
  variables in the post condition of an operation definition (see
  section~\ref{op-def}) and in the post condition of specification
  statements (see section~\ref{se:specification}).  It has the form:

  \begin{alltt} 
    id~ 
  \end{alltt} 
  where {\tt id} is a state component.

  {\it Symbolic literals\/} are constant values of some basic type.

\item[Examples:] {\it Names} and {\it symbolic literals\/} are used
  throughout all examples in this document (see appendix~\ref{Symbols}).

  For an example of the use of {\it old names}, consider the state defined
  as:
  \begin{alltt}
    \keyw{state} sigma \keyw{of}
      numbers : \keyw{seq of nat}
      index   : \keyw{nat}
    \Keyw{inv}  \keyw{mk\_}sigma(numbers, index) == index \keyw{not in set elems} numbers
    \Keyw{init} s == s = \keyw{mk\_}sigma([], 1)
    \keyw{end}
  \end{alltt}

  We can define an operation that increases the variable {\tt index} in
  an implicit manner:
  \begin{alltt}
    IncIndex()
    \keyw{ext wr} index : \keyw{nat}
    \keyw{post} index = index~ + 1
  \end{alltt}
  The operation {\tt IncIndex} manipulates the variable {\tt index},
  indicated with the \keyw{ext wr} clause. In the post condition, the new
  value of {\tt index} is equal to the old value of {\tt index} plus
  \texttt{1}. (See more about operations in section~\ref{op-def}).

  For a simple example of 
module 
  names, suppose that a function called 
  \texttt{build\_rel} is defined (and exported) in a 
module 
  called 
  \texttt{CGRel} as follows:
\begin{alltt}
  \keyw{types}

    Cg = <A> | <B> | <C> | <D> | <E> | <F> | 
         <G> | <H> | <J> | <K> | <L> | <S>;
    CompatRel = \keyw{map} Cg \keyw{to set of} Cg

  \keyw{functions}

    build_rel : \keyw{set of} (Cg * Cg) -> CompatRel
    build_rel (s) == \{|->\}
\end{alltt}
In another 
module 
  we can access this function by 
first importing the module \texttt{CGRel} then by 
  using the following call 
  \begin{alltt}
  CGRel`build_rel({mk_(<A>, <B>)})
  \end{alltt}


\end{description}

\subsection{The Undefined Expression}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep 
    \Ruleref{undefined expression}
    }

  \Rule{undefined expression}{
    \Lop{undefined}
    }
  
\item[Semantics:] The {\it undefined expression} is used to state
  explicitly that the result of an expression is undefined. This could
  for instance be used if it has not been decided what the result of
  evaluating the else-branch of an if-then-else expression should be.
  When an {\it undefined expression} is evaluated the
  interpreter will terminate the execution
  and report that an undefined expression was evaluated.

  Pragmatically use of undefined expressions differs from
  pre-conditions: use of a pre-condition means it is the caller's
  responsibility to ensure that the pre-condition is satisfied when
  the function is called; if an undefined expression is used it is the
  called function's responsibility to deal with error handling.

\item[Examples:] We can check that the type invariant holds before building 
  \texttt{Score} values:
  \begin{alltt}
  build_score : Team * \keyw{nat} * \keyw{nat} * \keyw{nat} * \keyw{nat} -> Score
  build_score (t,w,d,l,p) ==
    \keyw{if} 3 * w + d = p
    \keyw{then} \keyw{mk\_}Score(t,w,d,l,p)
    \keyw{else undefined}
  \end{alltt}
\end{description}

\subsection{The Precondition Expression}
\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep 
    \Ruleref{precondition expression}
    }
  \Rule{precondition expression}{
    \Lop{pre\_}, \Lit{(}, \Ruleref{expression}, \lfeed
                          \OptPt{\SeqPt{\Lit{,}, \Ruleref{expression}}},
                 \Lit{)}
    }
  
\item[Semantics:] 
  Assuming \texttt{e} is of function type the expression
  \keyw{pre\_}\texttt{(e,e1,...,en)} is true if and only if the
  pre-condition of \texttt{e} is true for arguments \texttt{e1,...,em}
  where \texttt{m} is the arity of the pre-condition of \texttt{e}. If
  \texttt{e} is not a function or \texttt{m} $>$ \texttt{n} then the
  result is \texttt{true}. If \texttt{e} has no pre-condition then the
  expression equals true.
\item[Examples:] 
  Consider the functions \texttt{f} and \texttt{g} defined below
  \begin{alltt}
  f : \keyw{nat} * \keyw{nat} -> \keyw{nat}
  f(m,n) == m \keyw{div} n
  \keyw{pre} n <> 0;

  g (n: \keyw{nat}) sqrt:\keyw{nat}
  \keyw{pre} n >= 0
  \keyw{post} sqrt * sqrt <= n \keyw{and}
       (sqrt+1) * (sqrt+1) > n
  \end{alltt}
  Then the expression
  \begin{alltt}
  \keyw{pre}\_(\keyw{let} h \keyw{in set} \{f,g, \keyw{lambda mk}\_(x,y):\keyw{nat} * \keyw{nat} & x \keyw{div} y\} 
       \keyw{in} h, 1,0,-1)
  \end{alltt}  
  is equal to 
  \begin{itemize}
  \item false if \texttt{h} is bound to \texttt{f} since this equates
        to \texttt{\keyw{pre}\_f(1,0)};
  \item true if \texttt{h} is bound to \texttt{g} since this equates
        to \texttt{\keyw{pre}\_g(1)};
  \item true if \texttt{h} is bound to 
        \texttt{\keyw{lambda} \keyw{mk}\_(x,y):\keyw{nat} * \keyw{nat} \& x \keyw{div} y} since there is no
        pre-condition defined for this function.
  \end{itemize}
  Note that however \texttt{h} is bound, the last argument
  (\texttt{-1}) is never used.
\end{description}


\section{Patterns}\label{patterns}

\begin{description}
\item[Syntax:]
  \Rule{pattern bind}{
    \Ruleref{pattern} \dsepl
    \Ruleref{bind}
    }

  \Rule{pattern}{
    \Ruleref{pattern identifier} \dsep
    \Ruleref{match value} \dsep
    \Ruleref{set enum pattern} \dsep
    \Ruleref{set union pattern} \dsep
    \Ruleref{seq enum pattern} \dsep
    \Ruleref{seq conc pattern} \dsep
    \Ruleref{map enumeration pattern} \dsep
    \Ruleref{map muinon pattern} \dsep
    \Ruleref{tuple pattern} \dsep
    \Ruleref{record pattern}
    }

  \Rule{pattern identifier}{
    \Ruleref{identifier} \dsepl \Lit{-}
    }

  \Rule{match value}{
    \Ruleref{symbolic literal} \dsep \Lit{(}, \Ruleref{expression}, \Lit{)}
    }

  \Rule{set enum pattern}{
    \Lit{\{}, [\Ruleref{pattern list}], \Lit{\}}
    }

  \Rule{set union pattern}{
    \Ruleref{pattern}, \Lit{\keyw{union}}, \Ruleref{pattern}
    }

  \Rule{seq enum pattern}{
    \Lit{[}, [\Ruleref{pattern list}], \Lit{]}
    }

  \Rule{seq conc pattern}{
    \Ruleref{pattern}, \Lit{\char'136}, \Ruleref{pattern}
    }


  \Rule{map enumeration pattern}{
    \Lit{\{}, [\Ruleref{maplet pattern list}], \Lit{\}}
    }

  \Rule{maplet pattern list}{
     \Ruleref{maplet pattern}, \SeqPt{\Lit{,}, \Ruleref{maplet pattern}}
    }

  \Rule{maplet pattern}{
    \Ruleref{pattern}, \Lit{|->}, \Ruleref{pattern}
  }

   \Rule{map muinon pattern}{
    \Ruleref{pattern}, \Lit{\keyw{munion}}, \Ruleref{pattern}
  }

  \Rule{tuple pattern}{
    \Lop{mk\_(}, \Ruleref{pattern}, \Lit{,}, \Ruleref{pattern list}, \Lit{)}
    }
 
  \Rule{record pattern}{
    \Lop{mk\_}, \Ruleref{name}, \Lit{(}, [\Ruleref{pattern list}], \Lit{)}
    }

  \Rule{pattern list}{
    \Ruleref{pattern}, \SeqPt{\Lit{,}, \Ruleref{pattern}}
    }

\item[Semantics:] A pattern is always used in a context where it is matched
  to a value of a particular type. Matching consists of checking that the
  pattern can be matched to the value, and binding any pattern identifiers
  in the pattern to the corresponding values, i.e.\ making the identifiers
  denote those values throughout their scope. In some cases where a pattern
  can be used, a bind can be used as well (see next section). If a bind is
  used it simply means that additional information (a type or a set
  expression) is used to constrain the possible values which can match the
  given pattern.

  Matching is defined as follows
  \begin{enumerate}
  \item A {\it pattern identifier} fits any type and can be matched to any
    value. If it is an identifier, that identifier is bound to the value;
    if it is the don't-care symbol \Lit{-}, no binding occurs.

  \item A {\it match value} can only be matched against the value of
    itself; no binding occurs. If a match value is not a literal like e.g.
    {\tt 7} or {\tt <RED>} it must be an expression enclosed in parentheses in order to
    discriminate it to a pattern identifier.

  \item A {\it set enumeration pattern} fits only set values. The patterns
    are matched to distinct elements of a set; all elements must be
    matched.

  \item A {\it set union pattern} fits only set values. The two patterns
    are matched to a partition of two subsets of a set. In the Toolbox
    the two subsets will always be chosen such that they are non-empty
    and disjoint.

  \item A {\it sequence enumeration pattern} fits only sequence values.
    Each pattern is matched against its corresponding element in the
    sequence value; the length of the sequence value and the number of
    patterns must be equal.

  \item A {\it sequence concatenation pattern} fits only sequence values.
    The two patterns are matched against two subsequences which together
    can be concatenated to form the original sequence value. In the
    Toolbox the two subsequences will always be chosen so that they
    are non-empty.

  \item A {\it map enumeration pattern} fits only map values. 

  \item A {\it maplet pattern list} are matched to distinct elements of a map; 
   all elements must be matched.

  \item A {\it map munion pattern} fits only map values. 
   The two patterns are matched to a partition of two sub maps of a map.
   In the VDM interpreters the two sub maps will always be chosen such that they are non-empty and disjoint.

  \item A {\it tuple pattern} fits only tuples with the same number of
    elements. Each of the patterns are matched against the corresponding
    element in the tuple value.

  \item A {\it record pattern} fits only record values with the same tag.
    Each of the patterns are matched against the field of the record value.
    All the fields of the record must be matched.
  \end{enumerate}

\item[Examples:] The simplest kind of pattern is the pattern
identifier. An example of this is given in the following let
expression:
\begin{alltt}
  \keyw{let} top = GroupA(1)
  \keyw{in} top.sc
\end{alltt}
Here the identifier \texttt{top} is bound to the head of the sequence
\texttt{GroupA} and the identifier may then be used in the body of the
let expression.

In the following examples we use match values:
\begin{alltt}
  \keyw{let} a = <France>
  \keyw{in} \keyw{cases} GroupA(1).team:
             <Brazil> -> "Brazil are winners",
             (a)      -> "France are winners",
             \keyw{others}    -> "Neither France nor Brazil are winners"
     \keyw{end;}
\end{alltt}
Match values can only match against their own values, so here if the
team at the head of \texttt{GroupA} is \texttt{<Brazil>} then the
first clause is matched; if the team at the head of \texttt{GroupA} is
\texttt{<France>} then the second clause is matched. Otherwise the
\keyw{others} clause is matched. Note here that the use of brackets
around \texttt{a} forces \texttt{a} to be considered as a match value.

Set enumerations match patterns to elements of a set. For instance in
\begin{alltt}
  \keyw{let} \{sc1, sc2, sc3, sc4\} = \keyw{elems} GroupA
  \keyw{in} sc1.points + sc2.points + sc3.points + sc4.points;
\end{alltt}
the identifiers \texttt{sc1}, \texttt{sc2}, \texttt{sc3} and
\texttt{sc4} are bound to the four elements of \texttt{GroupA}. Note
that the choice of binding is loose - for instance
\texttt{sc1} may be bound to [any] element of \texttt{\keyw{elems}
GroupA}. In this case if \texttt{\keyw{elems} GroupA} does not contain
precisely four elements, then the expression is not well-formed.

A set union pattern can be used to decompose a set for recursive
function calls. An example of this is the function \texttt{set2seq}
which converts a set into a sequence (with arbitrary order):
\begin{alltt}
  set2seq[@elem] : \keyw{set of} @elem -> \keyw{seq of} @elem
  set2seq(s) ==
    \keyw{cases} s:
      \{\} -> [],
      \{x\} -> [x],
      s1 \keyw{union} s2 -> (set2seq[@elem](s1))^(set2seq[@elem](s2))
    \keyw{end}
\end{alltt}
In the third cases alternative we see the use of a set union pattern. This
binds \texttt{s1} and \texttt{s2} to arbitrary subsets of \texttt{s}
such that they partition \texttt{s}. The Toolbox interpreter always
ensures a disjoint partition.

Sequence enumeration patterns can be used to extract specific elements
from a sequence. An example of this is the function \texttt{promoted}
which extracts the first two elements of a seqnce of scores and
returns the corresponding pair of teams:
\begin{alltt}
  promoted : \keyw{seq of} Score -> Team * Team
  promoted([sc1,sc2]^-) == \keyw{mk\_}(sc1.team,sc2.team);
\end{alltt}
Here \texttt{sc1} is bound to the head of the argument sequence, and
\texttt{sc2} is bound to the second element of the sequence. If
\texttt{promoted} is called with a sequence with fewer than two
elements then a runtime error occurs. Note that as we are not
interested in the remaining elements of the list we use a don't care
pattern for the remainder. 

The preceding example also demonstrated the use of sequence
concatenation patterns. Another example of this is the function
\texttt{quicksort} which implements a standard quicksort algorithm:
\begin{alltt}
  quicksort : \keyw{seq of nat} -> \keyw{seq of nat}
  quicksort (l) ==
    \keyw{cases} l:
      [] -> [],
      [x] -> [x],
      [x,y] -> \keyw{if} x < y \keyw{then} [x,y] \keyw{else} [y,x],
      -^[x]^- -> quicksort ([y | y \keyw{in set elems} l & y < x]) ^ 
                 [x] ^ quicksort ([y | y \keyw{in set elems} l & y > x])
    \keyw{end}
\end{alltt}
Here, in the second cases clause a sequence concatenation pattern is
used to decompose \texttt{l} into an arbitrary pivot element and two
subsequences. The pivot is used to partition the list into those
values less than the pivot and those values greater, and these two
partitions are recursively sorted.


Maplet pattern match patterns to elements of a maplet.
\begin{alltt}
\keyw{let} \{a |-> b\} = \{1 |-> 2\} \keyw{in} \keyw{mk\_}(a,b) = \keyw{mk\_}(1,2)
\end{alltt}

Maplet pattern list match patterns to elements of each maplet in a map.
\begin{alltt}
\keyw{let} \{1 |-> a,a |-> b,b |-> c\} = \{1 |-> 4,2 |-> 3,4 |-> 2\} \keyw{in}
c = 3
\end{alltt}

Map munion pattern can be used to decompose a map for recursive function calls.
Following \texttt{map2seq} function converts a map to a seq of maplet.
\begin{alltt}
map2seq[@T1, @T2] : map @T1 to @T2 -> seq of (map @T1 to @T2)
map2seq(m) ==
  \keyw{cases} m:
    (\{|->\})	-> [],
    \{- |-> -\}	-> [m],
    m1 \keyw{munion} m2 -> map2seq[@T1, @T2] (m1) ^  map2seq[@T1, @T2] (m2)
  \keyw{end};
\end{alltt}
Here, in the third cases clause a map munion pattern is used to decompose \texttt{m} 
into two maps.


Tuple patterns can be used to bind tuple components to
identifiers. For instance since the function \texttt{promoted} defined
above returns a pair, the following value definition binds the winning
team of \texttt{GroupA} to the identifier \texttt{Awinner}:
\begin{alltt}
  \keyw{values}

    \keyw{mk\_}(Awinner,-) = promoted(GroupA);
\end{alltt}

Record patterns are useful when several fields of a record are used in
the same expression. For instance the following expression constructs
a map from team names to points score:
\begin{alltt}
  \{ t |-> w * 3 + l | \keyw{mk\_}Score(t,w,l,-,-) \keyw{in set elems} GroupA\}
\end{alltt}
The function \texttt{print\_Expr} on page \pageref{printExprDef} also gives
several examples of record patterns.




\end{description}

\section{Bindings}\label{bind}

\begin{description}
\item[Syntax:]
  \Rule{bind}{
    \Ruleref{set bind} \dsepl \Ruleref{type bind}
    }

  \Rule{set bind}{
    \Ruleref{pattern}, \Lop{in set}, \Ruleref{expression}
    }

  \Rule{type bind}{
    \Ruleref{pattern}, \Lit{:}, \Ruleref{type}
    }

  \Rule{bind list}{
    \Ruleref{multiple bind}, \SeqPt{\Lit{,}, \Ruleref{multiple bind}}
    }

  \Rule{multiple bind}{
    \Ruleref{multiple set bind} \dsep
    \Ruleref{multiple type bind}
    }

  \Rule{multiple set bind}{
    \Ruleref{pattern list}, \Lop{in set}, \Ruleref{expression}
    }

  \Rule{multiple type bind}{
    \Ruleref{pattern list}, \Lit{:}, \Ruleref{type}
    }

\item[Semantics:] A {\it bind} matches a pattern to a value. In a {\it
    set bind} the value is chosen from the set defined by the set
    expression of the bind. In a {\it type bind} the value is chosen
    from the type defined by the type expression.  {\it Multiple bind}
    is the same as {\it bind} except that several patterns are bound
    to the same set or type.  Notice that type binds {\bf cannot} be
    executed by the interpreter.  This would require the interpreter
    to search through infinite domains like the natural numbers.

\item[Examples:] Bindings are mainly used in quantified expressions and
  comprehensions which can be seen from these examples:
  \begin{alltt}
    \keyw{forall} i, j \keyw{in set inds} list \& i < j => list(i) <= list(j)
      
    \{ y | y \keyw{in set} S & y > 2 \}

    \{ y | y: nat & y > 3 \}

    occurs : \keyw{seq1 of char} * \keyw{seq1 of char} -> \keyw{bool}
    occurs (substr,str) ==
      \keyw{exists} i,j \keyw{in set inds} str & substr = str(i,...,j);

  \end{alltt}
\end{description}

\section{Value (Constant) Definitions} \label{valuedef}

\vdmslpp{\vdmsl}{\vdmpp}\ supports the definition of constant
values. A value definition corresponds to a constant definition in
traditional programming languages.

\begin{description}
\item[Syntax:]
  \Rule{value definitions}{
    \Lop{values}, 
    \OptPt{\ifthenelse{\boolean{VDMpp}}{\Ruleref{access value definition}}%
                                       {\Ruleref{value definition}}, \lfeed
           \SeqPt{\Lit{;}, 
                  \ifthenelse{\boolean{VDMpp}}{\Ruleref{access value definition}}%
                                              {\Ruleref{value definition}}
                 }, 
           \OptPt{\Lit{;}}
          }
    }

  \ifthenelse{\boolean{VDMpp}}{
    \Rule{access value definition}{
       (\OptPt{\Ruleref{access}}, \OptPt{\Lop{static}})  \dsepl\ (\OptPt{\Lop{static}}, \OptPt{\Ruleref{access}}), \lfeed 
         \Ruleref{value definition}
    }}{}


  \Rule{value definition}{
    \Ruleref{pattern}, \OptPt{\Lit{:}, \Ruleref{type}}, \Lit{=}, \Ruleref{expression}
    }

\item[Semantics:] The value definition has the form:
  \begin{alltt}
    \keyw{values}
      \ifthenelse{\boolean{VDMpp}}{access}{} pat1 = e1;
      \ldots
      \ifthenelse{\boolean{VDMpp}}{access}{} patn = en
  \end{alltt}

  
  The global values (defined in a value definition) can be referenced
  at all levels in a \vdmslpp{\vdmsl}{\vdmpp} specification.  However,
  in order to be able to execute a specification these 
  values must be defined before they are used in the sequence of value
  definitions. This ``declaration before use'' principle is only used
  by the interpreter for value definitions.
  Thus for instance functions can be used before they are declared. In
  standard VDM-SL there are not any restrictions on the order of the
  definitions at all. It is possible to provide a type restriction as
  well, and this can be useful in order to obtain more exact type
  information.


\item[Examples:] The example below, taken from \cite{Fitzgerald&98}
  assigns token values to identifiers  
  \texttt{p1} and \texttt{eid2}, an \texttt{Expert} record value to 
  \texttt{e3} and an \texttt{Alarm} record value to \texttt{a1}.
\begin{alltt}
     \keyw{types}

     Period = \keyw{token};
     ExpertId = \keyw{token};
     Expert :: expertid : ExpertId
               quali : \keyw{set of} Qualification
     \keyw{inv} ex == ex.quali <> \{\};
     Qualification = <Elec> | <Mech> | <Bio> | <Chem>;
     Alarm :: alarmtext : \keyw{seq of} char
              quali : Qualification

     \keyw{values}
 
     \PUBLIC p1: Period = mk_token("Monday day");
     \PRIVATE eid2 : ExpertId = mk_token(145);
     \PROTECTED e3 : Expert = mk_Expert(eid2, { <Mech>, <Chem> });
     \mbox{} a1 : Alarm = mk_Alarm("CO2 detected", <Chem>)
\end{alltt}
  As this example shows, a value can depend on other values which are
  defined previous to itself.
  A top-level specification can consist of
  specifications from a number of files or modules (see
  section~\ref{top-level}).  It is good practice not to let a value depend
  on values defined in other modules as the ordering is important.
\end{description}


\section{The State Definition}\label{statedef}

If global variables are desired in a specification, it is possible to make
a state definition. The components of the state definition can be
considered the collection of global variables which can be referenced
inside operations. A state in a module is initialised before any of the
operation definitions (using that state) in a module can be used by
the interpreter.

\begin{description}
\item[Syntax:]
  \Rule{state definition}{
    \Lop{state}, \Ruleref{identifier}, \Lop{of}, \Ruleref{field list}, \lfeed
    \OptPt{\Ruleref{invariant}}, \OptPt{\Ruleref{initialisation}}, \Lop{end}, \OptPt{\Lit{;}}
    }

  \Rule{invariant}{
    \Lop{inv}, \Ruleref{invariant initial function}
    }

  \Rule{initialisation}{
    \Lop{init}, \Ruleref{invariant initial function}
    }

  \Rule{invariant initial function}{
    \Ruleref{pattern}, \Lit{==}, \Ruleref{expression}}

\item[Semantics:] The state definition has the form:
  \begin{alltt}
    \keyw{state} ident \keyw{of}
      id1 : type1
      \ldots
      idn : typen
    \Keyw{inv}  pat1 == inv
    \Keyw{init} pat2 == init
    \keyw{end}
  \end{alltt}
  A state identifier {\tt idn} is declared of a specific type {\tt typen}.
  The invariant {\tt inv} is a boolean expression denoting a
  property which must hold for the state {\tt ident} at all
  times. {\tt init} denotes a condition which must hold initially.
  It should be noticed that in order to use the
  interpreter, it is
  necessary to have an initialisation predicate (if any of the
  operations using the state are to be executed). In addition the body of
  this initialisation predicate must be a binary equality expression with
  the name (which also must be used as the pattern) of the entire state on
  the left-hand side of the equality and the right-hand side must evaluate
  to a record value of the correct type. This enables the interpreter
  to evaluate the {\tt init} condition. A simple example of an
  initialisation predicate is shown below:

  \begin{alltt}
  \keyw{state} St \keyw{of}
    x:\keyw{nat}
    y:\keyw{nat}
    l:\keyw{seq1 of nat}
  \keyw{init} s == s = \keyw{mk\_}St(0,0,[1])
  \keyw{end}
  \end{alltt}

  In the specification of both the invariant and the initial value the
  state must be manipulated as a whole, and this is done by referring to it
  as a record tagged with the state name (see the example). When a field in
  the state is manipulated in some operation, the field must however be
  referenced to directly by the field name without pre-fixing it with the
  state name.

\item[Examples:] In the following example we create one state variable:
  \begin{alltt}
  \keyw{types }

  GroupName = <A> | <B> | <C> | <D> | <E> | <F> | <G> | <H>

  \keyw{state} GroupPhase \keyw{of}
    gps : \keyw{map} GroupName \keyw{to set of} Score
  \keyw{inv mk\_}GroupPhase(gps) ==
    \keyw{forall} gp \keyw{in set rng gps} & 
      (\keyw{card} gp = 4 \keyw{and}
       \keyw{forall} sc \keyw{in set} gp & sc.won + sc.lost + sc.drawn <= 3)
  \keyw{init} gp ==
    gp = \keyw{mk\_}GroupPhase ({ <A> |-> 
                                init_sc ({<Brazil>, <Norway>, 
                                    <Morocco>, <Scotland>}),
                         ...})
  \keyw{end}

  \keyw{functions}

  init_sc : \keyw{set of} Team -> \keyw{set of} Score
  init_sc (ts) ==
    \{ \keyw{mk\_}Score (t,0,0,0,0) | t \keyw{in set ts} \}
  \end{alltt}
  In the invariant we state that each group has four teams, and no team 
  plays more than three games. Initially no team has played any games.

\end{description}

\section{Operation Definitions} \label{op-def}

Operations have already been mentioned in section~\ref{algorithm}. The
general form is described
\ifthenelse{\boolean{VDMsl}}{here.}{immediately below, and special
  operations called \emph{constructors} which are used for
  constructing instances of a class are described in
  section~\ref{constructors}.} 

\begin{description}
\item[Syntax:]
  \Rule{operation definitions}{
    \Lop{operations}, 
    \OptPt{\ifthenelse{\boolean{VDMpp}}{\Ruleref{access operation definition}}%
                                       {\Ruleref{operation definition}}, \lfeed
           \SeqPt{\Lit{;}, 
                  \ifthenelse{\boolean{VDMpp}}{\Ruleref{access operation definition}}%
                                       {\Ruleref{operation definition}}
                 }, 
           \OptPt{\Lit{;}}
          }
    }

  \ifthenelse{\boolean{VDMpp}}{
    \Rule{access operation definition}{(
      \OptPt{\Ruleref{access}}, \OptPt{\Lop{static}})  \dsep\  
     (
      \OptPt{\Lop{static}}, \OptPt{\Ruleref{access}}), \lfeed
      \Ruleref{operation definition}
    }}{}


\Rule{operation definition}{
  \Ruleref{explicit operation definition} \dsep
  \Ruleref{implicit operation definition} \dsep
  \Ruleref{extended explicit operation definition}
  }

\Rule{explicit operation definition}{
  \Ruleref{identifier}, \Lit{:}, \Ruleref{operation type}, \lfeed
  \Ruleref{identifier}, \Ruleref{parameters}, \lfeed
  \Lit{{\tt ==}}, \lfeed  \Ruleref{operation body}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{expression}}
  }

\Rule{implicit operation definition}{
  \Ruleref{identifier}, \Ruleref{parameter types}, \lfeed
  \OptPt{\Ruleref{identifier type pair list}}, \lfeed
  \Ruleref{implicit operation body}
  }

\Rule{implicit operation body}{
  \OptPt{\Ruleref{externals}}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
  \Lop{post}, \Ruleref{expression}, \lfeed
  \OptPt{\Ruleref{exceptions}}
  }

\Rule{extended explicit operation definition}{
  \Ruleref{identifier}, \lfeed
  \Ruleref{parameter types}, \lfeed
  \OptPt{\Ruleref{identifier type pair list}}, \lfeed
  \Lit{==}, \Ruleref{operation body}, \lfeed
  \OptPt{\Ruleref{externals}}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{expression}}, \lfeed
  \OptPt{\Ruleref{exceptions}}
}

\Rule{operation type}{
  \Ruleref{discretionary type}, \Lit{{\tt ==>}}, \Ruleref{discretionary type}
  }

\Rule{discretionary type}{
  \Ruleref{type} \dsepl \Lit{()}
  }

\Rule{parameters}{
  \Lit{(}, \OptPt{\Ruleref{pattern list}}, \Lit{)}
  }

\Rule{pattern list}{
  \Ruleref{pattern}, \SeqPt{\Lit{,}, \Ruleref{pattern}}
  }

\Rule{operation body}{
  \Ruleref{statement} \dsep 
  \Lop{is not yet specified}\index{\keyw{is not yet specified}!operations}
  }

\Rule{externals}{
  \Lop{ext}, \Ruleref{var information}, \SeqPt{\Ruleref{var information}}
  }

\Rule{var information}{
  \Ruleref{mode}, \Ruleref{name list}, \OptPt{\Lit{:}, \Ruleref{type}}
  }

\Rule{mode}{
  \Lop{rd} \dsepl \Lop{wr}
  }

\Rule{name list}{
  \Ruleref{identifier}, \SeqPt{\Lit{,}, \Ruleref{identifier}}
  }

\Rule{exceptions}{
  \Lop{errs}, \Ruleref{error list}
  }

\Rule{error list}{
  \Ruleref{error}, \SeqPt{\Ruleref{error}}
  }

\Rule{error}{
  \Ruleref{identifier}, \Lit{:}, \Ruleref{expression}, \Lit{->}, \Ruleref{expression}
  }

\item[Semantics:]

The following example of an explicit operation updates the 
state \texttt{GroupPhase} 
when one team beats another.
\begin{alltt}\label{winDef}
  Win : Team * Team ==> ()
  Win (wt,lt) ==
    \keyw{let} gp \keyw{in set dom} gps \keyw{be st} 
         \{wt,lt\} \keyw{subset} \{sc.team | sc \keyw{in set} gps(gp)\}
    \keyw{in} gps := gps ++ \{ gp |-> 
                        \{\keyw{if} sc.team = wt
                         \keyw{then mu}(sc, won |-> sc.won + 1,
                                     points |-> sc.points + 3)
                         \keyw{else if} sc.team = lt
                         \keyw{then mu}(sc, lost |-> sc.lost + 1)
                         \keyw{else} sc 
                    | sc \keyw{in set} gps(gp)\}\}
    \Keyw{pre} \keyw{exists} gp \keyw{in set dom} gps & 
          \{wt,lt\} \keyw{subset} \{sc.team | sc \keyw{in set} gps(gp)\};
\end{alltt}
An explicit operation consists of a statement (or several composed
using a block statement), as described in section \ref{sec:stmt}. The 
statement may access any 
state
variables it wishes, reading and writing to them as it sees fit.

An implicit operation is specified using an optional pre-condition,
and a mandatory post-condition. For example we could specify the
\texttt{Win} operation implicitly:
\begin{alltt}
  Win (wt,lt: Team)
  \Keyw{ext wr} gps : \keyw{map} GroupName \keyw{to set of} Score
  \Keyw{pre} \keyw{exists} gp \keyw{in set dom} gps & 
          \{wt,lt\} \keyw{subset} \{sc.team | sc \keyw{in set} gps(gp)\}
  \Keyw{post} \keyw{exists} gp \keyw{in set dom} gps &
         \{wt,lt\} \keyw{subset} \{sc.team | sc \keyw{in set} gps(gp)\}
         \keyw{and} gps = gps~ ++ 
                       \{ gp |-> 
                         \{\keyw{if} sc.team = wt
                          \keyw{then} \keyw{mu}(sc, won |-> sc.won + 1,
                                     points |-> sc.points + 3)
                          \keyw{else if} sc.team = lt
                          \keyw{then mu}(sc, lost |-> sc.lost + 1)
                          \keyw{else} sc 
                     | sc \keyw{in set} gps(gp)\}\};
\end{alltt}

The externals field lists the 
state
variables that the
operation will manipulate. The 
state
variables listed after the reserved
word \keyw{rd} can only be read whereas the operation can both read and
write the variables listed after \keyw{wr}. 
 
For these pre- and post-conditions the interpreter also
creates new functions as with the pre- and post-conditions of operation
definitions.  However, if a specification contains a global state, the
state is also part of the newly created functions. Thus, functions
with the following signatures are created for operations with pre-
and/or post-conditions\footnote{However, you should remember that
these pre and post condition predicates for an operation are simply
boolean functions and the state components are thus not changed by
calling such a predicate.}:
\begin{alltt}
  \keyw{pre\_}Op : InType * State +> \keyw{bool}

  \keyw{post\_}Op : InType * OutType * State * State +> \keyw{bool}
\end{alltt}
with the following exceptions:
\begin{itemize}
\item If the operation does not take any arguments, the {\tt InType} part
  of the signature is left out in both the {\tt \keyw{pre\_}Op} and {\tt
    \keyw{post\_}Op} signatures.

\item If the operation does not return a value, the {\tt OutType} part is
  left out in the {\tt \keyw{post\_}Op} signature.

\item If the specification does not define a state, the {\tt State} part(s)
  of both signatures are left out.
\end{itemize}

In the {\tt \keyw{post\_}Op} signature, the first {\tt State} part is for
the old state, whereas the second {\tt State} part is for the 
state after the operation call.

For instance, consider the following specifications:

\begin{quotation}
\begin{minipage}[t]{.4\textwidth}
\begin{alltt}
\keyw{module} A

\keyw{definitions}

\keyw{state} St \keyw{of}
  n : \keyw{nat}
\keyw{end}

\keyw{operations}

Op1 (a : \keyw{nat}) b :\keyw{nat}
\keyw{pre} a > 0
\keyw{post} b = 2 * a;

Op2 () b : \keyw{nat}
\keyw{post} b = 2;

Op3 ()
\keyw{post} \keyw{true}

\keyw{end} A

\end{alltt}
\end{minipage}
\begin{minipage}[t]{.4\textwidth}
\begin{alltt}
\keyw{module} B

\keyw{definitions}

\keyw{operations}

Op1 (a : \keyw{nat}) b : \keyw{nat}
\keyw{pre} a > 0
\keyw{post} b = 2 * a;

Op2 () b : \keyw{nat}
\keyw{post} b = 2;

Op3 ()
\keyw{post} \keyw{true}

\keyw{end} B
\end{alltt}
\end{minipage}
\end{quotation}

For \textbf{module A} we could then quote the pre and post conditions
defined in this specification as illustrated below

\begin{tabular}{|>{\ttfamily\selectfont}p{.4\textwidth}p{.4\textwidth}|} \hline
\textrm{Quote expression} & Explanation \\ \hline
\keyw{pre}\_Op1(1,\keyw{mk}\_St(2))              
  & \texttt{a} bound to 1 in state \texttt{St} with \texttt{n}  bound to 2 \\
\keyw{post}\_Op1(1,2,\keyw{mk}\_St(1), \keyw{mk}\_St(2)) 
  & \texttt{a} bound to 1, \texttt{b} bound to 2, state before with
    \texttt{n} bound to 1, state after with \texttt{n} bound to 2 \\
\keyw{post}\_Op2(2,\keyw{mk}\_St(1), \keyw{mk}\_St(2))   
  & \texttt{b} bound to 2, state before with \texttt{n} bound to 1, state
    after with \texttt{n} bound to 2 \\
\keyw{post}\_Op3(\keyw{mk}\_St(1), \keyw{mk}\_St(2))     
  & state before with \texttt{n} bound to 1, state after with
    \texttt{n} bound to 2 \\
\hline
\end{tabular}

For \textbf{module B} we can quote the pre and post conditions defined
in this specification as illustrated below

\begin{tabular}{|>{\ttfamily\selectfont}p{.4\textwidth}p{.4\textwidth}|} \hline
\textrm{Quote expression} & Explanation \\ \hline
\keyw{pre}\_Op1(1)     & \texttt{a} bound to 1 \\
\keyw{post}\_Op1(1,2)  & \texttt{a} bound to 1, \texttt{b} bound to 2\\
\keyw{post}\_Op2(2)    & \texttt{b} bound to 2\\
\keyw{post}\_Op3()     & No binding at all\\
\hline
\end{tabular}

\vspace{2ex}


The exceptions clause can be used to describe how an operation should
deal with error situations. The rationale for having the exception
clause is to give the user the ability to separate the exceptional
cases from the normal cases. The specification using exceptions does
not give any commitment as to how exceptions are to be signalled, but
it gives the means to show under which circumstances an error
situation can occur and what the consequences are for the result of
calling the operation.

The exception clause has the form:
\begin{alltt}
   \keyw{errs} COND1: c1 -> r1
       \ldots
       CONDn: cn -> rn
\end{alltt}
The condition names {\tt COND1}, \ldots, {\tt CONDn} are identifiers
which describe the kind of error which can be raised\footnote{Notice
that these names are purely of mnemonic value, i.e.\ semantically they
are not important.}. The condition expressions {\tt c1}, \ldots, {\tt
cn} can be considered as pre-conditions for the different kinds of
errors. Thus, in these expressions the identifiers from the arguments
list and the variables from the externals list can be used (they have
the same scope as the pre-condition). The result expressions {\tt r1},
\ldots, {\tt rn} can correspondingly be considered as post-conditions
for the different kinds of errors. In these expressions the result
identifier and old values of global variables (which can be written
to) can also be used. Thus, the scope corresponds to the scope of the
post-condition.

Superficially there appears to be some redundancy between exceptions
and pre-conditions here. However there is a conceptual distinction
between them which dictates which should be used and when. The
pre-condition specifies what callers  to the operation must ensure for
correct behaviour; the exception clauses indicate that the operation
being specified takes responsibility for error handling when an
exception condition is satisfied. Hence normally exception clauses and
pre-conditions do not overlap.

The next example of an operation uses the following state definition:
\begin{alltt}
  \keyw{state} qsys \keyw{of}
    q : Queue
  \keyw{end}
\end{alltt}    
This example shows how exceptions with an implicit definition can be used:
\begin{alltt}
  DEQUEUE() e: [Elem]
  \keyw{ext} \keyw{wr} q : Queue
  \keyw{post} q~ = [e] ^ q
  \keyw{errs} QUEUE_EMPTY: q = [] -> q = q~ \keyw{and} e = \keyw{nil}
\end{alltt}

This is a dequeue operation which uses a global variable {\tt q} of
type {\tt Queue} to get an element {\tt e} of type {\tt Elem} out of
the queue. The exceptional case here is that the queue in
which the exception clause specifies how the operation should
behave is empty.

Note that the Toolbox creates a function here:
\begin{alltt}
  \keyw{post\_}DEQUEUE: [Elem] * qsys * qsys +> \keyw{bool}
\end{alltt}


\end{description}


\section{Statements}\label{sec:stmt}

In this section the different kind of statements will be described
one by one. Each of them will be described by means of:
\begin{itemize}
\item A syntax description in BNF.
\item An informal semantics description.
\item An example illustrating its usage.
\end{itemize}

\subsection{Let Statements}\label{letstmt}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \Ruleref{let statement} \dsep
    \Ruleref{let be statement} \dsep
    \ldots
    }

  \Rule{let statement}{
    \Lop{let}, \Ruleref{local definition}, \SeqPt{\Lit{,}, \Ruleref{local definition}}, \lfeed
    \Lop{in}, \Ruleref{statement}
    }

  \Rule{let be statement}{
    \Lop{let}, \Ruleref{bind}, \OptPt{\Lop{be}, \Lop{st}, \Ruleref{expression}},
    \Lop{in}, \lfeed
    \Ruleref{statement}
    }

  \Rule{local definition}{
    \Ruleref{value definition} \dsep \Ruleref{function definition}
    }

  \Rule{value definition}{ 
    \Ruleref{pattern}, \OptPt{\Lit{:}, \Ruleref{type}}, \Lit{=}, \Ruleref{expression}
    }

  where the ``function definition'' component is described in
  section~\ref{functiondef}.

\item[Semantics:] The {\it let statement} and the {\it let-be-such-that
    statement} are similar to the corresponding {\it let} and {\it
    let-be-such-that expressions} except that the {\it in} part is a
  statement instead of an expression. Thus it can be explained as follows:

  A simple {\it let statement} has the form:
  \begin{alltt}
    \keyw{let} p1 = e1, \ldots, pn = en \keyw{in} s
  \end{alltt}
  where {\tt p1, \ldots, pn} are patterns, {\tt e1, \ldots, en} are
  expressions which match the corresponding patterns {\tt pi}, and {\tt s}
  is a statement, of any type, involving the pattern identifiers of {\tt
    p1, \ldots, pn}. It denotes the evaluation of the statement {\tt s} in
  the context in which the patterns {\tt p1, \ldots, pn} are matched
  against the corresponding expressions {\tt e1, \ldots, en}.

  More advanced let statements can also be made by using local function
  definitions. The semantics of doing that is simply that the scope of such
  locally defined functions is restricted to the body of the let statement.

  In VDM-SL the collection of definitions may be mutually recursive.
  However, this is not supported by the interpreter in  VDM-SL.
  Furthermore, the definitions must be ordered such that
  all constructs are defined before they are used.

  A {\it let-be-such-that statement} has the form
  \begin{alltt}
    \keyw{let} b \keyw{be st} e \keyw{in} s
  \end{alltt}
  where {\tt b} is a binding of a pattern to a set value (or a type), {\tt
    e} is a boolean expression, and {\tt s} is a statement, involving the
  pattern identifiers of the pattern in {\tt b}. The {\tt \keyw{be st} e}
  part is optional. The expression denotes the evaluation of the statement
  {\tt s} in the context where the pattern from {\tt b} has been matched
  against an element in the set (or type) from {\tt b}\footnote{Remember
    that only the set bindings can be executed by means of the
    interpreter.}. 
  If the \keyw{be st}
  expression {\tt e} is present, only such bindings where {\tt e} evaluates
  to true in the matching context are used.
     
\item[Examples:] An example of a \keyw{let be st} statement is provided in the
  operation \texttt{GroupWinner} 
  which returns the winning team in a given group: 
  \begin{alltt}
  GroupWinner : GroupName ==> Team
  GroupWinner (gp) ==
    \keyw{let} sc \keyw{in set} gps(gp) \keyw{be st}
       \keyw{forall} sc' \keyw{in set} gps(gp) \verb+\+ \{sc\} & 
          (sc.points > sc'.points) \keyw{or}
          (sc.points = sc'.points \keyw{and} sc.won > sc'.won)
    \keyw{in return} sc.team
  \end{alltt}
  The companion operation \texttt{GroupRunnerUp} gives an example of a simple 
  let statement as well:
  \begin{alltt}
  GroupRunnerUp_expl : GroupName ==> Team
  GroupRunnerUp_expl (gp) ==
    \keyw{def} t = GroupWinner(gp)
    \keyw{in let} sct = \keyw{iota} sc \keyw{in set} gps(gp) & sc.team = t
      \keyw{in}
         \keyw{let} sc \keyw{in set} gps(gp) \verb+\+ \{sct\} \keyw{be st}
           \keyw{forall} sc' \keyw{in set} gps(gp) \verb+\+ \{sc,sct\} & 
             (sc.points > sc'.points) \keyw{or}
             (sc.points = sc'.points \keyw{and} sc.won > sc'.won)
         \keyw{in return} sc.team
  \end{alltt}
  Note the use of the \texttt{def} statement (section \ref{defstmt})
  here; this is used rather than a \texttt{let} statement since the
  right-hand side is an operation call, and therefore is not an
  expression. 

\end{description}

\subsection{The Define Statement}\label{defstmt}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{def statement} \dsep \ldots
    }

  \Rule{def statement}{
    \Lop{def}, 
    \Ruleref{equals definition}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{equals definition}},\OptPt{\Lit{;}},
    \Lop{in}, \lfeed
    \Ruleref{statement}
    } 

  \Rule{equals definition}{
    \Ruleref{pattern bind}, \Lit{=},
    \Ruleref{expression}}

\item[Semantics:] A {\it define statement} has the form:
  \begin{alltt}
    \Keyw{def} pb1 = e1;
        \ldots
        pbn = en
    \keyw{in}
      s
  \end{alltt}
  The {\it define statement} corresponds to a {\it define expression}
  except that it is also allowed to use operation calls on the right-hand
  sides. Thus, operations that change the state can also be used here, and
  if there are more than one definition they are evaluated in the order in
  which they are presented.  It denotes the evaluation of the statement
  {\tt s} in the context in which the patterns (or binds) {\tt pb1, \ldots,
    pbn} are matched against the values returned by the corresponding
  expressions or operation calls {\tt e1, \ldots, en}\footnote{If binds are
    used it simply means that the values which can match the pattern are
    further constrained by the type or set expression as it is explained in
    section~\ref{patterns}.}.

\item[Examples:] Given the following sequences:
  \begin{alltt}
  secondRoundWinners = [<A>,<B>,<C>,<D>,<E>,<F>,<G>,<H>];
  secondRoundRunnersUp = [<B>,<A>,<D>,<C>,<F>,<E>,<H>,<G>]
  \end{alltt}
  The operation \texttt{SecondRound}%
  returns the sequence of pairs 
  representing the second round games gives an example of a \keyw{def} 
  statement:
  \begin{alltt}
  SecondRound : () ==> \keyw{seq of} (Team * Team)
  SecondRound () ==
  \keyw{def} winners = \{ gp |-> GroupWinner(gp) | gp \keyw{in set dom} gps \};
     runners_up = \{ gp |-> GroupRunnerUp(gp) | gp \keyw{in set dom} gps\}
  \keyw{in return} ([mk_(winners(secondRoundWinners(i)),
                runners_up(secondRoundRunnersUp(i))) 
           | i \keyw{in set} \{1,...,8\}])
  \end{alltt}

\end{description}

\subsection{The Block Statement} \label{dcl-stmt}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{block statement} \dsep \ldots
    }

  \Rule{block statement}{
    \Lit{(}, \SeqPt{\Ruleref{dcl statement}}, \lfeed
    \Ruleref{statement}, \SeqPt{\Lit{;}, \Ruleref{statement}}, \OptPt{\Lit{;}}, \Lit{)}
    }

  \Rule{dcl statement}{
    \Lop{dcl}, \Ruleref{assignment definition}, \lfeed
    \SeqPt{\Lit{,}, \Ruleref{assignment definition}}, \Lit{;}
    }

  \Rule{assignment definition}{
    \Ruleref{identifier}, \Lit{:}, \Ruleref{type}, \OptPt{\Lit{:=},
    \Ruleref{expression}}}

\item[Semantics:] The {\it block statement} corresponds to block statements
  from traditional high-level programming languages.  It enables the use of
  locally defined variables (by means of the declare statement) which can
  be modified inside the body of the block statement. It simply denotes the
  ordered execution of what the individual statements prescribe. The first
  statement in the sequence that returns a value causes the evaluation of
  the sequence statement to terminate. This value is returned as the
  value of the block statement. If none of the statements in the block
  returns a value, the evaluation of the block statement is terminated when
  the last statement in the block has been evaluated. When the block
  statement is left the values of the local variables are discharged. Thus,
  the scope of these variables is simply inside the block statement.
      
\item[Examples:] In the context of 
state definition
  \begin{alltt}\label{stdef}
  \keyw{state} St \keyw{of}
    x:\keyw{nat}
    y:\keyw{nat}
    l:\keyw{seq1 of nat}
  \keyw{end}
  \end{alltt}
  the operation \texttt{Swap} uses a block statement to swap the values of 
  variables \texttt{x} and \texttt{y}:
  \begin{alltt}
  Swap : () ==> ()
  Swap () ==
    (\keyw{dcl} temp: \keyw{nat} := x;
     x := y;
     y := temp
    )
  \end{alltt}

\end{description}

\subsection{The Assignment Statement}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \ifthenelse{\boolean{VDMpp}}{\Ruleref{general assign statement}}%
                                {\Ruleref{assign statement}} \dsep
    \ldots
    }

\ifthenelse{\boolean{VDMpp}}{%
  \Rule{general assign statement}{
  \Ruleref{assign statement} \dsep
  \Ruleref{multiple assign statement}
  }
}%
{}

\Rule{assign statement}{
  \Ruleref{state designator}, \Lit{:=}, 
    \Ruleref{expression}
  }

  \Rule{state designator}{
    \Ruleref{name} \dsep
    \Ruleref{field reference} \dsep
    \Ruleref{map or sequence reference}
    }

  \Rule{field reference}{
    \Ruleref{state designator}, \Lit{.}, \Ruleref{identifier}
    }

%koizumi change_start
%  \Rule{map reference}{
%    \Ruleref{state designator}, \Lit{(}, \Ruleref{expression}, \Lit{)}
%    }

%  \Rule{sequence reference}{
%    \Ruleref{state designator}, \Lit{(}, \Ruleref{expression}, \Lit{)}
%    }

   \Rule{map or sequence reference}{
     \Ruleref{state designator}, \Lit{(}, \Ruleref{expression}, \Lit{)}
     }
%koizumi change_end

%\ifthenelse{\boolean{VDMpp}}{%
  \Rule{multiple assign statement}{
    \Lit{atomic}, 
    \Lit{(}
      \Ruleref{assign statement}, \Lit{;}, \lfeed
      \Ruleref{assign statement},
      \lfeed
      \SeqPt{\Lit{;},\Ruleref{assign statement}}
    \Lit{)}
    }
%  }%
%{}

\item[Semantics:] The {\it assignment statement} corresponds to a
  generalisation of assignment statements from traditional high level
  programming languages. It is used to change the value of the global or
  local state. Thus, the assignment statement has side-effects on the
  state. However, in order to be able to simply change a part of the state,
  the left-hand side of the assignment can be a state designator. A state
  designator is either simply the name of a global variable, a reference to
  a field of a variable, a map reference of a variable, or a sequence
  reference of a variable. In this way it is possible to change the value
  of a small component of the state. For example, if a state component is a
  map, it is possible to change a single entry in the map.

  An assignment statement has the form:
  \begin{alltt}
    sd := ec
  \end{alltt}
  where {\tt sd} is a state designator, and {\tt ec} is either an
  expression or a call of an operation. The assignment statement denotes the
  change to the given state component described at the right-hand side
  (expression or operation call). If the right-hand side is a state
  changing operation then that operation is executed (with the
  corresponding side effect) before the assignment is made.


  Multiple assignment is also possible. This has the form:
  \begin{alltt}
    \keyw{atomic} (sd1 := ec1;
\           ...;
\           sdN := ecN
           )
  \end{alltt}
  All of the expressions or operation calls on the right hand sides are
  executed or evaluated, and then the results are bound to the
  corresponding state designators. The right-hand sides are executed
  atomically with respect to invariant evaluation. 

\item[Examples:] The operation in the previous example (\texttt{Swap}) 
  illustrated normal assignment. The operation \texttt{Win\_sd}, a 
  refinement of \texttt{Win} on page \pageref{winDef} illustrates the use of 
  state designators to assign to a specific map key:
  \begin{alltt}
  Win_sd : Team * Team ==> ()
  Win_sd (wt,lt) ==
    \keyw{let} gp \keyw{in set dom} gps \keyw{be st} 
        \{wt,lt\} \keyw{subset} \{sc.team | sc \keyw{in set} gps(gp)\}
    \keyw{in} gps(gp) := \{ \keyw{if} sc.team = wt
                   \keyw{then mu}(sc, won |-> sc.won + 1,
                               points |-> sc.points + 3)
                   \keyw{else if} sc.team = lt
                   \keyw{then mu}(sc, lost |-> sc.lost + 1)
                   \keyw{else} sc 
                 | sc \keyw{in set} gps(gp)\}
  \Keyw{pre} \keyw{exists} gp \keyw{in set dom} gps & 
                 \{wt,lt\} \keyw{subset} \{sc.team | sc \keyw{in set} gps(gp)\}
  \end{alltt}
  The operation \texttt{SelectionSort} is a state based version of the 
  function \texttt{selection\_sort} on page \pageref{selectionSortdef}. It 
  demonstrates the use of state designators to modify the contents of a 
  specific sequence index, using the 
state \texttt{St}
 defined on page~\pageref{stdef}. 
  \begin{alltt}
  \keyw{functions}
 
  min_index : \keyw{seq1 of nat} -> \keyw{nat}
  min_index(l) ==
  \keyw{if len} l = 1 \keyw{then} 1
  \keyw{else let} mi = min_index(\keyw{tl} l)
     \keyw{in if} l(mi+1) < \keyw{hd} l
       \keyw{then} mi+1
       \keyw{else} 1

  \keyw{operations}

  SelectionSort : \keyw{nat} ==> ()
  SelectionSort (i) ==
    \keyw{if} i < \keyw{len} l
    \keyw{then} (\keyw{dcl} temp: \keyw{nat};
         \keyw{dcl} mi : \keyw{nat} := min_index(l(i,...,\keyw{len} l)) + i - 1;
         temp := l(mi);
         l(mi) := l(i);
         l(i) := temp;
         SelectionSort(i+1)
        );
  \end{alltt}

\end{description}

\subsection{Conditional Statements}\label{condstmt}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{if statement} \dsep
    \Ruleref{cases statement} \dsep \ldots
    }

  \Rule{if statement}{
    \Lop{if}, \Ruleref{expression}, \Lop{then}, \Ruleref{statement}, \lfeed
    \SeqPt{\Ruleref{elseif statement}}, \OptPt{\Lop{else}, \Ruleref{statement}}
    }

  \Rule{elseif statement}{
    \Lop{elseif}, \Ruleref{expression}, \Lop{then}, \Ruleref{statement}
    }

  \Rule{cases statement}{
    \Lop{cases}, \Ruleref{expression}, \Lit{:}, \lfeed
    \Ruleref{cases statement alternatives}, \lfeed
    \OptPt{\Lit{,}, \Ruleref{others statement}}, \Lop{end}
    }

  \Rule{cases statement alternatives}{
    \Ruleref{cases statement alternative}, \lfeed
    \SeqPt{\Lit{,}, \Ruleref{cases statement alternative}}
    }

  \Rule{cases statement alternative}{
    \Ruleref{pattern list}, \Lit{->}, \Ruleref{statement}
    }

  \Rule{others statement}{
    \Lop{others}, \Lit{->}, \Ruleref{statement}
    }

\item[Semantics:] The semantics of the {\it if statement} corresponds to
  the {\it if expression} described in section~\ref{if-exp} except for the
  alternatives which are statements (and that the \keyw{else} part is
  optional)\footnote{If the \keyw{else} part is omitted
  semantically it is like using \keyw{else skip}.}.
  
  The semantics for the {\it cases statement} corresponds
  to the {\it cases expression} described in section~\ref{cases-exp} except
  for the alternatives which are statements.

\item[Examples:] Assuming functions \texttt{clear\_winner} and 
  \texttt{winner\_by\_more\_wins} and operation \texttt{RandomElement} 
  with the following signatures:
  \begin{alltt}
    clear_winner : \keyw{set of} Score -> \keyw{bool}
    winner_by_more_wins : \keyw{set of} Score -> \keyw{bool}
    RandomElement : \keyw{set of} Team ==> Team
  \end{alltt}
  then the operation \texttt{GroupWinner\_if} demonstrates the use of a 
  nested if statement (the iota expression is presented on page 
  \pageref{iotaexpr}):
  \begin{alltt}
  GroupWinner_if : GroupName ==> Team
  GroupWinner_if (gp) ==
    \keyw{if} clear_winner(gps(gp))
     -- return unique score in gps(gp) which has more points
     -- than any other score
    \keyw{then return} ((\keyw{iota} sc \keyw{in set} gps(gp) &
                   \keyw{forall} sc' \keyw{in set} gps(gp) \verb+\+ \{sc\} &
                     sc.points > sc'.points).team)
    \keyw{else if} winner_by_more_wins(gps(gp))
     -- return unique score in gps(gp) with maximal points
     -- & has won more than other scores with maximal points
    \keyw{then return} ((\keyw{iota} sc \keyw{in set} gps(gp) &
              \keyw{forall} sc' \keyw{in set} gps(gp) \verb+f+\ \{sc\} &
                (sc.points > sc'.points) \keyw{or}
                (sc.points = sc'.points \keyw{and} 
                 sc.won > sc'.won)).team)
     -- no outright winner, so choose random score 
     -- from joint top scores
    \keyw{else} RandomElement ( \{sc.team | sc \keyw{in set} gps(gp) &
                           \keyw{forall} sc' \keyw{in set} gps(gp) &
                            sc'.points <= sc.points\} );
  \end{alltt}
  Alternatively, we could use a cases statement with match value patterns for
  this operation: 
  \begin{alltt}
  GroupWinner_cases : GroupName ==> Team
  GroupWinner_cases (gp) ==
    \keyw{cases true}:
      (clear_winner(gps(gp))) -> 
           \keyw{return} ((\keyw{iota} sc \keyw{in set} gps(gp) &
                     \keyw{forall} sc' \keyw{in set} gps(gp) \verb+\+ \{sc\} &
                      sc.points > sc'.points).team),

      (winner_by_more_wins(gps(gp))) ->
           \keyw{return} ((\keyw{iota} sc \keyw{in set} gps(gp) &
                     \keyw{forall} sc' \keyw{in set} gps(gp) \verb+\+ \{sc\} &
                       (sc.points > sc'.points) \keyw{or}
                       (sc.points = sc'.points \keyw{and} 
                          sc.won > sc'.won)).team),

      \keyw{others} -> RandomElement ( \{sc.team | sc \keyw{in set} gps(gp) &
                                  \keyw{forall} sc' \keyw{in set} gps(gp) &
                                   sc'.points <= sc.points\} )
    end
  \end{alltt}

\end{description}

\subsection{For-Loop Statements}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{sequence for loop} \dsep
    \Ruleref{set for loop} \dsep
    \Ruleref{index for loop} \dsep \ldots
    }

  \Rule{sequence for loop}{
    \Lop{for}, \Ruleref{pattern bind}, \Lop{in}, 
    \OptPt{\Lop{reverse}}, \Ruleref{expression}, \lfeed
    \Lop{do}, \Ruleref{statement}
    }\index{for loop}

  \Rule{set for loop}{
    \Lop{for}, \Lop{all}, \Ruleref{pattern},
    \Lit{\keyw{in set}}, \Ruleref{expression},\lfeed
    \Lop{do}, \Ruleref{statement}
    }

  \Rule{index for loop}{
    \Lop{for}, \Ruleref{identifier}, \Lit{$=$}, \Ruleref{expression},
    \Lop{to}, \Ruleref{expression}, \lfeed
    \OptPt{\Lop{by}, \Ruleref{expression}}, \Lop{do}, \Ruleref{statement}
    }

\item[Semantics:] There are three kinds of {\it for-loop statements}. The
  for-loop using an index is known from most high-level programming
  languages. In addition, there are two for-loops for traversing sets and
  sequences. These are especially useful if access to all
  elements from a set (or sequence) is needed one by one.

  An {\it index for-loop statement} has the form:
  \begin{alltt}
    \keyw{for} id = e1 \keyw{to} e2 \keyw{by} e3 \keyw{do}
    s
  \end{alltt}
  where {\tt id} is an identifier, {\tt e1} and {\tt e2} are integer
  expressions indicating the lower and upper bounds for the loop, {\tt e3}
  is an integer expression indicating the step size, and {\tt s} is a
  statement where the identifier {\tt id} can be used. It denotes the
  evaluation of the statement {\tt s} as a sequence statement where the
  current context is extended with a binding of {\tt id}. Thus, the first
  time {\tt s} is evaluated {\tt id} is bound to the value returned from
  the evaluation of the lower bound {\tt e1} and so forth until the upper
  bound is reached ie. until \texttt{s} $>$ \texttt{e2} . Note that
  {\tt e1, e2} and {\tt e3} are evaluated before entering the loop.

  A {\it set for-loop statement\/} has the form:
  \begin{alltt}
    \keyw{for all} e \keyw{in set} S \keyw{do}
    s
  \end{alltt}
  where {\tt S} is a set expression. The statement {\tt s} is evaluated in
  the current environment extended with a binding of e to subsequent values
  from the set {\tt S}.

  A {\it sequence for-loop statement\/} has the form:
  \begin{alltt}
    \keyw{for} e \keyw{in} l \keyw{do}
    s
  \end{alltt}
  where {\tt l} is a sequence expression. The statement {\tt s} is
  evaluated in the current environment extended with a binding of e to
  subsequent values from the sequence {\tt l}. If the keyword
  \keyw{reverse} is used the elements of the sequence {\tt l} will be
  taken in reverse order.

\item[Examples:] The operation \texttt{Remove} demonstrates the use of a 
  \textit{sequence-for} loop to remove all occurences of a given number from a 
  sequence of numbers:
  \begin{alltt}\label{removeDef}
  Remove : (\keyw{seq of nat}) * \keyw{nat} ==> \keyw{seq of nat}
  Remove (k,z) ==
  (\keyw{dcl} nk : \keyw{seq of nat} := [];
   \keyw{for} elem \keyw{in} k \keyw{do}
     \keyw{if} elem <> z
     \keyw{then} nk := nk^[elem];
   \keyw{return} nk
  );
  \end{alltt}
  A \textit{set-for} loop can be exploited to return the set of winners of 
  all groups:
  \begin{alltt}
  GroupWinners: () ==> \keyw{set of} Team
  GroupWinners () ==
  (\keyw{dcl} winners : \keyw{set of} Team := \{\};
   \keyw{for all} gp \keyw{in set dom} gps \keyw{do}
     (\keyw{dcl} winner: Team := GroupWinner(gp);
      winners := winners \keyw{union} \{winner\}
     );
   \keyw{return} winners
   );
  \end{alltt}
  An example of a \textit{index-for} loop is the classic bubblesort 
  algorithm:
  \begin{alltt}
  BubbleSort : \keyw{seq of nat} ==> \keyw{seq of nat}
  BubbleSort (k) ==
    (\keyw{dcl} sorted_list : \keyw{seq of nat} := k;
     \keyw{for} i = \keyw{len} k \keyw{to} 1 \keyw{by} -1 \keyw{do}
       \keyw{for} j = 1 to i-1 \keyw{do}
         \keyw{if} sorted_list(j) > sorted_list(j+1)
         \keyw{then} (\keyw{dcl} temp:\keyw{nat} := sorted_list(j);
               sorted_list(j) := sorted_list(j+1);
               sorted_list(j+1) := temp
              );
     \keyw{return} sorted_list
     )
\end{alltt}
\end{description}

\subsection{The While-Loop Statement}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{while loop} \dsep \ldots
    }
  
  \Rule{while loop}{
    \Lop{while}, \Ruleref{expression}, \Lop{do}, \Ruleref{statement}
    }

\item[Semantics:] The semantics for the {\it while statement} corresponds
  to the while statement from traditional programming languages. The form
  of a {\it while loop\/} is:
  \begin{alltt}
    \keyw{while} e \keyw{do}
      s
  \end{alltt}
  where {\tt e} is a boolean expression and {\tt s} a statement. As long as
  the expression {\tt e} evaluates to \keyw{true} the body statement {\tt
    s} is evaluated.

\item[Examples:] The {\it while loop} can be illustrated by the following
  example which uses Newton's method to approximate the square root of
  a real number \texttt{r} within relative error \texttt{e}.
  \begin{alltt}\label{squarerootDef}
  SquareRoot : \keyw{real} * \keyw{real} ==> \keyw{real}
  SquareRoot (r,e) ==
    (\keyw{dcl} x:\keyw{real} := 1,
        nextx:\keyw{real} := r;
     \keyw{while} \keyw{abs} (x - nextx) >= e * x \keyw{do}
       ( x := nextx;
         nextx := ((r / x) + x) / 2;
       );
     \keyw{return} nextx
    );
  \end{alltt}
\end{description}

\subsection{The Nondeterministic Statement}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{nondeterministic statement} \dsep \ldots
    }
  
  \Rule{nondeterministic statement}{
    \Lit{||}, \Lit{(}, \Ruleref{statement},\lfeed
    \SeqPt{\Lit{,}, \Ruleref{statement}}, \Lit{)}
    }

\item[Semantics:] The {\it nondeterministic statement} has the form:
  \begin{alltt}
    || (stmt1, stmt2, \ldots, stmtn)
  \end{alltt}
  and it represents the execution of the component statements {\tt
    stmti} in an arbitrary (non-deterministic)
  order. However, it
  should be noted that the component statements are not executed
  simultaneously. Notice that the interpreter will use an
  underdetermined\footnote{Even though the
    user of the interpreter does not know
    the order in which these statements are executed they are always
    executed in the same order unless the seed option is used.} semantics even though this construct
  is called a non-deterministic statement.

\item[Examples:] Using the 
state definition
  \begin{alltt}
  \keyw{state} St \keyw{of}
    x:\keyw{nat}
    y:\keyw{nat}
    l:\keyw{seq1 of nat}
  \keyw{end}
  \end{alltt}
  we can use the non-deterministic statement to effect a bubble sort:
  \begin{alltt}\label{sortDef}
  Sort: () ==> ()
  Sort () ==
    \keyw{while} x < y \keyw{do}
      ||(BubbleMin(), BubbleMax());
  \end{alltt}
  Here \texttt{BubbleMin} ``bubbles'' the minimum value in the
  subsequence \texttt{l(x,...,y)} to the head of the subsequence and
  \texttt{BubbleMax} ``bubbles'' the maximum value in the subsequence
  \texttt{l(x,...,y)} to the last index in the
  subsequence. \texttt{BubbleMin} works by first iterating through the
  subsequence to find the index of the minimum value. The contents of
  this index are then swapped with the contents of the head of the
  list, \texttt{l(x)}.
  \begin{alltt}
  BubbleMin : () ==> ()
  BubbleMin () ==
    (\keyw{dcl} z:\keyw{nat} := x;
     \keyw{dcl} m:\keyw{nat} := l(z);
     -- find min val in l(x..y)
     \keyw{for} i = x \keyw{to} y \keyw{do}
       \keyw{if} l(i) < m
       \keyw{then} ( m := l(i);
              z := i);
     -- move min val to index x
     (\keyw{dcl} temp:\keyw{nat};
      temp := l(x);
      l(x) := l(z);
      l(z) := temp;
      x := x+1));
\end{alltt}
\texttt{BubbleMax} operates in a similar fashion. It iterates through the
  subsequence to find the index of the maximum value, then swaps the
  contents of this index with the contents of the last element of the
  subsequence. 
\begin{alltt}
  BubbleMax : () ==> ()
  BubbleMax () ==
    (\keyw{dcl} z:\keyw{nat} := x;
     \keyw{dcl} m:\keyw{nat} := l(z);
     -- find max val in l(x..y)
     \keyw{for} i = x \keyw{to} y \keyw{do}
       \keyw{if} l(i) > m
       \keyw{then} ( m := l(i);
              z := i);
     -- move max val to index y
     (\keyw{dcl} temp:\keyw{nat};
      temp := l(y);
      l(y) := l(z);
      l(z) := temp;
      y := y-1));
  \end{alltt}
\end{description}

\subsection{The Call Statement}
\label{call-stmt}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{call statement} \dsep \ldots
    }
  \Rule{call statement}{
    \Ruleref{name}, \Lit{(}, \OptPt{\Ruleref{expression list}}, \Lit{)}
    }

\item[Semantics:] The {\it call statement} has the form:
  \begin{alltt}
    opname(param1, param2, \ldots, paramn)
  \end{alltt}


  The {\it call statement} calls an operation, {\tt opname}, %
and returns the result of
  evaluating the operation. Because operations can manipulate global
  variables a {\it call statement} does not necessarily have to return
  a value as function calls do.


\item[Examples:] \mbox{} 
  The operation {\tt ResetStack} given below does not
  have any parameter and does not return a value whereas the operation {\tt
    PopStack} returns the top element of the stack.
  \begin{alltt}
    ResetStack();
    ...
    top := PopStack();
  \end{alltt}
  where {\tt PopStack} could be defined as:
  \begin{alltt}
    PopStack: () ==> Elem
    PopStack() ==
      def res = hd stack in
       (stack := tl stack;
        return res)
    pre stack <> []
    post stack~ = [RESULT] ^ stack
  \end{alltt}
  where {\tt stack} is a global variable.

\end{description}

\subsection{The Return Statement}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{return statement} \dsep \ldots
    }

  \Rule{return statement}{
    \Lop{return}, \OptPt{\Ruleref{expression}}
    }

\item[Semantics:] The {\it return statement} returns the value of an
  expression inside an operation. The value is evaluated in the given
  context. If an operation does not return a value, the expression must be
  omitted. A {\it return statement\/} has the form:
  \begin{alltt}
    return e
  \end{alltt}
  or
  \begin{alltt}
    return
  \end{alltt}
  where expression {\tt e} is the return value of the operation.

\item[Examples:] In the following example {\tt OpCall} is an operation call
  whereas {\tt FunCall} is a function call. As the {\it if statement\/}
  only accepts statements in the two branches {\tt FunCall} is
  ``converted'' to a statement by using the {\it return statement}.
  \begin{alltt}
    \keyw{if} test
    \Keyw{then} OpCall()
    \Keyw{else} \keyw{return} FunCall()
  \end{alltt}

\end{description}

\subsection{Exception Handling Statements}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{always statement} \dsep
    \Ruleref{trap statement} \dsep
    \Ruleref{recursive trap statement} \dsep
    \Ruleref{exit statement} \dsep \ldots
    }

  \Rule{always statement}{
    \Lop{always}, \Ruleref{statement}, \Lop{in}, \Ruleref{statement}
    }

  \Rule{trap statement}{
    \Lop{trap}, \Ruleref{pattern bind}, \Lop{with},
    \Ruleref{statement}, \Lop{in}, \lfeed
    \Ruleref{statement}
    }

  \Rule{recursive trap statement}{
    \Lop{tixe}, \Ruleref{traps}, \Lop{in}, \Ruleref{statement}
    }

  \Rule{traps}{
    \Lit{\{}, \Ruleref{pattern bind}, \Lit{|->}, \Ruleref{statement}, \lfeed
    \SeqPt{ \Lit{,}, \Ruleref{pattern bind}, \Lit{|->}, \Ruleref{statement} },
    \Lit{\}}
    }

  \Rule{exit statement}{
    \Lop{exit}, \OptPt{\Ruleref{expression}}
    }

\item[Semantics:] The exception handling statements are used to control
  exception errors in a specification. This means that we have to be
  able to signal an exception within a specification. This can be done with
  the {\it exit statement}, and has the form:
  \begin{alltt}
    \keyw{exit} e
  \end{alltt}
  or
  \begin{alltt}
    \keyw{exit}
  \end{alltt}
  where {\tt e} is an expression which is optional. The expression {\tt e}
  can be used to signal what kind of exception is raised.

  The {\it always statement\/} has the form:
  \begin{alltt}
    \keyw{always} s1 \keyw{in}
    s2
  \end{alltt}
  where {\tt s1} and {\tt s2} are statements. First statement {\tt s2} is
  evaluated, and regardless of any exceptions raised, statement {\tt s1} is
  also evaluated. The result value of the complete {\it always statement\/}
  is determined by the evaluation of statement {\tt s1}: if this raises an
  exception, this value is returned, otherwise the result of the evaluation
  of statement {\tt s2} is returned.

  The {\it trap statement\/} only evaluates the handler statement,
{\tt s1}, when certain conditions are fulfilled. It has the form:
\begin{alltt} 
    \keyw{trap} pat \keyw{with} s1 \keyw{in} s2 
\end{alltt}
where {\tt pat} is a pattern or bind used to select certain
exceptions, {\tt s1} and {\tt s2} are statements. First, we evaluate
statement {\tt s2}, and if no exception is raised, the result value of
the complete {\it trap statement\/} is the result of the evaluation of
{\tt s2}. If an exception is raised, the value of {\tt s2} is matched
against the pattern {\tt pat}. If there is no matching, the exception
is returned as result of the complete {\it trap statement}, otherwise,
statement {\tt s1} is evaluated and the result of this evaluation is
also the result of the complete {\it trap statement}.

  The {\it recursive trap statement\/} has the form:
  \begin{alltt}
    \keyw{tixe} \{
      pat1 |-> s1,
      ...
      patn |-> sn
    \} \keyw{in} s
  \end{alltt}
  where {\tt pat1, \ldots, patn} are patterns or binds, {\tt s, s1, \ldots,
    sn} are statements. First, statement {\tt s} is evaluated, and if no
  exception is raised, the result is returned as the result of the complete
  {\it recursive trap statement}. Otherwise, the value is matched in order
  against each of the patterns {\tt pati}. When a match cannot be found,
  the exception is returned as the result of the {\it recursive trap
    statement}. If a match is found, the corresponding statement {\tt
    si} is evaluated. If this does not raise an exception, the result value
  of the evaluation of {\tt si} is returned as the result of the {\it
    recursive trap statement}. Otherwise, the matching starts again, now
  with the new exception value (the result of the evaluation of {\tt si}).

\item[Examples:] In many programs, we need to allocate memory for a
  single operation. After the operation is completed, the memory is not
  needed anymore. This can be done with the {\it always statement}:
  \begin{alltt}
    ( \keyw{dcl} mem : Memory;
      \keyw{always} Free(mem) \keyw{in}
      ( mem := Allocate();
        Command(mem, \ldots)
      )
    )
  \end{alltt}
  In the above example, we cannot act upon a possible exception raised
  within the body statement of the {\it always statement}. By using the
  {\it trap statement\/} we can catch these exceptions:
  \begin{alltt}
    \keyw{trap} pat \keyw{with} ErrorAction(pat) \keyw{in}
    ( \keyw{dcl} mem : Memory;
      \keyw{always} Free(mem) \keyw{in}
      ( mem := Allocate();
        Command(mem, \ldots)
      )
    )
  \end{alltt}
  Now all exceptions raised within the {\it always statement\/} are
  captured by the {\it trap statement}. If we want to distinguish between
  several exception values, we can use either nested {\it trap
    statements\/} or the {\it recursive trap statement}:
  \begin{alltt}
    DoCommand : () ==> int
    DoCommand () ==
    ( \keyw{dcl} mem : Memory;
      \keyw{always} Free(mem) \keyw{in}
      ( mem := Allocate();
        Command(mem, \ldots)
      )
    );

    Example : () ==> int
    Example () ==
    \keyw{tixe}
    \{ <NOMEM> |-> \keyw{return} -1,
      <BUSY>  |-> DoCommand(),
      err     |-> \keyw{return} -2 \}
    \keyw{in}
      DoCommand()
  \end{alltt}
  In operation {\tt DoCommand} we use the {\it always statement\/} in the
  allocation of memory, and all exceptions raised are captured by the {\it
    recursive trap statement\/} in operation {\tt Example}. An exception
  with value {\tt <NOMEM>} results in a return value of {\tt -1} and no
  exception raised. If the value of the exception is {\tt <BUSY>} we try to
  perform the operation {\tt DoCommand} again. If this raises an exception,
  this is also handled by the {\it recursive trap statement}. All other
  exceptions result in the return of the value {\tt -2}.  
\end{description}

\subsection{The Error Statement}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{error statement} \dsep
    \ldots
    }

  \Rule{error statement}{
    \Lop{error}
    }

\item[Semantics:] The {\it error statement} corresponds to the
undefined expression. It is used to state explicitly that the result
of a statement is undefined and because of this an error has occurred.
When an {\it error statement} is evaluated the
interpreter will
terminate the execution of the specification and report that an {\it
error statement} was evaluated.

  Pragmatically use of error statements differs from
  pre-conditions as was the case with undefined expressions: use of a
  pre-condition means it is the caller's 
  responsibility to ensure that the pre-condition is satisfied when
  the operation is called; if an error statement is used it is the
  called operation's responsibility to deal with error handling.


\item[Examples:] The operation \texttt{SquareRoot} on page
  \pageref{squarerootDef} does not exclude
  the possibility that the number to be square rooted might be
  negative. We remedy this in the operation \texttt{SquareRootErr}:
  \begin{alltt}
  SquareRootErr : \keyw{real} * \keyw{real} ==> \keyw{real}
  SquareRootErr (r,e) ==
    \keyw{if} r < 0
    \keyw{then error}
    \keyw{else}
      (\keyw{dcl} x:\keyw{real} := 1;
       \keyw{dcl} nextx\keyw:{real} := r;
       \keyw{while abs} (x - nextx) >= e * x \keyw{do}
         ( x := nextx;
           nextx := ((r / x) + x) / 2;
         );
       \keyw{return} nextx
      )
  \end{alltt}
\end{description}

\subsection{The Identity Statement}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{identity statement}
    }

  \Rule{identity statement}{
    \Lop{skip}
    }

\item[Semantics:] The {\it identity statement\/} is used to signal that no
  evaluation takes place.

\item[Examples:] In the operation \texttt{Remove} in section
  \ref{removeDef} the behaviour of the operation within the
  \textsf{for} loop if \texttt{elem=z} is not explicitly
  stated. \texttt{Remove2} below does this.
  \begin{alltt}
  Remove2 : (\keyw{seq of nat}) * \keyw{nat} ==> \keyw{seq of nat}
  Remove2 (k,z) ==
    (\keyw{dcl} nk : \keyw{seq of nat} := [];
     \keyw{for} elem \keyw{in} k \keyw{do}
       \keyw{if} elem <> z \keyw{then} nk := nk^[elem]
       \keyw{else skip};
     \keyw{return} nk
    );
  \end{alltt}
  Here, we explicitly included the \keyw{else}-branch to illustrate the
  {\it identity statement}, however, in most cases the \keyw{else}-branch
  will not be included and the {\it identity statement\/} is implicitly
  assumed.

\end{description}


\subsection{The Specification Statement} \label{se:specification}

\begin{description}
\item[Syntax:] 
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{specification statement}
    }
  \Rule{specification statement}{
    \Lit{[}, \Ruleref{implicit operation body}, \Lit{]}
  }

\item[Semantics:] 

The specification statement can be used to describe a desired effect a
statement in terms of a pre- and a post-condition. Thus, it captures
the abstraction of a statement, permitting it to have an abstract
(implicit) specification without being forced to an operation
definition. The specification statement is equivalent with the body of
an implicitly defined operation (see section~\ref{op-def}). Thus
specification statements can not be executed.

\item[Examples:] We can use a specification statement to specify a
  bubble maximum part of a bubble sort:
  \begin{alltt}
  Sort2 : () ==> ()
  Sort2 () ==
    \keyw{while} x < y \keyw{do}
      || (BubbleMin(),
          [\keyw{ext wr} l : \keyw{seq1 of nat}
              \keyw{wr} y : \keyw{nat}
              \keyw{rd} x : \keyw{nat}
           \keyw{pre} x < y
           \keyw{post} y < y~ \keyw{and}
                permutation (l~(x,...,y~),l(x,...,y~)) \keyw{and}
                \keyw{forall} i \keyw{in set} \{x,...,y\} & l(i) < l(y~)]
         )
  \end{alltt}
  (\texttt{permutation} is an auxiliary function taking two sequences
  which returns true iff one sequence is a permutation of the other.)


\end{description}


\newpage
\section{Top-level Specification}
\label{top-level}\label{modules}

In the previous sections all the  VDM-SL constructs such as types,
expressions, statements, functions and operations have been described. A
number of these constructs can constitute a top-level  VDM-SL
specification. A top-level specification can be created in two ways:
\begin{enumerate}
\item The specification is split into a number of modules which are
  specified separately, but can depend on each other.
\item The specification is specified in a flat manner, i.e.\ no modules are
  used.
\end{enumerate}
Thus, a complete specification, or document, has the following syntax.

\begin{description}
\item[Syntax:]
\Rule{document}{
  \Ruleref{any module}, \SeqPt{\Ruleref{any module}} \dsep
   \Ruleref{definition block}, \SeqPt{\Ruleref{definition block}}
  }

\Rule{any module}{
  \Ruleref{module} \dsep
  \Ruleref{dynamic link module}
  }
\end{description}

\subsection{A Flat Specification}\label{flat}

As said, a flat specification does not use modules. This means that all
constructs can be used throughout the specification. In the flat case, a
document has a syntax of:

\Rule{document}{\ldots \dsep
  \Ruleref{definition block}, \SeqPt{\Ruleref{definition block}}
  }

\Rule{definition block}{
  \Ruleref{type definitions} \dsep
  \Ruleref{state definition} \dsep
  \Ruleref{value definitions} \dsep
  \Ruleref{function definitions} \dsep
  \Ruleref{operation definitions}
  }

Thus, a flat specification is made up of several {\it definition\/} blocks.
However, only one state definition is allowed. The following is an example
of a flat top-level specification:

\begin{alltt}
  \keyw{values}

    st1 = \keyw{mk\_}St([3,2,-9,11,5,3])

  \keyw{state} St \keyw{of}
    l:\keyw{seq1 of nat}
  \keyw{end}

  \keyw{functions}

  min_index : \keyw{seq1 of nat} -> \keyw{nat}
  min_index(l) ==
    \keyw{if} \keyw{len} l = 1
    \keyw{then} 1
    \keyw{else} \keyw{let} mi = min_index(\keyw{tl} l)
        \keyw{in} \keyw{if} l(mi+1) < \keyw{hd} l
          \keyw{then} mi+1
          \keyw{else} 1

  \keyw{operations}

  SelectionSort : \keyw{nat} ==> ()
  SelectionSort (i) ==
    if i < len l
    then (\keyw{dcl} temp: \keyw{nat};
          \keyw{dcl} mi : \keyw{nat} := min_index(l(i,...,\keyw{len} l)) + i - 1;
         
          temp := l(mi);
          l(mi) := l(i);
          l(i) := temp;
          SelectionSort(i+1)
         )
\end{alltt}





\subsection{A Structured Specification}

As an extension to the standard VDM-SL language, it is possible to
structure an  VDM-SL specification using modules. In this section,
the use of modules to create the top-level specification will be described.
With the structuring facilities offered by  VDM-SL it is possible to:
\begin{itemize}
\item Export constructs from a module.
\item Import constructs from a module.
\item Rename constructs upon import.
\item Define a state in a module.
\end{itemize}

In addition to these kinds of ordinary modules it is possible to use
so-called ``Dynamic Link Modules'' (see section~\ref{sec:DLmodules}).

\subsubsection{The Layout of a Module}

Before the actual facilities are described, the general layout of a
module is described. A module consists of three parts: a {\it module
declaration}, an {\it interface section}, and a {\it definitions
section}. It is possible to leave out the definitions part in the
early development of a module specification.

In the module declaration, the module is named. The name must be a
unique module name within the complete specification. The second
part, the interface section, defines the relation of a module with other
modules and consists of a number of sections. These sections are:
\begin{itemize}

\item An {\it imports section}. In the imports section, all the
  constructs that are going to be used from other modules are
  described. If constructs are going to be renamed it has to be done
  in the imports section. 

\item An {\it exports section}. Here all the constructs that are going
  to be used in other modules are defined.
  If no exports section is present the
  module cannot be used from other modules.
\end{itemize}
The third part of a module declaration, the
definitions section, contains all the definitions of the module.
Thus, in general, the syntax of a module is:


\begin{description}
\item[Syntax:]
\Rule{module}{
  \Lop{module}, \Ruleref{identifier}, \Ruleref{interface}, \lfeed
  \OptPt{\Ruleref{module body}}, \Lop{end}, \Ruleref{identifier}
  }

  \Rule{module body}{
    \Lop{definitions}, \Ruleref{definition block}, \SeqPt{definition block}
  }
\end{description}

To illustrate the use of modules, the example flat top-level
specification are rewritten with some minor modifications.  Some
unimportant parts of the flat specification are left out for clarity.

\subsubsection{The Exports Section}

\begin{description}
\item[Syntax:]
  \Rule{interface}{
    \OptPt{\Ruleref{import definition list}}, \lfeed
    \Ruleref{export definition}
    }

  \Rule{export definition}{
    \Lop{exports}, \Ruleref{export module signature}
    }

  \Rule{export module signature}{
    \Lop{all} \dsep
    \Ruleref{export signature}, \lfeed
    \SeqPt{\Ruleref{export signature}}
    }
  
  \Rule{export signature}{
    \Ruleref{export types signature} \dsep
    \Ruleref{values signature} \dsep
    \Ruleref{export functions signature} \dsep
    \Ruleref{operations signature}
%    \dsep
%    state signature
    }
  
  \Rule{export types signature}{
    \Lop{types}, \Ruleref{type export}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{type export}}, \OptPt{\Lit{;}}
    }
  
  \Rule{type export}{
    \OptPt{\Lop{struct}}, \Ruleref{name}
    }
  
  \Rule{values signature}{
    \Lop{values}, \Ruleref{value signature}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{value signature}}, \OptPt{\Lit{;}}
    }
  
  \Rule{value signature}{
    \Ruleref{name list}, \Lit{:}, \Ruleref{type}
    }
  
  \Rule{export functions signature}{
    \Lop{functions} \Ruleref{function export}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{function export}}
    }

  \Rule{function export}{
    \Ruleref{name list}, \OptPt{\Ruleref{type variable list}}, \Lit{:}, \lfeed
    \Ruleref{function type}
    }
  
  \Rule{functions signature}{
    \Lop{functions} \Ruleref{function signature}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{function signature}}, \OptPt{\Lit{;}}
    }
  
  \Rule{function signature}{
    \Ruleref{name list}, \Lit{:}, \Ruleref{function type}
    }
  
  \Rule{operations signature}{
    \Lop{operations} \Ruleref{operation signature}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{operation signature}}, \OptPt{\Lit{;}}
    }
  
  \Rule{operation signature}{
    \Ruleref{name list}, \Lit{:}, \Ruleref{operation type}
    }
  
%  \Rule{state signature}{
%    \Lop{state}, name, \SeqPt{\Lit{,}, name}
%    }

\item[Semantics:] The exports section must be used to make constructs
  visible to other modules. Some or all of the defined
  constructs from a module can be exported. In the latter case, the keyword
  \keyw{all} is used. However, imported constructs are not exported
  from the module. If only part 
  of the constructs are exported, the visible constructs with
  the appropriate signatures are stated.

  Normally, if a construct is visible to another module,
  that construct can be considered
   to be defined inside the module. However, with types and
  operations there are some exceptions:
  \begin{description}
  \item[Types:] If a type {\tt T} is defined in module {\tt A} and
    this type is also going to be used in module {\tt B}, the type
    from module {\tt A} has to be exported. This can be done in two ways:
    \begin{enumerate}
    \item The name of the type is exported.
    \item The structure of the type is exported.
    \end{enumerate}
    If only the name of the type is exported, the other module cannot create
    values of type {\tt T}. This means that the exporting module ({\tt A})
    must provide functions and/or operations to directly create and manipulate
    values of type {\tt T} by means of the constructors related to the
    representation of {\tt T}. 

    If we export the structure of the type by using the keyword
    \keyw{struct}, the other module can create and manipulate values of
    type {\tt T} (it can also use \keyw{mk\_} keyword and the
    \keyw{is\_} keyword for this type if it is a record type).

    If the type also defines an invariant, the invariant predicate function
    is only exported if the structure of the type is exported.

  \item[Operations:] In a module, a state that is global for
    the module can be defined. All operations within the module can
    manipulate that state. If operations are exported from a module, they
     manipulate the state in the exporting module,
      i.e.\ the state in the module where they are defined.
  \end{description}

  If an exported function or an operation defines a pre- and/or
  post-condition, the corresponding predicate functions (see
  section~\ref{functiondef}) are also exported.

\item[Examples:] Consider a model of a bank account. An account is
characterised by the name of the holder, the account number, the
bank branch at which the account is maintained, the balance, and an
encrypted PIN code for the ATM card. We might model this as follows:
\begin{alltt}
\keyw{module} BankAccount

  \keyw{exports} \keyw{types} digit; account
          \keyw{functions} digval: digit -> \keyw{nat};
                  withdrawal: account * \keyw{real} -> account;
                  isPin: account * \keyw{nat} -> \keyw{bool};
                  requestWithdrawal: account * \keyw{nat} -> \keyw{bool}
  \keyw{definitions}

  \keyw{types}

  digit = \keyw{nat}
  \keyw{inv} d == d < 10;
  
  account::  holder : \keyw{seq1 of char}
             number : \keyw{seq1 of digit}
             branchcode : \keyw{seq1 of digit}
             balance: \keyw{real}
             epin: \keyw{nat}
  \keyw{inv mk\_}account(holder, number, branchcode,-,-) ==
    \keyw{len} number = 8 and \keyw{len} branchcode = 6

  \keyw{functions}

    digval : digit -> \keyw{nat}
    digval(d) == d;

    deposit: account * \keyw{real} -> account
    deposit(acc,r) == 
      \keyw{mu}(acc,balance |-> acc.balance + r);

    withdrawal : account * \keyw{real} -> account
    withdrawal (acc,r) == 
      \keyw{mu}(acc,balance |-> acc.balance - r);

    isPin : account * \keyw{nat} -> \keyw{bool}
    isPin(acc,ep) ==
      ep = acc.epin;

    requestWithdrawal : account * \keyw{nat} -> \keyw{bool}
    requestWithdrawal (acc,amt) ==
      acc.balance > amt

\keyw{end} BankAccount
\end{alltt}
In this module we export two types and five functions. Note that since
we have enumerated the entities we are exporting, but have not
exported \texttt{digit} or \texttt{account} using the \keyw{struct}
keyword, the internals of \texttt{account} values may not be accessed
by other modules, neither may the invariant for \texttt{digit}. If 
such access is necessary, the types should be exported with the
\keyw{struct} keyword, or all constructs in the module should be
exported using the \keyw{exports all} clause.

The module \texttt{Keypad} given below models the keypad interface of
an ATM machine. The state variable maintains a buffer of data typed at
the keypad by the user.

\begin{alltt}
\keyw{module} Keypad

  \keyw{imports}
    \keyw{from} BankAccount \keyw{types} digit

  \keyw{exports all}

  \keyw{definitions}

  \keyw{state} buffer \keyw{of}
    data : \keyw{seq of} BankAccount`digit
  \keyw{end}

  \keyw{operations}

    DataAvailable : () ==> \keyw{bool}
    DataAvailable () ==
      \keyw{return}(data <> []);

    ReadData : () ==> \keyw{seq of} BankAccount`digit
    ReadData () ==
      \keyw{return}(data);

    WriteData : \keyw{seq of} BankAccount`digit ==> ()
    WriteData (d) ==
      data := data^d

\keyw{end} Keypad
\end{alltt}
In this module all constructs are exported. Since the only entities
defined are the state and operations on it, this means that all of the
operations may be accessed by an importing module. The state is not
accessible to importing modules, but remains private to this
module. However the state constructor
\texttt{\keyw{mk\_}Keypad`buffer} is accessible.


\end{description}

\subsubsection{The Imports Section}

\begin{description}
\item[Syntax:]
  \Rule{interface}{
    \OptPt{\Ruleref{import definition list}}, \lfeed
    \Ruleref{export definition}
    }

  \Rule{import definition list}{
    \Lop{imports}, \Ruleref{import definition}, \lfeed
    \SeqPt{\Lit{,}, \Ruleref{import definition}}
    }

  \Rule{import definition}{
    \Lop{from}, \Ruleref{identifier}, \Ruleref{import module signature}
    }

  \Rule{import module signature}{
    \Lop{all} \dsep
    \Ruleref{import signature}, \lfeed
    \SeqPt{\Ruleref{import signature}}
    }

  \Rule{import signature}{
    \Ruleref{import types signature} \dsep
    \Ruleref{import values signature} \dsep
    \Ruleref{import functions signature} \dsep
    \Ruleref{import operations signature}
%    \dsep
%    state signature
    }

  \Rule{import types signature}{
    \Lop{types}, \Ruleref{type import}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{type import}}, \OptPt{\Lit{;}}
    }

  \Rule{type import}{
    \Ruleref{name}, \OptPt{\Lop{renamed}, \Ruleref{name}} \dsep
    \Ruleref{type definition}, \OptPt{\Lop{renamed}, \Ruleref{name}}
    }

  \Rule{import values signature}{
    \Lop{values}, \Ruleref{value import}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{value import}}, \OptPt{\Lit{;}}
    }

  \Rule{value import}{
    \Ruleref{name}, \OptPt{\Lit{:}, \Ruleref{type}}, \OptPt{\Lop{renamed}, \Ruleref{name}}
    }

  \Rule{import functions signature}{
    \Lop{functions}, \Ruleref{function import}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{function import}}, \OptPt{\Lit{;}}
    }

  \Rule{function import}{
    \Ruleref{name}, \OptPt{\OptPt{\Ruleref{type variable list}},  \lfeed
    \Lit{:}, \Ruleref{function type}},
    \OptPt{\Lop{renamed}, \Ruleref{name}}
    }

  \Rule{import operations signature}{
    \Lop{operations}, \Ruleref{operation import}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{operation import}}, \OptPt{\Lit{;}}
    }

  \Rule{operation import}{
    \Ruleref{name}, \OptPt{\Lit{:}, \Ruleref{operation type}}, \lfeed
    \OptPt{\Lop{renamed}, \Ruleref{name}}
    }

\item[Semantics:] The imports section is used to state what constructs are
  used from other modules with the restriction that only visible constructs
  can be imported. If all the visible constructs from a
  module are going to be used, the keyword \keyw{all} is used, unless one or
  more constructs are going to be renamed. With renaming, an imported
  construct is given a new name
  which can be used instead of the original name preceded by the
  exporting module name. In general this has the form:
  \begin{alltt}
    name \keyw{renamed} new_name
  \end{alltt}
  where {\tt name} is the name of the imported construct, and {\tt
    new\_name} is the new name for the construct. This way,
  more meaningful names can be given to constructs. Note that in the importing
  module it is not possible to refer to {\tt DefModule`name} (where
  {\tt DefModule} is the name of the defining module) any longer but only to
  {\tt newname}.

  It is possible to include type information in the imports section,
such that
  this information will only be used by the static semantics check of the
  complete module. If no type information is given, the static semantics
  can also find this information in the exporting module (see
  section~\ref{static}).
  
  When a type which has been exported with the \keyw{struct} keyword
  (with its structure) is imported the
  importing module may only make use of this structure if it repeats
  the type definition from the exporting module in its type import. In
  case such a type is a composite type and it is also renamed this has
  the consequence that the tag is renamed as well.
  
\item[Examples:] We can model an ATM card as consisting of a
card number and an expiry date. This requires the \texttt{digit} type
defined in the module \texttt{BankAccount}. It also uses the function
\texttt{digval} from the same module.
\begin{alltt}
\keyw{module} ATMCard

  \keyw{imports}
    \keyw{from} BankAccount \keyw{types} digit 
                     \keyw{functions} digval \keyw{renamed} atmc_digval

  \keyw{exports all}

  \keyw{definitions}

  \keyw{types}

    digit = BankAccount`digit;

    atmc:: cardnumber : \keyw{seq1 of} digit
           expiry : digit * digit * digit * digit
    \keyw{inv mk\_}atmc(cardnumber, \keyw{mk\_}(m1,m2,-,-)) ==
        atmc_digval(m1) * 10 + atmc_digval(m2) <= 12 \keyw{and}
        \keyw{len} cardnumber >= 8

  \keyw{functions}

    getCardnumber : atmc -> \keyw{seq1 of} digit
    getCardnumber (atmc) ==
      atmc.cardnumber

\keyw{end} ATMCard
\end{alltt}
Here the invariant on the type \texttt{atmc} states that expiry dates
must represent valid dates, and card numbers must be at least 8 digits
long. Note that since \texttt{digit} is not exported with the
\keyw{struct} keyword from the module \texttt{BankAccount}, we cannot
access the invariant for \texttt{digit} in module
\texttt{ATMCard}. However this notwithstanding, all values of type
\texttt{digit} manipulated in \texttt{ATMCard} must satisfy the
invariant. 

\end{description}

\section{Dynamic Link Modules}\label{sec:DLmodules}

Dynamic Link modules are used to describe the interface between
modules which are fully specified in VDM-SL and parts of the overall
system which are only available as C++ code. This facility enables
users to make use of existing C++ libraries while a specification is
being interpreted/debugged. The usage of this facility
is described in detail in \cite{DLMan-SCSK}. The general layout of a Dynamic Link
module is similar to an ordinary VDM-SL module. It has three parts: a
\emph{module declaration}, an \emph{interface section}, and an
optional \emph{library reference}. 

\begin{description}
\item[Syntax:]
  
The module declaration of a Dynamic Link module is simply the keywords
\keyw{dlmodule} followed by the name of the module. The interface
section of a Dynamic Link module is simpler than the interface section
for an ordinary module. The only kind of constructs which
can be imported into a Dynamic Link module are types. Such imported types can
be used in the signature of the values, functions and/or operations
which are exported from the module. Finally the library reference
(identified by the \Lop{uselib} keyword) is
used to identify the dynamically linked C++ library which must be
used by the interpreter in case a specification
which makes use of code from such a library is going to be interpreted.

The syntax for Dynamic Link modules is:
 
\Rule{dynamic link module}{
  \Lop{dlmodule}, \Ruleref{identifier}, \lfeed
  \Ruleref{dynamic link interface},\lfeed
  \OptPt{\Ruleref{use signature}},\lfeed
  \Lop{end}, \Ruleref{identifier}
  }

\Rule{dynamic link interface}{
  \OptPt{\Ruleref{dynamic link import definition list}}, \lfeed
  \Ruleref{dynamic link export definition}
  }

\Rule{use signature}{
   \Lop{uselib}, \Ruleref{text literal}
   }

\Rule{dynamic link import definition list}{
  \Lop{imports}, \lfeed
  \Ruleref{dynamic link import definition}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{dynamic link import definition}}
  }

\Rule{dynamic link import definition}{
  \Lop{from}, \Ruleref{identifier}, \lfeed
  \Ruleref{dynamic link import types signatures}
  }

\Rule{dynamic link import types signatures}{
  \Lop{types}, \Ruleref{name}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{name}}, \OptPt{\Lit{;}}
  }
  
\Rule{dynamic link export definition}{
  \Lop{exports}, \lfeed
  \Ruleref{dynamic link export signature}, \lfeed
  \SeqPt{\Ruleref{dynamic link export signature}}
  }

\Rule{dynamic link export signature}{
  \Ruleref{values signature} \dsep
  \Ruleref{functions signature} \dsep
  \Ruleref{operations signature}
  }
  
\item[Semantics:] The semantics of the interface constructs is
     identical to the semantics of these parts for ordinary
     modules. The semantics of the use signature is given by the C++
     compiler which has been used to create the dynamically linked C++
     libraries. Thus, the C++ code referred to in the use signature is
     not provided with semantics directly at the VDM-SL level.
\item[Example:] The example presented here is used in
\cite{DLMan-SCSK}. The first module imports constructs from a {\tt MATH}
module and a {\tt CYLIO} module. Both of these other modules are
presented afterwards and both of them are Dynamic Link modules.

\begin{alltt}
\keyw{module} CYLINDER
  \keyw{imports}
    \keyw{from} MATH
        \keyw{functions}
          ExtSin : \keyw{real} -> \keyw{real}
        \keyw{values} 
          ExtPI : \keyw{real},

    \keyw{from} CYLIO
        \keyw{functions}
          ExtGetCylinder : () -> CircCyl
   
        \keyw{operations}
          ExtShowCircCylVol : CircCyl * \keyw{real} ==> ()

   \keyw{exports}
     \keyw{types}  
         CircCyl  

  \keyw{definitions}
    \keyw{types}
        CircCyl :: rad    : \keyw{real}
                   height : \keyw{real}
                   slope  : \keyw{real}

    \keyw{functions}
        CircCylVol : CircCyl -> \keyw{real}
        CircCylVol(cyl) ==
          MATH`ExtPI * cyl.rad * cyl.rad * cyl.height * 
          MATH`ExtSin(cyl.slope)

    \keyw{operations}
        CircCyl : () ==> ()
        CircCyl() == ( \keyw{let} cyl = CYLIO`ExtGetCylinder() \keyw{in} 
                         \keyw{let} vol = CircCylVol(cyl) \keyw{in}
                            CYLIO`ExtShowCircCylVol(cyl, vol))
\keyw{end} CYLINDER
\end{alltt}

The {\tt MATH} module is defined as:

\begin{alltt}
\keyw{dlmodule} MATH
  \keyw{exports}
    \keyw{functions}
      ExtCos : \keyw{real} -> \keyw{real};
      ExtSin : \keyw{real} -> \keyw{real}  
      
   \keyw{values}   
      ExtPI : \keyw{real}
  
   \keyw{uselib}
      "libmath.so" 

\keyw{end} MATH
\end{alltt}

The {\tt CYLIO} module is defined as:

\begin{alltt}
\keyw{dlmodule} CYLIO
  \keyw{imports}
    \keyw{from} CYLINDER
      \keyw{types}
        CircCyl

   \keyw{exports}
     \keyw{functions}
       ExtGetCylinder : () -> CircCyl
   
     \keyw{operations}
       ExtShowCircCylVol : CircCyl * \keyw{real} ==> ()

   \keyw{uselib}
      "libcylio.so"

\keyw{end} CYLIO
\end{alltt}

The way to use such modules with the VDM-SL Interpreter is described
in \cite{DLMan-SCSK}
\end{description}

\section{Differences between  VDM-SL
         and\\      ISO/VDM-SL}\label{diff}

This version of  \vdmslpp{\vdmsl}{\vdmpp} is based on 
the ISO/VDM-SL standard, but a few differences exist. These
differences are both syntactical and semantical, and are mainly due to
the extensions of the language and to requirements to make 
\vdmslpp{\vdmsl}{\vdmpp} constructs executable\footnote{The semantics
mentioned here is the semantics of the interpreter.}.

The major difference between  {\vdmsl} and
ISO/VDM-SL is the availability of a structuring in  VDM-SL. This
causes some syntactical differences.

For the flat part of  VDM-SL, the following differences with ISO/VDM-SL
exist:


\begin{description}
\item[Syntactical differences:]\mbox{}\\
  \begin{itemize}
  
  \item Semicolon (``;'') is used in the standard as a separator
    between subsequent constructs (e.g., between function
    definitions).  \vdmslpp{\vdmsl}{\vdmpp} adds to this rule that
    an optional semicolon can be put after the last of such a sequence
    of constructs. This change apply to the following syntactic
    definitions (see appendix \ref{app-a}): \vdmslpp{{\em state
    definition},}{} {\em type definitions}, {\em values definitions},
    {\em function definitions}, {\em operation definitions}, {\em def
    expression}, {\em def statement}, and {\em block statement}.

  \item In explicit function and operation definitions it is possible
    to specify an optional post condition in 
    \vdmslpp{VDM-SL}{\vdmpp} (see section~\ref{functiondef} and
    section~\ref{op-def} or section~\ref{functiondef2} or
    section~\ref{op-def2}).

  \item The body of explicit function and operation definitions can be
    specified in a preliminary manner using the \vdmslpp{clause}{clauses
    \keyw{is subclass responsibility} and} \keyw{is not yet specified}.

    
  \item An extended form for explicit function and operation
    definitions has been included. The extension is to enable the
    function and operation definition to use a heading similar to that
    used for implicit definitions. This makes it easier first to write
    an implicit definition and then add an algorithmic part later
    on. In addition the result identifier type pair has been
    generalised to work with more than one identifier.

  \item In a flat specification the keyword \keyw{definitions} is not used.
    This way, a flat specification can be distributed over several files.
    However, in a module, the definitions section must begin with the
    keyword \keyw{definitions} (see Section~\ref{flat}).

  \item  \vdmsl\ has been extended with the {\em specification statement}.

  \item In an {\it if statement\/} the ``else'' part is optional (see
        section~\ref{condstmt} or section~\ref{condstmt2}).
        
  \item An empty set and an empty sequence can be used directly as
        patterns (see section~\ref{patterns} or section~\ref{patterns2}).
  \item ``map domain restrict to'' and ``map domain restrict by'' have
        a right grouping (see section~\ref{grouping}).
  \item The operator precedence ordering for map type constructors is
        different from the standard (see section~\ref{preceedence}).


  \end{itemize}
  
\item[Semantical differences (wrt.\ the interpreter):]\mbox{}\\[-3mm] 
  \begin{itemize}
  
  \item  \vdmslpp{\vdmsl}{\vdmpp} only operates with a
    conditional logic (see section~\ref{bool}).
    
  \item The initialisation of a global state must be written in a
    special constructive way. Note that the state of a module is only
    initialised if at least one operation from that module is used
    (see section~\ref{statedef}).

  \item In  \vdmslpp{\vdmsl}{\vdmpp}, {\it value definitions\/}
    which are mutually recursive cannot be executed and they must be
    ordered such that they are defined before they are used (see
    section~\ref{valuedef}).
    
  \item The local definitions in a {\it let statement\/} and a {\it
    let expression\/} cannot be recursively defined. Furthermore they
    must be ordered such that they are defined before they are used
    (see section~\ref{let-exp} and section~\ref{letstmt}).
    
  \item The numeric type \keyw{rat} in  \vdmslpp{\vdmsl}{\vdmpp}
    denotes the same type as the type \keyw{real} (see
    section~\ref{numeric}).
      
  \item The two forms of interpreting looseness which are used in
    ISO/VDM-SL are `underdeterminedness' and `nondeterminism'. In
    ISO/VDM-SL the looseness in operations is nondeterministic whereas
    it is underdetermined for functions. In 
    \vdmslpp{\vdmsl}{\vdmpp} the looseness in both operations and
    functions is underdetermined. This is, however, also in line with
    the standard because the interpreter simply corresponds to one of
    the possible models for a specification.

  \end{itemize}
\end{description}

\section{Static Semantics}\label{static}

VDM specifications that are syntactically correct according to the
syntax rules do not necessarily obey the
typing and scoping rules of the language.
The well-formedness of a
VDM specification can be checked by the {\em static semantics checker}.
In the Toolbox such a static semantics checker (for programming
languages this is normally referred to as a type checker) is also
present.

In general, it is not statically decidable whether a given VDM
specification is well-formed or not.  The static semantics for
\vdmslpp{\vdmsl}{\vdmpp}\ differs from the static semantics of other
languages in the sense that it only rejects specifications which are
definitely not well-formed, and only accepts specifications which are
definitely well-formed.  Thus, the static semantics for
\vdmslpp{\vdmsl}{\vdmpp}\ attaches a {\em well-formedness grade} to a
VDM specification.  Such a well-formedness grade indicates whether a
specification is definitely well-formed, definitely not-well-formed, or
possibly well-formed.

In the Toolbox this means that the static semantics checker can be
called for either possible correctness or definite correctness.
However, it should be noted that only very simple specifications will
be able to pass the definite well-formed\-ness check. Thus, for
practical use the possible well-formedness is most useful.

The difference between a possibly well-formedness check and a definite
well-formedness check can be illustrated by the following
fragment of a VDM specification:
\begin{alltt}
   \keyw{if} a = \keyw{true} 
   \keyw{then} a + 1 
   \keyw{else} \keyw{not} a
\end{alltt}
where {\tt a} has the type {\tt \keyw{nat} | \keyw{bool}} (the union
type of
\keyw{nat} and
\keyw{bool}). The reader can easily see that this expression is
ill-formed if {\tt a} is equal to \keyw{true} because then it will be
impossible to add one to {\tt a}. However, since such expressions can
be arbitrarily complex this can in general not be checked statically. In
this particular example possible well-formedness will yield
\keyw{true} while definite well-formedness will yield \keyw{false}.



\newpage

%\bibliographystyle{newalpha}
\bibliographystyle{alpha}
\bibliography{ifad}

\newpage
\appendix

% Do not delete next line:
% Start Of Rules

\section{The  VDM-SL Syntax} \label{app-a}
This appendix specifies the complete syntax for 
VDM-SL.
\subsection{Document}

\Ruledef{document}{
  \Ruleref{any module}, \SeqPt{\Ruleref{any module}} \dsep
   \Ruleref{definition block}, \SeqPt{\Ruleref{definition block}}
  }

\Ruledef{any module}{
  \Ruleref{module} \dsep
  \Ruleref{dynamic link module}
  }

\subsection{Modules}

This entire subsection is not present in the current version of the
VDM-SL standard. \marginpar{\hspace*{-3mm}\fbox{{\footnotesize Non standard}}}

\Ruledef{module}{
  \Lop{module}, \Ruleref{identifier}, \Ruleref{interface}, \lfeed
  \OptPt{\Ruleref{module body}}, \Lop{end}, \Ruleref{identifier}
  }

\Ruledef{interface}{
  \OptPt{\Ruleref{import definition list}}, \lfeed
  \Ruleref{export definition}
  }

\Ruledef{import definition list}{
  \Lop{imports}, \Ruleref{import definition}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{import definition}}
  }

\Ruledef{import definition}{
  \Lop{from}, \Ruleref{identifier}, \Ruleref{import module signature}
  }

\Ruledef{import module signature}{
  \Lop{all} \dsep
  \Ruleref{import signature}, \SeqPt{\Ruleref{import signature}}
  }

\Ruledef{import signature}{
  \Ruleref{import types signature} \dsep
  \Ruleref{import values signature} \dsep
  \Ruleref{import functions signature} \dsep
  \Ruleref{import operations signature}
%  \dsep
%  \Ruleref{state signature}
  }

\Ruledef{import types signature}{
  \Lop{types}, \Ruleref{type import}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{type import}}, \OptPt{\Lit{;}}
  }

\Ruledef{type import}{
  \Ruleref{name}, \OptPt{\Lop{renamed}, \Ruleref{name}} \dsep
  \Ruleref{type definition}, \OptPt{\Lop{renamed}, \Ruleref{name}}
  }

\Ruledef{import values signature}{
  \Lop{values}, \Ruleref{value import}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{value import}}, \OptPt{\Lit{;}}
  }

\Ruledef{value import}{
  \Ruleref{name}, \OptPt{\Lit{:}, \Ruleref{type}}, \OptPt{\Lop{renamed}, \Ruleref{name}}
  }

\Ruledef{import functions signature}{
  \Lop{functions}, \Ruleref{function import}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{function import}}, \OptPt{\Lit{;}}
  }

\Ruledef{function import}{
  \Ruleref{name}, \OptPt{\OptPt{type variable list}, 
  \Lit{:}, \Ruleref{function type}}, \lfeed
  \OptPt{\Lop{renamed}, \Ruleref{name}}
  }

\Ruledef{import operations signature}{
  \Lop{operations}, \Ruleref{operation import}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{operation import}}, \OptPt{\Lit{;}}
  }

\Ruledef{operation import}{
  \Ruleref{name}, \OptPt{\Lit{:}, \Ruleref{operation type}}, \OptPt{\Lop{renamed}, \Ruleref{name}}
  }

\Ruledef{export definition}{
  \Lop{exports}, \Ruleref{export module signature}
  }

\Ruledef{export module signature}{
  \Lop{all} \dsep
  \Ruleref{export signature}, \lfeed
  \SeqPt{\Ruleref{export signature}}
  }

\Ruledef{export signature}{
  \Ruleref{export types signature} \dsep
  \Ruleref{values signature} \dsep
  \Ruleref{export functions signature} \dsep
  \Ruleref{operations signature}
%  \dsep
%  \Ruleref{state signature}
  }

\Ruledef{export types signature}{
  \Lop{types}, \Ruleref{type export}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{type export}}, \OptPt{\Lit{;}}
  }

\Ruledef{type export}{
  \OptPt{\Lop{struct}}, \Ruleref{name}
  }

\Ruledef{values signature}{
  \Lop{values}, \Ruleref{value signature}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{value signature}}, \OptPt{\Lit{;}}
  }

\Ruledef{value signature}{
  \Ruleref{name list}, \Lit{:}, \Ruleref{type}
  }

\Ruledef{export functions signature}{
  \Lop{functions} \Ruleref{function export}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{function export}}
  }

\Ruledef{function export}{
  \Ruleref{name list}, \OptPt{\Ruleref{type variable list}}, \Lit{:}, \lfeed
  \Ruleref{function type}
  }
  
\Ruledef{functions signature}{
  \Lop{functions} \Ruleref{function signature}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{function signature}}, \OptPt{\Lit{;}}
  }

\Ruledef{function signature}{
    \Ruleref{name list}, \Lit{:}, \Ruleref{function type}
  }

\Ruledef{operations signature}{
  \Lop{operations} \Ruleref{operation signature}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{operation signature}}, \OptPt{\Lit{;}}
  }

\Ruledef{operation signature}{
  \Ruleref{name list}, \Lit{:}, \Ruleref{operation type}
  }
  
%\Ruledef{state signature}{
%  \Lop{state}, \Ruleref{name}, \SeqPt{\Lit{,}, \Ruleref{name}}
%  }
 
\Ruledef{dynamic link module}{
  \Lop{dlmodule}, \Ruleref{identifier}, \lfeed
  \Ruleref{dynamic link interface},\lfeed
  \OptPt{\Ruleref{use signature}},\lfeed
  \Lop{end}, \Ruleref{identifier}
  }

\Ruledef{dynamic link interface}{
  \OptPt{\Ruleref{dynamic link import definition list}}, \lfeed
  \Ruleref{dynamic link export definition}
  }

\Ruledef{use signature}{
   \Lop{uselib}, \Ruleref{text literal}
   }

\Ruledef{dynamic link import definition list}{
  \Lop{imports}, \lfeed
  \Ruleref{dynamic link import definition}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{dynamic link import definition}}
  }

\Ruledef{dynamic link import definition}{
  \Lop{from}, \Ruleref{identifier}, \lfeed
  \Ruleref{dynamic link import types signatures}
  }

\Ruledef{dynamic link import types signatures}{
  \Lop{types}, \Ruleref{name}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{name}}, \OptPt{\Lit{;}}
  }

\Ruledef{dynamic link export definition}{
  \Lop{exports}, \lfeed
  \Ruleref{dynamic link export signature}, \lfeed
  \SeqPt{\Ruleref{dynamic link export signature}}
  }

\Ruledef{dynamic link export signature}{
  \Ruleref{values signature} \dsep
  \Ruleref{functions signature} \dsep
  \Ruleref{operations signature}
  }
\subsection{Definitions}


\Ruledef{module body}{
  \Lop{definitions}, \Ruleref{definition block}, \SeqPt{\Ruleref{definition block}}
  }

\Ruledef{definition block}{
  \Ruleref{type definitions} \dsep
  \Ruleref{state definition} \dsep
  \Ruleref{value definitions} \dsep
  \Ruleref{function definitions} \dsep
  \Ruleref{operation definitions}
  }

\subsubsection{Type Definitions}
\label{mathCSTypeDefs}

\Ruledef{type definitions}{
  \Lop{types}, 
  \OptPt{\ifthenelse{\boolean{VDMpp}}{\Ruleref{access type definition}}%
                                     {\Ruleref{type definition}}
         , \lfeed
         \SeqPt{\Lit{;}, 
               \ifthenelse{\boolean{VDMpp}}{\Ruleref{access type definition}}%
                                           {\Ruleref{type definition}}}, 
         \OptPt{\Lit{;}}
        }
  }%
  \nonstandard{1}

\ifthenelse{\boolean{VDMpp}}{
  \Ruledef{access type definition}{
     (\OptPt{\Ruleref{access}}, \OptPt{\Lop{static}})  \dsepl\ (\OptPt{\Lop{static}}, \OptPt{\Ruleref{access}}), \lfeed 
     \Ruleref{type definition}
    }
  }{}

\ifthenelse{\boolean{VDMpp}}{
  \Ruledef{access}{
    \Lop{public} \dsep \Lop{private} \dsep \Lop{protected}
  }
}{}

\Ruledef{type definition}{
  \Ruleref{identifier}, \Lit{=}, \Ruleref{type}, \OptPt{\Ruleref{invariant}} \dsep
  \Ruleref{identifier}, \Lit{::}, \Ruleref{field list}, \OptPt{\Ruleref{invariant}}
  }

\Ruledef{type}{
  \Ruleref{bracketed type} \dsep
  \Ruleref{basic type} \dsep
  \Ruleref{quote type} \dsep
  \Ruleref{composite type} \dsep
  \Ruleref{union type} \dsep
  \Ruleref{product type} \dsep
  \Ruleref{optional type} \dsep
  \Ruleref{set type} \dsep
  \Ruleref{seq type} \dsep
  \Ruleref{map type} \dsep
  \Ruleref{partial function type} \dsep
  \Ruleref{type name} \dsep
  \Ruleref{type variable}
  }

\Ruledef{bracketed type}{
  \Lit{(}, \Ruleref{type}, \Lit{)}
  }

\Ruledef{basic type}{
  \Lop{bool} \dsepl
  \Lop{nat} \dsepl
  \Lop{nat1} \dsepl
  \Lop{int} \dsepl
  \Lop{rat} \dsep
  \Lop{real} \dsepl
  \Lop{char} \dsepl
  \Lop{token} 
  }

\Ruledef{quote type}{
  \Ruleref{quote literal}
  }

\Ruledef{composite type}{
  \Lop{compose}, \Ruleref{identifier}, \Lop{of}, \Ruleref{field list}, \Lop{end}
  }

\Ruledef{field list}{
  \SeqPt{\Ruleref{field}}
  }

\Ruledef{field}{
  \OptPt{\Ruleref{identifier}, \Lit{:}}, \Ruleref{type} \dsep
  \OptPt{\Ruleref{identifier}, \Lit{:-}}, \Ruleref{type}
  }

\Ruledef{union type}{
  \Ruleref{type}, \Lit{|}, \Ruleref{type}, \SeqPt{\Lit{|}, \Ruleref{type}}
  }

\Ruledef{product type}{
  \Ruleref{type}, \Lit{*}, \Ruleref{type}, \SeqPt{\Lit{*}, \Ruleref{type}}
  }

\Ruledef{optional type}{
  \Lit{[}, \Ruleref{type}, \Lit{]}
  }

\Ruledef{set type}{
  \Lop{set of}, \Ruleref{type}
  }

\Ruledef{seq type}{
  \Ruleref{seq0 type} \dsep
  \Ruleref{seq1 type}
  }

\Ruledef{seq0 type}{
  \Lop{seq of}, \Ruleref{type}
  }

\Ruledef{seq1 type}{
  \Lop{seq1 of}, \Ruleref{type}
  }

\Ruledef{map type}{
  \Ruleref{general map type} \dsep
  \Ruleref{injective map type}
  }

\Ruledef{general map type}{
  \Lop{map}, \Ruleref{type}, \Lop{to}, \Ruleref{type}
  }

\Ruledef{injective map type}{
  \Lop{inmap}, \Ruleref{type}, \Lop{to}, \Ruleref{type}
  }

\Ruledef{function type}{
  \Ruleref{partial function type} \dsep
  \Ruleref{total function type}
  }

\Ruledef{partial function type}{
  \Ruleref{discretionary type}, \Lit{->}, \Ruleref{type}
  }

\Ruledef{total function type}{
  \Ruleref{discretionary type}, \Lit{+>}, \Ruleref{type}
  }

\Ruledef{discretionary type}{
  \Ruleref{type} \dsep
  \Lit{(}, \Lit{)}
  }

\Ruledef{type name}{
  \Ruleref{name}
  }

\Ruledef{type variable}{
  \Ruleref{type variable identifier}
  }


\subsubsection{The State Definition}

\Ruledef{state definition}{
  \Lop{state}, \Ruleref{identifier}, \Lop{of}, \Ruleref{field list}, \lfeed
  \OptPt{\Ruleref{invariant}}, \OptPt{\Ruleref{initialisation}}, \Lop{end}, \OptPt{\Lit{;}}
  }\nonstandard{1}
\Ruledef{invariant}{
  \Lop{inv}, \Ruleref{invariant initial function}
  }

\Ruledef{initialisation}{
  \Lop{init}, \Ruleref{invariant initial function}
  }

\Ruledef{invariant initial function}{
  \Ruleref{pattern}, \Lit{==}, \Ruleref{expression}
  }

\subsubsection{Value Definitions}

\Ruledef{value definitions}{
  \Lop{values}, 
  \OptPt{\ifthenelse{\boolean{VDMpp}}{\Ruleref{access value definition}}%
                                     {\Ruleref{value definition}}, \lfeed
         \SeqPt{\Lit{;}, 
                \ifthenelse{\boolean{VDMpp}}{\Ruleref{access value definition}}%
                                            {\Ruleref{value definition}}
               }, 
         \OptPt{\Lit{;}}
        }
  }
  \nonstandard{1}

  \ifthenelse{\boolean{VDMpp}}{
    \Rule{access value definition}{
       (\OptPt{\Ruleref{access}}, \OptPt{\Lop{static}})  \dsepl\ (\OptPt{\Lop{static}}, \OptPt{\Ruleref{access}}), \lfeed 
         \Ruleref{value definition}
    }}{}

\Ruledef{value definition}{ 
  \Ruleref{pattern}, \OptPt{\Lit{:}, \Ruleref{type}}, \Lit{=}, \Ruleref{expression}
  }
  \nonstandard{1}

\subsubsection{Function Definitions}\label{functiondef2}

\Ruledef{function definitions}{
  \Lop{functions}, 
  \OptPt{\ifthenelse{\boolean{VDMpp}}{\Ruleref{access function definition}}%
                                     {\Ruleref{function definition}}, \lfeed
         \SeqPt{\Lit{;}, 
                \ifthenelse{\boolean{VDMpp}}{\Ruleref{access function definition}}%
                                     {\Ruleref{function definition}}}, 
         \OptPt{\Lit{;}}
        }
  }
  \nonstandard{1}

\ifthenelse{\boolean{VDMpp}}{
  \Rule{access function definition}{
    (\OptPt{\Ruleref{access}}, \OptPt{\Lop{static}})  \dsepl\  (\OptPt{\Lop{static}}, \OptPt{\Ruleref{access}}), \lfeed
      \Ruleref{function definition}
  }}{}

\Ruledef{function definition}{
  \Ruleref{explicit function definition} \dsep
  \Ruleref{implicit function definition} \dsep
  \Ruleref{extended explicit function definition}
  }
  \nonstandard{1}

\Ruledef{explicit function definition}{
  \Ruleref{identifier},
  \OptPt{\Ruleref{type variable list}},
  \Lit{:}, \lfeed
  \Ruleref{function type}, \lfeed
  \Ruleref{identifier}, \Ruleref{parameters list}, \lfeed
  \Lit{==}, \Ruleref{function body}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}
    , \lfeed \OptPt{\Lop{post}, \Ruleref{expression}}, \lfeed
  \OptPt{\Lop{measure}, \Ruleref{name}}
  }
  \nonstandard{1}

\Ruledef{implicit function definition}{
  \Ruleref{identifier}, \OptPt{\Ruleref{type variable list}}, \lfeed 
  \Ruleref{parameter types}, \lfeed
  \Ruleref{identifier type pair list}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
  \Lop{post}, \Ruleref{expression}
  }

%This should be removed and exchanged with a more general solution.
\setlength{\nonstandlen}{-2\baselineskip}\addtolength{\nonstandlen}{-.8ex}

\vspace{\nonstandlen}\mbox{}\marginpar{\hspace*{-3mm}\raisebox{\nonstandlen}[0pt][0pt]{{\fbox{{\footnotesize Non standard}}}}}
\Ruledef{extended explicit function definition}{
  \Ruleref{identifier}, \OptPt{\Ruleref{type variable list}}, \lfeed
  \Ruleref{parameter types}, \lfeed
  \Ruleref{identifier type pair list}, \lfeed
  \Lit{==}, \Ruleref{function body}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{expression}}
}

\Ruledef{type variable list}{
  \Lit{[}, \Ruleref{type variable identifier}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{type variable identifier}}, \Lit{]}
  }             

\Ruledef{identifier type pair}{
  \Ruleref{identifier}, \Lit{:}, \Ruleref{type}
  }

\Ruledef{parameter types}{
  \Lit{(}, \OptPt{\Ruleref{pattern type pair list}}, \Lit{)}
  }

\Ruledef{identifier type pair list}{
  \Ruleref{identifier}, \Lit{:}, \Ruleref{type}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{identifier}, \Lit{:}, \Ruleref{type}}
}

\Ruledef{pattern type pair list}{
  \Ruleref{pattern list}, \Lit{:}, \Ruleref{type}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{pattern list},\Lit{:}, \Ruleref{type}}
  }

\Ruledef{parameters list}{
  \Ruleref{parameters}, \SeqPt{\Ruleref{parameters}}
  }

\Ruledef{parameters}{
  \Lit{(}, \OptPt{\Ruleref{pattern list}}, \Lit{)}
  }

\Ruledef{function body}{
  \Ruleref{expression} \dsep
  \Lop{is not yet specified} 
  } \nonstandard{1}

\subsubsection{Operation Definitions}\label{op-def2}

\Ruledef{operation definitions}{
  \Lop{operations}, 
  \OptPt{\ifthenelse{\boolean{VDMpp}}{\Ruleref{access operation definition}}%
                                     {\Ruleref{operation definition}}, \lfeed
         \SeqPt{\Lit{;}, 
                \ifthenelse{\boolean{VDMpp}}{\Ruleref{access operation definition}}%
                                     {\Ruleref{operation definition}}
               }, 
         \OptPt{\Lit{;}}
        }
  }\nonstandard{1}

  \ifthenelse{\boolean{VDMpp}}{
    \Ruledef{access operation definition}{(
      \OptPt{\Ruleref{access}}, \OptPt{\Lop{static}})  \dsep\  
     (
      \OptPt{\Lop{static}}, \OptPt{\Ruleref{access}}), \lfeed
      \Ruleref{operation definition}
    }}{}

\Ruledef{operation definition}{
  \Ruleref{explicit operation definition} \dsep
  \Ruleref{implicit operation definition} \dsep
  \Ruleref{extended explicit operation definition}
  }\nonstandard{1}

\Ruledef{explicit operation definition}{
  \Ruleref{identifier}, \Lit{:}, \Ruleref{operation type}, \lfeed
  \Ruleref{identifier}, \Ruleref{parameters}, \lfeed
  \Lit{{\tt ==}}, \Ruleref{operation body}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{expression}}
  }\nobreak\nonstandard{1}

\Ruledef{implicit operation definition}{
  \Ruleref{identifier}, \Ruleref{parameter types}, \lfeed
  \OptPt{\Ruleref{identifier type pair list}}, \lfeed
  \Ruleref{implicit operation body}
  }

\Ruledef{implicit operation body}{
  \OptPt{\Ruleref{externals}}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
  \Lop{post}, \Ruleref{expression}, \lfeed
  \OptPt{\Ruleref{exceptions}}
  }

\Ruledef{extended explicit operation definition}{
  \Ruleref{identifier}, \Ruleref{parameter types}, \lfeed
  \OptPt{\Ruleref{identifier type pair list}}, \lfeed
  \Lit{==}, \Ruleref{operation body}, \lfeed
  \OptPt{\Ruleref{externals}}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{expression}}, \lfeed
  \OptPt{\Ruleref{exceptions}}
}\nonstandard{7}

\Ruledef{operation type}{
  \Ruleref{discretionary type}, \Lit{==>}, \Ruleref{discretionary type}
  }

\Ruledef{operation body}{
  \Ruleref{statement} \dsep 
  \Lop{is not yet specified}
  } \nonstandard{1}

\Ruledef{externals}{
  \Lop{ext}, \Ruleref{var information}, \SeqPt{\Ruleref{var information}}
  }

\Ruledef{var information}{
  \Ruleref{mode}, \Ruleref{name list}, \OptPt{\Lit{:}, \Ruleref{type}}
  }

\Ruledef{mode}{
  \Lop{rd} \dsepl \Lop{wr}
  }

\Ruledef{exceptions}{
  \Lop{errs}, \Ruleref{error list}
  }

\Ruledef{error list}{
  \Ruleref{error}, \SeqPt{error}
  }

\Ruledef{error}{
  \Ruleref{identifier}, \Lit{:}, \Ruleref{expression}, \Lit{->}, \Ruleref{expression}
  }


\subsection{Expressions}

\Ruledef{expression list}{
  \Ruleref{expression}, \SeqPt{\Lit{,}, \Ruleref{expression}}
  }

\Ruledef{expression}{
  \Ruleref{bracketed expression} \dsep
  \Ruleref{let expression} \dsep
  \Ruleref{let be expression} \dsep
  \Ruleref{def expression} \dsep
  \Ruleref{if expression} \dsep
  \Ruleref{cases expression} \dsep
  \Ruleref{unary expression} \dsep
  \Ruleref{binary expression} \dsep
  \Ruleref{quantified expression} \dsep
  \Ruleref{iota expression} \dsep
  \Ruleref{set enumeration} \dsep
  \Ruleref{set comprehension} \dsep
  \Ruleref{set range expression} \dsep
  \Ruleref{sequence enumeration} \dsep
  \Ruleref{sequence comprehension} \dsep
  \Ruleref{subsequence} \dsep
  \Ruleref{map enumeration} \dsep
  \Ruleref{map comprehension} \dsep
  \Ruleref{tuple constructor} \dsep
  \Ruleref{record constructor} \dsep 
  \Ruleref{record modifier}  \dsep
  \Ruleref{apply} \dsep
  \Ruleref{field select} \dsep
  \Ruleref{tuple select} \dsep
  \Ruleref{function type instantiation} \dsep
  \Ruleref{lambda expression} \dsep
  \Ruleref{general is expression} \dsep
  \Ruleref{undefined expression} \dsep
  \Ruleref{precondition expression} \dsep
  \Ruleref{name} \dsep
  \Ruleref{old name}  \dsep
  \Ruleref{symbolic literal}
}
\nonstandard{4}

\subsubsection{Bracketed Expressions}

\Ruledef{bracketed expression}{
  \Lit{(}, \Ruleref{expression}, \Lit{)}
  }

\subsubsection{Local Binding Expressions}

\Ruledef{let expression}{
  \Lop{let}, \Ruleref{local definition},
   \SeqPt{\Lit{,}, \Ruleref{local definition}}, \lfeed
  \Lop{in}, \Ruleref{expression}
  }

\Ruledef{let be expression}{
  \Lop{let}, \Ruleref{bind},
  \OptPt{\Lop{be}, \Lop{st}, \Ruleref{expression}}, \Lop{in}, \lfeed
  \Ruleref{expression}
  }

\Ruledef{def expression}{
  \Lop{def}, 
  \Ruleref{pattern bind}, \Lit{=}, \Ruleref{expression}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{pattern bind}, \Lit{=}, \Ruleref{expression}}, \OptPt{\Lit{;}},
  \lfeed
  \Lop{in}, \Ruleref{expression}
  }
  \nonstandard{2}

\subsubsection{Conditional Expressions}

\Ruledef{if expression}{
  \Lop{if}, \Ruleref{expression}, \Lop{then}, \Ruleref{expression},\lfeed
  \SeqPt{\Ruleref{elseif expression}}, \lfeed
  \Lop{else}, \Ruleref{expression}
  }

\Ruledef{elseif expression}{
  \Lop{elseif}, \Ruleref{expression}, \Lop{then}, \Ruleref{expression}
  }

\Ruledef{cases expression}{
  \Lop{cases}, \Ruleref{expression}, \Lit{:},\lfeed 
  \Ruleref{cases expression alternatives}, \lfeed
  \OptPt{\Lit{,}, \Ruleref{others expression}}, \Lop{end}
  }

\Ruledef{cases expression alternatives}{
  \Ruleref{cases expression alternative}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{cases expression alternative}}
  }

\Ruledef{cases expression alternative}{
  \Ruleref{pattern list}, \Lit{->}, \Ruleref{expression}
  }

\Ruledef{others expression}{
  \Lop{others}, \Lit{->}, \Ruleref{expression}
  }

\subsubsection{Unary Expressions}

\Ruledef{unary expression}{
  \Ruleref{prefix expression} \dsep
  \Ruleref{map inverse}
  }

\Ruledef{prefix expression}{
  \Ruleref{unary operator}, \Ruleref{expression}
  }

\Ruledef{unary operator}{
  \Ruleref{unary plus} \dsep
  \Ruleref{unary minus} \dsep
  \Ruleref{arithmetic abs} \dsep
  \Ruleref{floor} \dsep
  \Ruleref{not} \dsep
  \Ruleref{set cardinality} \dsep
  \Ruleref{finite power set} \dsep
  \Ruleref{distributed set union} \dsep
  \Ruleref{distributed set intersection} \dsep
  \Ruleref{sequence head} \dsep
  \Ruleref{sequence tail} \dsep
  \Ruleref{sequence length} \dsep
  \Ruleref{sequence elements} \dsep
  \Ruleref{sequence indices} \dsep
  \Ruleref{distributed sequence concatenation} \dsep
  \Ruleref{map domain} \dsep
  \Ruleref{map range} \dsep
  \Ruleref{distributed map merge}
  }

\Ruledef{unary plus}{
  \Lit{+}
  }

\Ruledef{unary minus}{
  \Lit{-}
  }

\Ruledef{arithmetic abs}{
  \Lop{abs}
  }

\Ruledef{floor}{
  \Lop{floor}
  }

\Ruledef{not}{
  \Lop{not}
  }

\Ruledef{set cardinality}{
  \Lop{card}
  }

\Ruledef{finite power set}{
  \Lop{power}
  }

\Ruledef{distributed set union}{
  \Lop{dunion}
  }

\Ruledef{distributed set intersection}{
  \Lop{dinter}
  }

\Ruledef{sequence head}{
  \Lop{hd}
  }

\Ruledef{sequence tail}{
  \Lop{tl}
  }

\Ruledef{sequence length}{
  \Lop{len}
  }

\Ruledef{sequence elements}{
  \Lop{elems}
  }

\Ruledef{sequence indices}{
  \Lop{inds}
  }

\Ruledef{distributed sequence concatenation}{
  \Lop{conc}
  }

\Ruledef{map domain}{
  \Lop{dom}
  }

\Ruledef{map range}{
  \Lop{rng}
  }

\Ruledef{distributed map merge}{
  \Lop{merge}
  }

\Ruledef{map inverse}{
  \Lop{inverse}, \Ruleref{expression}
  }

\subsubsection{Binary Expressions}

\Ruledef{binary expression}{
  \Ruleref{expression}, \Ruleref{binary operator}, \Ruleref{expression}
  }

\Ruledef{binary operator}{
  \Ruleref{arithmetic plus} \dsep
  \Ruleref{arithmetic minus} \dsep
  \Ruleref{arithmetic multiplication} \dsep
  \Ruleref{arithmetic divide} \dsep
  \Ruleref{arithmetic integer division} \dsep
  \Ruleref{arithmetic rem} \dsep
  \Ruleref{arithmetic mod} \dsep
  \Ruleref{less than} \dsep
  \Ruleref{less than or equal} \dsep
  \Ruleref{greater than} \dsep
  \Ruleref{greater than or equal} \dsep
  \Ruleref{equal} \dsep
  \Ruleref{not equal} \dsep
  \Ruleref{or} \dsep
  \Ruleref{and} \dsep
  \Ruleref{imply} \dsep
  \Ruleref{logical equivalence} \dsep
  \Ruleref{in set} \dsep
  \Ruleref{not in set} \dsep
  \Ruleref{subset} \dsep
  \Ruleref{proper subset} \dsep
  \Ruleref{set union} \dsep
  \Ruleref{set difference} \dsep
  \Ruleref{set intersection} \dsep
  \Ruleref{sequence concatenate} \dsep
  \Ruleref{map or sequence modify} \dsep
  \Ruleref{map merge} \dsep
  \Ruleref{map domain restrict to} \dsep
  \Ruleref{map domain restrict by} \dsep
  \Ruleref{map range restrict to} \dsep
  \Ruleref{map range restrict by} \dsep
  \Ruleref{composition} \dsep
  \Ruleref{iterate} 
}

\Ruledef{arithmetic plus}{
  \Lit{+}
  }

\Ruledef{arithmetic minus}{
  \Lit{-}
  }

\Ruledef{arithmetic multiplication}{
  \Lit{*}
  }

\Ruledef{arithmetic divide}{
  \Lit{/}
  }

\Ruledef{arithmetic integer division}{
  \Lop{div}
  }

\Ruledef{arithmetic rem}{
  \Lop{rem}
  }

\Ruledef{arithmetic mod}{
  \Lop{mod}
  }

\Ruledef{less than}{
  \Lit{<}
  }

\Ruledef{less than or equal}{
  \Lit{<=}
  }

\Ruledef{greater than}{
  \Lit{>}
  }

\Ruledef{greater than or equal}{
  \Lit{>=}
  }

\Ruledef{equal}{
  \Lit{=}
  }

\Ruledef{not equal}{
  \Lit{<>}
  }

%#ifdef VDMPP
%\Ruledef{approx}{
%  \Lop{\~{}=}
%}
%#endif VDMPP
\Ruledef{or}{
  \Lop{or}
  }

\Ruledef{and}{
  \Lop{and}
  }

\Ruledef{imply}{
  \Lit{=>}
  }

\Ruledef{logical equivalence}{
  \Lit{<=>}
  }

\Ruledef{in set}{
  \Lop{in set}
  }

\Ruledef{not in set}{
  \Lop{not in set}
  }

\Ruledef{subset}{
  \Lop{subset}
  }

\Ruledef{proper subset}{
  \Lop{psubset}
  }

\Ruledef{set union}{
  \Lop{union}
  }

\Ruledef{set difference}{
  \Lit{\char'134}
  }

\Ruledef{set intersection}{
  \Lop{inter}
  }

\Ruledef{sequence concatenate}{
  \Lit{\char'136}
  }

\Ruledef{map or sequence modify}{
  \Lit{++}
  }

\Ruledef{map merge}{
  \Lop{munion}
  }

\Ruledef{map domain restrict to}{
  \Lit{<:}
  }

\Ruledef{map domain restrict by}{
  \Lit{<-:}
  }

\Ruledef{map range restrict to}{
  \Lit{:>}
  }

\Ruledef{map range restrict by}{
  \Lit{:->}
  }

\Ruledef{composition}{
  \Lop{comp}
  }

\Ruledef{iterate}{
  \Lit{**}
  }

\subsubsection{Quantified Expressions}

\Ruledef{quantified expression}{
  \Ruleref{all expression} \dsep
  \Ruleref{exists expression} \dsep
  \Ruleref{exists unique expression}
  }

\Ruledef{all expression}{
  \Lop{forall}, \Ruleref{bind list}, \Lit{\&}, \Ruleref{expression}
  }

\Ruledef{exists expression}{
  \Lop{exists}, \Ruleref{bind list}, \Lit{\&}, \Ruleref{expression}
  }

\Ruledef{exists unique expression}{
  \Lop{exists1}, \Ruleref{bind}, \Lit{\&}, \Ruleref{expression}
  }

\subsubsection{The Iota Expression}

\Ruledef{iota expression}{
  \Lop{iota}, \Ruleref{bind}, \Lit{\&}, \Ruleref{expression}
  }

\subsubsection{Set Expressions}

\Ruledef{set enumeration}{
  \Lit{\{}, \OptPt{\Ruleref{expression list}}, \Lit{\}}
  }

\Ruledef{set comprehension}{
  \Lit{\{}, \Ruleref{expression}, \Lit{|}, \Ruleref{bind list}, \lfeed
  \OptPt{\Lit{\&}, \Ruleref{expression}},
  \Lit{\}}
  }

\Ruledef{set range expression}{
  \Lit{\{}, \Ruleref{expression}, \Lit{,}, \Lit{\Range}, \Lit{,},
  \lfeed
  \Ruleref{expression},
  \Lit{\}}
  }

\subsubsection{Sequence Expressions}

\Ruledef{sequence enumeration}{
  \Lit{[}, \OptPt{\Ruleref{expression list}}, \Lit{]}
  }

\Ruledef{sequence comprehension}{
  \Lit{[}, \Ruleref{expression}, \Lit{|}, \Ruleref{set bind}, \lfeed
  \OptPt{\Lit{\&}, \Ruleref{expression}},
  \Lit{]}
  }

\Ruledef{subsequence}{
  \Ruleref{expression}, \Lit{(}, \Ruleref{expression}, \Lit{,},
  \Lit{\Range}, \Lit{,}, \lfeed
  \Ruleref{expression}, \Lit{)} 
  }

\subsubsection{Map Expressions}

\Ruledef{map enumeration}{
  \Lit{\{}, \Ruleref{maplet}, \SeqPt{\Lit{,}, \Ruleref{maplet}}, \Lit{\}} \dsep
  \Lit{\{}, \Lit{|->}, \Lit{\}}
  }

\Ruledef{maplet}{
  \Ruleref{expression}, \Lit{|->}, \Ruleref{expression}
  }

\Ruledef{map comprehension}{
  \Lit{\{}, \Ruleref{maplet}, \Lit{|}, \Ruleref{bind list}, \lfeed
  \OptPt{\Lit{\&}, \Ruleref{expression}},
  \Lit{\}}
  }

\subsubsection{The Tuple Constructor Expression}

\Ruledef{tuple constructor}{
  \Lit{mk\_}, \Lit{(}, \Ruleref{expression}, \Lit{,}, \Ruleref{expression list}, \Lit{)}
  }

\subsubsection{Record Expressions}

\Ruledef{record constructor}{
  \Lop{mk\_},\nmk \Ruleref{name}, \Lit{(}, \OptPt{\Ruleref{expression list}}, \Lit{)}
  }
\ntext{no delimiter is allowed}

\Ruledef{record modifier}{
  \Lit{mu}, \Lit{(}, \Ruleref{expression}, \Lit{,}, \lfeed
  \Ruleref{record modification}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{record modification}}, \Lit{)}
  }

\Ruledef{record modification}{
  \Ruleref{identifier}, \Lit{|->}, \Ruleref{expression}
  }

\subsubsection{Apply Expressions}

\Ruledef{apply}{
  \Ruleref{expression}, \Lit{(}, \OptPt{\Ruleref{expression list}}, \Lit{)}
  }

\Ruledef{field select}{
  \Ruleref{expression}, \Lit{.}, \Ruleref{identifier}
  }

\Ruledef{tuple select}{
  \Ruleref{expression}, \Lit{.\#}, \Ruleref{numeral}
  }

\Ruledef{function type instantiation}{
  \Ruleref{name}, \Lit{[}, \Ruleref{type}, \SeqPt{\Lit{,}, \Ruleref{type}}, \Lit{]}
  }
  
\subsubsection{The Lambda Expression}

\Ruledef{lambda expression}{
  \Lop{lambda}, \Ruleref{type bind list}, \Lit{\&}, \Ruleref{expression}
  }

\subsection{The narrow Expression}

\Ruledef{narrow expression}{
  \Lop{narrow\_},  \Lit{(}, \Ruleref{expression},  \Lit{,}, \Ruleref{type}, \Lit{)} 
  }


\subsubsection{The Is Expression}

\Ruledef{general is expression}{
  \Ruleref{is expression} \dsep
  \Ruleref{type judgement}
  }

\Ruledef{is expression}{
  \Lit{\keyw{is}\_},\nmk \Ruleref{name}, \Lit{(}, \Ruleref{expression}, \Lit{)} \dsep
  \Ruleref{is basic type}, \Lit{(}, \Ruleref{expression}, \Lit{)}
  }
\ntext{no delimiter is allowed}

\Ruledef{type judgement}{
  \Lit{\keyw{is}\_}, \Lit{(}, \Ruleref{expression}, \Lit{,}, \Ruleref{type}, \Lit{)}
  }

\subsubsection{The Undefined Expression}

\Ruledef{undefined expression}{
  \Lop{undefined}
  }
  \nonstandard{1}

\subsubsection{The Precondition Expression}

\Ruledef{pre-condition expression}{
  \Lop{pre\_}, \Lit{(}, \Ruleref{expression}, \lfeed
                        \OptPt{\SeqPt{\Lit{,}, \Ruleref{expression}}},
               \Lit{)}
  }



\subsubsection{Names}

\Ruledef{name}{
  \Ruleref{identifier}, \OptPt{\Lit{`}, \Ruleref{identifier}}
  }

\Ruledef{name list}{
  \Ruleref{name}, \SeqPt{\Lit{,}, \Ruleref{name}}
  }

\Ruledef{old name}{
  \Ruleref{identifier}, \Lit{\char'176}
  }

\subsection{State Designators}

\Ruledef{state designator}{
  \Ruleref{name} \dsep
  \Ruleref{field reference} \dsep
  \Ruleref{map or sequence reference}
  }

\Ruledef{field reference}{
  \Ruleref{state designator}, \Lit{.}, \Ruleref{identifier}
  }

\Ruledef{map or sequence reference}{
  \Ruleref{state designator}, \Lit{(}, \Ruleref{expression}, \Lit{)}
  }

\subsection{Statements}

\Ruledef{statement}{
  \Ruleref{let statement} \dsep
  \Ruleref{let be statement} \dsep
  \Ruleref{def statement} \dsep
  \Ruleref{block statement} \dsep
  \ifthenelse{\boolean{VDMpp}}{\Ruleref{general assign statement}}%
                              {\Ruleref{assign statement}} \dsep
  \Ruleref{if statement} \dsep
  \Ruleref{cases statement} \dsep
  \Ruleref{sequence for loop} \dsep
  \Ruleref{set for loop} \dsep
  \Ruleref{index for loop} \dsep
  \Ruleref{while loop} \dsep
  \Ruleref{nondeterministic statement} \dsep 
  \Ruleref{call statement} \dsep
  \Ruleref{specification statement} \dsep
  \Ruleref{return statement} \dsep
  \Ruleref{always statement} \dsep
  \Ruleref{trap statement} \dsep
  \Ruleref{recursive trap statement} \dsep
  \Ruleref{exit statement} \dsep
  \Ruleref{error statement} \dsep
  \Ruleref{identity statement} 
  }
  \nonstandard{2}

\subsubsection{Local Binding Statements}

\Ruledef{let statement}{
  \Lop{let}, \Ruleref{local definition}, \SeqPt{\Lit{,}, \Ruleref{local definition}}, \lfeed
  \Lop{in}, \Ruleref{statement}
  }

\Ruledef{local definition}{
  \Ruleref{value definition} \dsep 
  \Ruleref{function definition}
  }

\Ruledef{let be statement}{
  \Lop{let}, \Ruleref{bind}, \OptPt{\Lop{be}, \Lop{st},
  \Ruleref{expression}}, \Lop{in}, \lfeed
  \Ruleref{statement}
  }

\Ruledef{def statement}{
  \Lop{def}, \Ruleref{equals definition}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{equals definition}}, \OptPt{\Lit{;}},
  \lfeed
  \Lop{in}, \Ruleref{statement}
  }
  \nonstandard{1}

\Ruledef{equals definition}{
  \Ruleref{pattern bind}, \Lit{=},
   \Ruleref{expression}}

\subsubsection{Block and Assignment Statements}

\Ruledef{block statement}{
  \Lit{(}, \SeqPt{\Ruleref{dcl statement}}, \lfeed
  \Ruleref{statement}, \SeqPt{\Lit{;},  \Ruleref{statement}}, \OptPt{\Lit{;}}, 
  \Lit{)}
  }\nonstandard{1}

\Ruledef{dcl statement}{
  \Lop{dcl}, \Ruleref{assignment definition}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{assignment definition}}, \Lit{;}
  }

\Ruledef{assignment definition}{
  \Ruleref{identifier}, \Lit{:}, \Ruleref{type}, \OptPt{\Lit{:=}, 
    \Ruleref{expression} }
  }

\ifthenelse{\boolean{VDMpp}}{%
  \Ruledef{general assign statement}{
  \Ruleref{assign statement} \dsep
  \Ruleref{multiple assign statement}
  }
}%
{}

\Ruledef{assign statement}{
  \Ruleref{state designator}, \Lit{:=}, 
    \Ruleref{expression}
  }

%\ifthenelse{\boolean{VDMpp}}{%
  \Ruledef{multiple assign statement}{
    \Lit{atomic}, 
    \Lit{(}
      \Ruleref{assign statement}, \Lit{;}, \lfeed
      \Ruleref{assign statement},
      \lfeed
      \OptPt{\SeqPt{\Lit{;},\Ruleref{assign statement}}},
    \Lit{)}
    }
%  }%
%{}


\subsubsection{Conditional Statements}\label{condstmt2}

\Ruledef{if statement}{
  \Lop{if}, \Ruleref{expression}, \Lop{then}, \Ruleref{statement}, \lfeed
  \SeqPt{\Ruleref{elseif statement}}, \lfeed
  \OptPt{\Lop{else}, \Ruleref{statement}}
  }

\Ruledef{elseif statement}{
  \Lop{elseif}, \Ruleref{expression}, \Lop{then}, \Ruleref{statement}
  }


\Ruledef{cases statement}{
  \Lop{cases}, \Ruleref{expression}, \Lit{:}, \lfeed
  \Ruleref{cases statement alternatives}, \lfeed 
  \OptPt{\Lit{,}, \Ruleref{others statement}}, \Lop{end}
  }

\Ruledef{cases statement alternatives}{
  \Ruleref{cases statement alternative}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{cases statement alternative}}
  }

\Ruledef{cases statement alternative}{
  \Ruleref{pattern list}, \Lit{->}, \Ruleref{statement}
  }

\Ruledef{others statement}{
  \Lop{others}, \Lit{->}, \Ruleref{statement}
  }

\subsubsection{Loop Statements}

\Ruledef{sequence for loop}{
  \Lop{for}, \Ruleref{pattern bind}, \Lop{in},
  \OptPt{\Lop{reverse}}, \lfeed
  \Ruleref{expression}, \Lop{do}, \Ruleref{statement}
  }

\Ruledef{set for loop}{
  \Lop{for}, \Lop{all}, \Ruleref{pattern}, \Lop{in set},
  \Ruleref{expression},\lfeed
  \Lop{do}, \Ruleref{statement}
  }

\Ruledef{index for loop}{
  \Lop{for}, \Ruleref{identifier}, \Lit{=}, \Ruleref{expression},
  \Lop{to}, \Ruleref{expression}, \lfeed
  \OptPt{\Lop{by}, \Ruleref{expression}}, \lfeed
  \Lop{do}, \Ruleref{statement}
  }

\Ruledef{while loop}{
  \Lop{while}, \Ruleref{expression}, \Lop{do}, \Ruleref{statement}
  }
\subsubsection{The Nondeterministic Statement}

\Ruledef{nondeterministic statement}{
  \Lit{||}, \Lit{(}, \Ruleref{statement}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{statement}}, \Lit{)}
  }

\subsubsection{Call and Return Statements}

\Ruledef{call statement}{
  \Ruleref{name}, \Lit{(}, \lfeed
  \OptPt{\Ruleref{expression list}}, \Lit{)}
}

\Ruledef{return statement}{
  \Lop{return}, \OptPt{\Ruleref{expression}}
  }

\subsubsection{The Specification Statement}

\Ruledef{specification statement}{
  \Lit{[}, \Ruleref{implicit operation body}, \Lit{]}
  }\nonstandard{1}



\subsubsection{Exception Handling Statements}

\Ruledef{always statement}{
  \Lop{always}, \Ruleref{statement}, \Lop{in}, \Ruleref{statement}
  }

\Ruledef{trap statement}{
  \Lop{trap}, \Ruleref{pattern bind}, \Lop{with}, \Ruleref{statement},
  \lfeed
  \Lop{in}, \Ruleref{statement}
  }

\Ruledef{recursive trap statement}{
  \Lop{tixe}, \Ruleref{traps}, \Lop{in}, \Ruleref{statement}
  }

\Ruledef{traps}{
  \Lit{\{}, \Ruleref{pattern bind}, \Lit{|->}, \Ruleref{statement}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{pattern bind}, \Lit{|->}, \Ruleref{statement}},
  \Lit{\}}
  }

\Ruledef{exit statement}{
  \Lop{exit}, \OptPt{\Ruleref{expression}}
  }

\subsubsection{The Error Statement}

  \Ruledef{error statement}{
    \Lop{error}
    }\nonstandard{1}

\subsubsection{The Identity Statement}

\Ruledef{identity statement}{
  \Lop{skip}
  }

\subsection{Patterns and Bindings}

\subsubsection{Patterns}\label{patterns2}

\Ruledef{pattern}{
  \Ruleref{pattern identifier} \dsep
  \Ruleref{match value} \dsep
  \Ruleref{set enum pattern} \dsep
  \Ruleref{set union pattern} \dsep
  \Ruleref{seq enum pattern} \dsep
  \Ruleref{seq conc pattern} \dsep
  \Ruleref{map enumeration pattern} \dsep
  \Ruleref{map muinon pattern} \dsep
  \Ruleref{tuple pattern} \dsep
  \Ruleref{record pattern}
  }

\Ruledef{pattern identifier}{
  \Ruleref{identifier} \dsepl \Lit{-}
  }

\Ruledef{match value}{
  \Lit{(}, \Ruleref{expression}, \Lit{)} \dsep
  \Ruleref{symbolic literal}
  }

\Ruledef{set enum pattern}{
  \Lit{\{}, \OptPt{\Ruleref{pattern list}}, \Lit{\}}
  }\nonstandard{1}

\Ruledef{set union pattern}{
  \Ruleref{pattern}, \Lit{union}, \Ruleref{pattern}
  }

\Ruledef{seq enum pattern}{
  \Lit{[}, \OptPt{\Ruleref{pattern list}}, \Lit{]}
  }\nonstandard{1}

\Ruledef{seq conc pattern}{
  \Ruleref{pattern}, \Lit{\char'136}, \Ruleref{pattern}
  }

\Ruledef{map enumeration pattern}{
    \Lit{\{}, [\Ruleref{maplet pattern list}], \Lit{\}}
    }

\Ruledef{maplet pattern list}{
     \Ruleref{maplet pattern}, \SeqPt{\Lit{,}, \Ruleref{maplet pattern}}
    }

\Ruledef{maplet pattern}{
    \Ruleref{pattern}, \Lit{|->}, \Ruleref{pattern}
  }

\Ruledef{map muinon pattern}{
    \Ruleref{pattern}, \Lit{\keyw{munion}}, \Ruleref{pattern}
  }

\Ruledef{tuple pattern}{
  \Lit{mk\_}, \Lit{(}, \Ruleref{pattern}, \Lit{,}, \Ruleref{pattern list}, \Lit{)}
  } 

\Ruledef{tuple pattern}{
  \Lit{mk\_}, \Lit{(}, \Ruleref{pattern}, \Lit{,}, \Ruleref{pattern list}, \Lit{)}
  } 

\Ruledef{record pattern}{
  \Lit{mk\_},\nmk \Ruleref{name}, \Lit{(}, \OptPt{\Ruleref{pattern list}}, \Lit{)}
  }
\ntext{no delimiter is allowed}

\Ruledef{pattern list}{
  \Ruleref{pattern}, \SeqPt{\Lit{,}, \Ruleref{pattern}}
  }

\subsubsection{Bindings}

\Ruledef{pattern bind}{
  \Ruleref{pattern} \dsepl \Ruleref{bind}
  }

\Ruledef{bind}{
  \Ruleref{set bind} \dsepl \Ruleref{type bind}
  }

\Ruledef{set bind}{
  \Ruleref{pattern}, \Lop{in set}, \Ruleref{expression}
  }

\Ruledef{type bind}{
  \Ruleref{pattern}, \Lit{:}, \Ruleref{type}
  }

\Ruledef{bind list}{
  \Ruleref{multiple bind}, \SeqPt{\Lit{,}, \Ruleref{multiple bind}}
  }

\Ruledef{multiple bind}{
  \Ruleref{multiple set bind} \dsep
  \Ruleref{multiple type bind}
  }

\Ruledef{multiple set bind}{
  \Ruleref{pattern list}, \Lop{in set}, \Ruleref{expression}
  }

\Ruledef{multiple type bind}{
  \Ruleref{pattern list}, \Lit{:}, \Ruleref{type}
  }

\Ruledef{type bind list}{
  \Ruleref{type bind}, \SeqPt{\Lit{,}, \Ruleref{type bind}}
  }

\section{Lexical Specification}\label{app-b}\label{ap:lexis}

\subsection{Characters}

The character set is shown in Table~\ref{charSetTable}, with the forms of
characters used in this document. Notice that this character set corresponds
exactly to the ASCII (or ISO 646) syntax.

In the \vdmsl\ standard a character is defined as:

\Ruledef{character}{
  \hyperlink{charSetTable}{plain letter} \dsep
  \hyperlink{charSetTable}{key word letter} \dsep
  \hyperlink{charSetTable}{distinguished letter} \dsep
  Greek letter \dsep
  \hyperlink{charSetTable}{digit} \dsep
  \hyperlink{charSetTable}{delimiter character} \dsep
  \hyperlink{charSetTable}{other characters} \dsep
  \Ruleref{separator}
  }

The plain letters and the keyword letters are displayed in
Table~\ref{charSetTable} (in a document the keyword letters simply use the
corresponding small letters). The distinguished letters use the
corresponding capital and lower-case
letters where the whole quote literal is preceded by
``{\tt <}'' and followed by ``{\tt >}'' (note that quote literals
can also use underscores and digits). The Greek letters can also be used
with a number sign ``{\tt \#}'' followed by the corresponding letter (this
information is used by the \LaTeX\ pretty printer such that the Greek letters
can be produced). All delimiter characters (in the ASCII version of the
standard) are listed in Table~\ref{charSetTable}. In the standard a
distinction between delimiter characters and compound delimiters are
made.
We have
chosen not to use this distinction in this presentation. Please also notice
that some of the delimiters in the mathematical syntax are keywords in the
ASCII syntax which is used here.

\begin{table}[ht]
\setlength{\tabcolsep}{3.5mm}
\setlength{\arraycolsep}{3.5mm}

\rule{\textwidth}{.5mm}
    {\tt
    \begin{tabular}{*{13}{l}} 
        % that's 13 italic columns
        \multicolumn{13}{l}{\rm plain letter:} \\
        a & b & c & d & e & f & g & h & i & j & k & l & m \\
        n & o & p & q & r & s & t & u & v & w & x & y & z \\
        A & B & C & D & E & F & G & H & I & J & K & L & M \\
        N & O & P & Q & R & S & T & U & V & W & X & Y & Z
    \end{tabular}
    }

\blankline
    {\sf  
    \begin{tabular}{*{13}{l}}
        % that's 13 keyword columns
        \multicolumn{13}{l}{\rm keyword letter:} \\
        a & b & c & d & e & f & g & h & i & j & k & l & m \\
        n & o & p & q & r & s & t & u & v & w & x & y & z
    \end{tabular}
    }

\blankline
{\tt
    \begin{tabular}{*{10}{l}}
        % that's 10 math columns
        \multicolumn{10}{l}{\mbox{{\rm delimiter character:}}} \\
          ,         & :         & ;         & =         & (         &
          )         & |         & -         & [         & ]         \\
          \{        & \}        & +         & /         & <         &
          >         & <=        & >=        & <>        &  .        \\
          \verb+*+  & ->        & +>        & ==>       & ||        &
          =>        &   <=>     & |->       & <:        & :>        \\
          <-:       & :->       & \&        & ==        & **        & 
          \verb+^+  & ++        &           &           &           \\
    \end{tabular}
}

\blankline
    \begin{tabular}{*{10}{l}}
        \multicolumn{10}{l}{digit:} \\
        {\tt 0}
        & {\tt 1} 
        & {\tt 2} 
        & {\tt 3} 
        & {\tt 4} 
        & {\tt 5}
        & {\tt 6} 
        & {\tt 7} 
        & {\tt 8} 
        & {\tt 9} 
     \end{tabular}

\blankline
    \begin{tabular}{*{10}{l}}
        \multicolumn{10}{l}{hexadecimal digit:} \\
        {\tt 0} & {\tt 1} & {\tt 2} & {\tt 3} & {\tt 4} & {\tt 5} & {\tt 6} & {\tt 7} & {\tt 8} & {\tt 9} \\
        {\tt A} & {\tt B} & {\tt C} & {\tt D} & {\tt E} & {\tt F} \\
        {\tt a} & {\tt b} & {\tt c} & {\tt d} & {\tt e} & {\tt f} 
     \end{tabular}

\blankline
    \begin{tabular}{*{8}{l}}
        \multicolumn{8}{l}{octal digit:} \\
        {\tt 0}
        & {\tt 1} 
        & {\tt 2} 
        & {\tt 3} 
        & {\tt 4} 
        & {\tt 5}
        & {\tt 6} 
        & {\tt 7} 
     \end{tabular}

\blankline
    \begin{tabular}{*{6}{l}}
        \multicolumn{6}{l}{other characters:} \\
        {\tt \_} 
        & {\tt \char'140} % `
        & {\tt \char'047} % '
        & {\tt \char'042} % ''
        & {\tt \char'100} % @
        & {\tt \~{}}
    \end{tabular}

\blankline
    \begin{tabular}{p{14cm}}   %{p{\textwidth}}
        newline: \\
        \\
        white space: \\
        \\
        These have no graphic form, but are a combination of white space
        and line break.  There are two separators: without line break
        (white space) and with line break (newline).
    \end{tabular}

\rule{\textwidth}{.5mm}
\hypertarget{charSetTable}{\caption{Character set}}
\label{charSetTable}

\end{table}

\clearpage % to force table to appear *here*


\subsection{Symbols}\label{Symbols}

The following kinds of symbols exist: keywords, delimiters,
% simple names -- these do not seem to exist anymore DJA
symbolic literals, and comments.  The transformation from characters to
symbols is given by the following rules; these use the same notation as the
syntax definition but differ in meaning in that no separators may appear
between adjacent terminals.  Where ambiguity is possible otherwise, two
consecutive symbols must be separated by a separator.

\newcommand{\Lks}[1]{\Lop{#1}\dsepl}
\newcommand{\Lksb}[1]{\Lop{#1}\dsep}
\Ruledef{keyword}{
  \Lks{abs}
  \Lks{all}
  \Lks{always}
  \Lks{and}
  \Lks{as}
  \Lks{atomic}
  \Lks{be}
  \Lks{bool}
  \Lksb{by}
  \Lks{card}
  \Lks{cases}
  \Lks{char}
  \Lks{comp}
  \Lks{compose} 
  \Lksb{conc}
  \Lks{dcl}
  \Lks{def}
  \Lks{definitions}
  \Lks{dinter} 
  \Lks{div}
  \Lksb{dlmodule}
  \Lks{do}
  \Lks{dom}
  \Lks{dunion}
  \Lks{elems}
  \Lks{else}
  \Lks{elseif}
  \Lksb{end}
  \Lks{error}
  \Lks{errs}
  \Lks{exists}
  \Lks{exists1}
  \Lks{exit} 
  \Lks{exports}
  \Lksb{ext} 
  \Lks{false} 
  \Lks{floor}
  \Lks{for} 
  \Lks{forall}
  \Lks{from}
  \Lksb{functions}
  \Lks{hd} 
  \Lks{if}
  \Lks{imports}
  \Lks{in} 
  \Lks{inds}
  \Lks{init}
  \Lksb{inmap}
  \Lks{int}
  \Lks{inter}
  \Lks{inv}
  \Lks{inverse}
  \Lksb{iota}
  \Lks{lambda}
  \Lks{len} 
  \Lks{let}
  \Lks{map}
  \Lks{measure}
  \Lks{merge} 
  \Lks{mod} 
  \Lksb{module}
  \Lks{mu}
  \Lks{munion}
  \Lks{nat}
  \Lks{nat1}
  \Lks{nil} 
  \Lks{not}
  \Lksb{of}
  \Lks{operations}
  \Lks{or}
  \Lks{others}
  \Lksb{post}
  \Lks{power} 
  \Lks{pre}
  \Lks{psubset}
  \Lks{rat}
  \Lks{rd}
  \Lks{real} 
  \Lksb{rem}
  \Lks{renamed}
  \Lks{return}
  \Lks{reverse}
  \Lks{rng}
  \Lks{seq}
  \Lksb{seq1}
  \Lks{set}
  \Lks{skip}
  \Lks{specified}
  \Lks{st}
  \Lks{state}
  \Lksb{struct}
  \Lks{subset}
  \Lks{then}
  \Lks{tixe}
  \Lks{tl}
  \Lks{to}
  \Lks{token}
  \Lksb{trap} 
  \Lks{true}
  \Lks{types}
  \Lks{undefined}
  \Lks{union}
  \Lksb{uselib}
  \Lks{values} 
  \Lks{while} 
  \Lks{with}
  \Lks{wr}
  \Lksb{yet}
  \Lop{RESULT} 
  }

\Ruledef{separator}{
  \hyperlink{charSetTable}{newline} \dsepl 
  \hyperlink{charSetTable}{white space}
  }

\Ruledef{identifier}{
  \Brack{\hyperlink{charSetTable}{plain letter} \dsepl Greek letter}, \lfeed
  \SeqPt{\Brack{\hyperlink{charSetTable}{plain letter} \dsepl Greek letter} \dsepl % \Ruleref{IS THIS RIGHT}??
    \hyperlink{charSetTable}{digit}      \dsepl
    \Lit{'}  \dsepl
    \Lit{\_}
    }
  }

\medskip


\noindent %Note that the hyphen which can be used in identifiers is written
%as a low line (also known as an underscore ``\_''), whereas it is
%translated to ``-'' in the mathematical syntax.
All identifiers beginning with one of the reserved prefixes are
reserved: \keyw{init\_}, \keyw{inv\_}, \keyw{is\_}, \keyw{mk\_},
\keyw{post\_} and \keyw{pre\_}.

\Ruledef{type variable identifier}{
  \Lit{@}, \Ruleref{identifier}
  }

\Ruledef{is basic type}{
  \Lop{is\_}, 
  \Brack{%
    \Lop{bool} \dsepl
    \Lop{nat} \dsepl 
    \Lop{nat1} \dsepl 
    \Lop{int} \dsepl 
    \Lop{rat} \dsep 
    \Lop{real} \dsepl
    \Lop{char} \dsepl
    \Lop{token}
    }
  }

\Ruledef{symbolic literal}{
  \Ruleref{numeric literal} \dsepl
  \Ruleref{boolean literal} \dsep
  \Ruleref{nil literal} \dsepl
  \Ruleref{character literal} \dsepl
  \Ruleref{text literal} \dsep
  \Ruleref{quote literal}
  }

\Ruledef{numeral}{
  \hyperlink{charSetTable}{digit}, \SeqPt{\hyperlink{charSetTable}{digit}}
  }

\Ruledef{numeric literal}{
  \hyperlink{charSetTable}{decimal literal} \dsepl \hyperlink{charSetTable}{hexadecimal literal}
  }

\Ruledef{exponent}{
  \Brack{\Lit{E} \dsepl \Lit{e}},
  \OptPt{\Lit{+} \dsepl \Lit{-}},
  \Ruleref{numeral}
  }

\Ruledef{decimal literal}{
  \Ruleref{numeral},
  \OptPt{\Lit{.}, \hyperlink{charSetTable}{digit}, \SeqPt{\hyperlink{charSetTable}{digit}}},
  \OptPt{\Ruleref{exponent}}
}

\Ruledef{hexadecimal literal}{
  \Brack{\Lit{0x} \dsepl \Lit{0X}}, \hyperlink{charSetTable}{hexadecimal digit}, \SeqPt{\hyperlink{charSetTable}{hexadecimal digit}}
}

\Ruledef{boolean literal}{
  \Lop{true} \dsepl \Lop{false}
  }

\Ruledef{nil literal}{
  \Lop{nil}
  }

\Ruledef{character literal}{
  \Lit{\mbox{\,}'\mbox{\,}}, \Ruleref{character} \dsepl 
  \Ruleref{escape sequence} \dsep 
  \Ruleref{multi character}, 
  \Lit{\mbox{\,}'\mbox{\,}}
  }\nonstandard{1}

\Ruledef{escape sequence}{
  \Lit{\char'134\char'134} \dsepl \Lit{{\char'134}r} \dsepl
  \Lit{{\char'134}n} \dsepl \Lit{{\char'134}t} \dsepl
  \Lit{{\char'134}f} \dsepl \Lit{{\char'134}e} \dsepl \Lit{{\char'134}a} \dsep
  \Lit{{\char'134}x} \hyperlink{charSetTable}{hexadecimal digit},\hyperlink{charSetTable}{hexadecimal digit} \dsepl
  \Lit{{\char'134}c} \Ruleref{character} \dsep
  \Lit{{\char'134}} \hyperlink{charSetTable}{octal digit}, \hyperlink{charSetTable}{octal digit}, \hyperlink{charSetTable}{octal digit} \dsep
  \Lit{{\char'134}"} \dsepl
  \Lit{{\char'134}'} \dsepl
  }

\Ruledef{multi character}{Greek letter \dsep
   \Lit{<=} \dsepl \Lit{>=} \dsepl \Lit{<>} \dsepl \Lit{->} \dsepl
   \Lit{+>} \dsepl \Lit{==>} \dsepl \Lit{||} \dsep \Lit{=>} \dsepl
   \Lit{<=>} \dsepl \Lit{|->} \dsepl \Lit{<:} \dsepl \Lit{:>} \dsepl
   \Lit{<-:} \dsep \Lit{:->} \dsepl \Lit{==} \dsepl \Lit{**} \dsepl
   \Lit{++}}  

\Ruledef{text literal}{
  \Lit{\mbox{\,}"\mbox{\,}},
  \SeqPt{%
%    \Lit{\mbox{\,}"\mbox{\,}"\mbox{\,}}\dsepl%  was , - changed by br!
%    character -- \Brack{\Lit{\mbox{\,}"\mbox{\,}}\dsepl newline}
     \Lit{\mbox{\,}"\mbox{\,}"\mbox{\,}}\dsepl
     \Ruleref{character} \dsepl \Ruleref{escape sequence}
    },
  \Lit{\mbox{\,}"\mbox{\,}}
  }

\Ruledef{quote literal}{
  \hyperlink{charSetTable}{distinguished letter}, \lfeed
  \SeqPt{\Lit{\_} \dsepl \hyperlink{charSetTable}{distinguished letter}
   \dsepl \hyperlink{charSetTable}{digit}}% \Ruleref{M30} (\Ruleref{hyphen allowed})
  }

\Ruledef{Single-line comment}{
  \Lit{--}, \SeqPt{\Ruleref{character} -- \hyperlink{charSetTable}{newline}}, \hyperlink{charSetTable}{newline}
  }


The escape sequences given above are to be interpreted as follows:

\begin{center}
\begin{tabular}{ll}\hline
Sequence & Interpretation\\ \hline
  \Lit{\char'134\char'134} & backslash character\\
  \Lit{{\char'134}r}       & return character\\
  \Lit{{\char'134}n}       & newline character\\
  \Lit{{\char'134}t}       & tab character\\
  \Lit{{\char'134}f}       & formfeed character\\
  \Lit{{\char'134}e}       & escape character\\
  \Lit{{\char'134}a}       & alarm (bell)\\
  \Lit{{\char'134}x} hexadecimal digit, hexadecimal digit
                           & hex representation of character\\
                           & (e.g. \texttt{{\char'134}x41} is `A')\\
  \Lit{{\char'134}c} character 
                           & control character\\
                           & (e.g. \texttt{{\char'134}c A} $\equiv$ 
                                    \texttt{{\char'134}x01})\\
  \Lit{{\char'134}} octal digit, octal digit, octal digit 
                           & octal representation of character\\
  \Lit{{\char'134}{\char'042}}       & the \texttt{{\char'042}} character\\
  \Lit{{\char'134}'}       & the \verb+'+ character \\ \hline
\end{tabular}
\end{center}

\newpage
\section{Operator Precedence}\label{app-c}

The precedence ordering for operators in the concrete syntax is defined
using a two-level approach: operators are divided into families, and an
upper-level precedence ordering, $>$, is given for the families, such that
if families $F\sb{1}$ and $F\sb{2}$ satisfy

\begin{quote}
$F\sb{1} > F\sb{2}$
\end{quote}

\noindent then every operator in the family $F\sb{1}$ is of a higher precedence
than every operator in the family $F\sb{2}$.

The relative precedences of the operators within families is determined by
considering type information, and this is used to resolve ambiguity. The
type constructors are treated separately, and are not placed in a
precedence ordering with the other operators.

There are six families of operators, namely Combinators, Applicators,
Evaluators, Relations, Connectives and Constructors:

\begin{description}%{Connectivesxx}
\item[Combinators:] Operations that allow function and mapping values to be
  combined, and function, mapping and numeric values to be iterated.

\item[Applicators:] Function application, field selection, sequence
  indexing, etc.

\item[Evaluators:] Operators that are non-predicates.

\item[Relations:] Operators that are relations.

\item[Connectives:] The logical connectives.

\item[Constructors:] Operators that are used, implicitly or explicitly, in
  the construction of expressions; e.g.  \keyw{if-then-elseif-else}, `{\tt
    |->}', `\ldots', etc.
\end{description}

\noindent The precedence ordering on the families is:

\begin{quote}
$\mbox{\small combinators} >
\mbox{\small applicators} >
\mbox{\small evaluators}  >
\mbox{\small relations}   >
\mbox{\small connectives} >
\mbox{\small constructors}$
\end{quote}

\subsection{The Family of Combinators}

These combinators have the highest family priority.

\Ruledef{combinator}{
  \Ruleref{iterate} \dsepl \Ruleref{composition}
  }

\Ruledef{iterate}{
  \Lit{**}
  }

\Ruledef{composition}{
  \Lop{comp}
  }

\blankline
\begin{center}
  \begin{tabular}{cc}
    \hline
    precedence level & combinator \\
    \hline
    1       & \keyw{comp}     \\
    2       & \keyw{iterate}  \\
    \hline
  \end{tabular}
\end{center}

\subsection{The Family of Applicators}

All applicators have equal precedence.

\Ruledef{applicator}{
  \Ruleref{subsequence}
% \dsep \Ruleref{tuple constructor}
  \dsep \Ruleref{apply}
  \dsep \Ruleref{function type instantiation}
  \dsep \Ruleref{field select}
  }

\Rule{subsequence}{
  \Ruleref{expression}, \Lit{(}, \Ruleref{expression}, \Lit{,}, \Lit{\Range},
  \Lit{,}, \lfeed
  \Ruleref{expression}, \Lit{)}
  }

\Rule{apply}{
  \Ruleref{expression}, \Lit{(}, \OptPt{\Ruleref{expression list}}, \Lit{)}
  }

\Rule{function type instantiation}{
  \Ruleref{expression}, \Lit{[}, \Ruleref{type}, \SeqPt{\Lit{,}, \Ruleref{type}}, \Lit{]}
  }

\Rule{field select}{
  \Ruleref{expression}, \Lit{.}, \Ruleref{identifier} 
  }

\subsection{The Family of Evaluators}

The family of evaluators is divided into nine groups, according to the type
of expression they are used in.

\Ruledef{evaluator}{
  \Ruleref{arithmetic prefix operator} \dsep
  \Ruleref{set prefix operator} \dsep
  \Ruleref{sequence prefix operator} \dsep
  \Ruleref{map prefix operator} \dsep
  \Ruleref{map inverse} \dsep
  \Ruleref{arithmetic infix operator} \dsep
  \Ruleref{set infix operator} \dsep
  \Ruleref{sequence infix operator} \dsep
  \Ruleref{map infix operator}
  }

\Ruledef{arithmetic prefix operator}{
  \Lit{+} \dsepl
  \Lit{-} \dsepl
  \Lop{abs} \dsepl
  \Lop{floor}
  }

\Ruledef{set prefix operator}{
  \Lop{card} \dsepl
  \Lop{power} \dsepl
  \Lop{dunion} \dsepl
  \Lop{dinter}
  }

\Ruledef{sequence prefix operator}{
  \Lop{hd} \dsepl
  \Lop{tl} \dsepl
  \Lop{len} \dsep
  \Lop{inds} \dsepl
  \Lop{elems} \dsepl
  \Lop{conc}
  }

\Ruledef{map prefix operator}{
  \Lop{dom} \dsepl
  \Lop{rng} \dsepl
  \Lop{merge} \dsepl
  \Lop{inverse}
  }

\Ruledef{arithmetic infix operator}{
  \Lit{+} \dsepl
  \Lit{-} \dsepl
  \Lit{*} \dsepl
  \Lit{/} \dsepl
  \Lop{rem} \dsepl
  \Lop{mod} \dsepl
  \Lop{div}
  }

\Ruledef{set infix operator}{
  \Lop{union} \dsepl
  \Lop{inter} \dsepl
  \Lit{\char'134}
  }

\Ruledef{sequence infix operator}{
  \Lit{\char'136}
  }

\Ruledef{map infix operator}{
  \Lop{munion} \dsepl
  \Lit{++} \dsepl
  \Lit{<:} \dsepl
  \Lit{<-:} \dsepl
  \Lit{:>} \dsepl
  \Lit{:->}
  }

\noindent The precedence ordering follows a pattern of analogous operators. The
family is defined in the following table.

\blankline
\begin{center}
  \begin{tabular}{ccccc}
    \hline
    precedence level & arithmetic       & set                   & map                    & sequence \\
    1                & {\tt + -}        & \keyw{union} \verb+\+ & \keyw{munion} {\tt ++} & \verb+^+ \\
    2                & \verb+*+ {\tt /} & \keyw{inter}          &                        & \\
                     & \keyw{rem}       &                       &                        & \\
                     & \keyw{mod}       &                       &                        & \\
                     & \keyw{div}       &                       &                        & \\
    3                &                  &                       & \keyw{inverse}         & \\
    4                &                  &                       & {\tt <: <-:}           & \\
    5                &                  &                       & {\tt :> :->}           & \\
    6                & (unary) {\tt +}  & \keyw{card}           & \keyw{dom}             & \keyw{len}         \\
                     & (unary) {\tt -}  & \keyw{power}          & \keyw{rng}             & \keyw{elems}       \\
                     & \keyw{abs}       & \keyw{dinter}         & \keyw{merge}           & \keyw{hd} \keyw{tl} \\
                     & \keyw{floor}     & \keyw{dunion}         &                        & \keyw{conc}        \\
                     &                  &                       &                        & \keyw{inds}        \\
    \hline
  \end{tabular}
\end{center}

\subsection{The Family of Relations}

This family includes all the relational operators whose results are of type
\keyw{bool}.

\Ruledef{relation}{
  \Ruleref{relational infix operator} \dsepl \Ruleref{set relational operator}
  }

\Ruledef{relational infix operator}{
  \Lit{=} \dsepl
  \Lit{<>} \dsepl
  \Lit{<} \dsepl
  \Lit{<=} \dsepl
  \Lit{>} \dsepl
  \Lit{>=}
  }

\Ruledef{set relational operator}{
  \Lop{subset} \dsepl
  \Lop{psubset} \dsepl
  \Lop{in set} \dsepl
  \Lop{not in set}
  }

\blankline
\begin{center}
  \begin{tabular}{ccc}
    \hline
    precedence level & relation \\
    \hline
    1       & {\tt <=}        & {\tt <}         \\
            & {\tt >=}        & {\tt >}         \\
            & {\tt =}         & {\tt <>}        \\
            & \keyw{subset}   & \keyw{psubset}  \\
            & \keyw{in set}   & \keyw{not in set}\\
    \hline \\
  \end{tabular}
\end{center}

\noindent All operators in the Relations family have equal precedence.  Typing
dictates that there is no meaningful way of using them adjacently.

\subsection{The Family of Connectives}

This family includes all the logical operators whose result is of type
\keyw{bool}.

\Ruledef{connective}{
  \Ruleref{logical prefix operator} \dsepl \Ruleref{logical infix operator}
  }

\Ruledef{logical prefix operator}{
  \Lop{not}
  }

\Ruledef{logical infix operator}{
  \Lop{and} \dsepl
  \Lop{or} \dsepl
  \Lit{=>} \dsepl
  \Lit{<=>}
  }

\blankline
\begin{center}
  \begin{tabular}{cc}
    \hline
    precedence level & connective \\ \hline
    1                & {\tt <=>}      \\
    2                & {\tt =>}  \\
    3                & \keyw{or}       \\
    4                & \keyw{and}     \\
    5                & \keyw{not}      \\
    \hline
  \end{tabular}
\end{center}

\subsection{The Family of Constructors}

This family includes all the operators used to construct a value.  Their
priority is given either by brackets, which are an implicit part of the
operator, or by the syntax.

\subsection{Grouping}\label{grouping}

The grouping of operands of the binary operators are as follows:

\begin{list}{\bf no label!}{%
    \def\mylabel#1{\hspace\labelsep #1\hfill}
    \let\makelabel\mylabel
    \settowidth{\labelwidth}{Constructors: }
    \setlength{\leftmargin}{\labelwidth}
    \addtolength{\leftmargin}{2\labelsep}
    }
\item[Combinators:] Right grouping.

\item[Applicators:] Left grouping.

\item[Connectives:] The `{\tt =>}' operator has right grouping.  The other
  operators are associative and therefore right and left grouping are
  equivalent.
  
\item[Evaluators:] Left grouping\footnote{Except the ``map domain restrict
    to'' and the ``map domain restrict by'' operators which have a right
    grouping. This is not standard.}.

\item[Relations:] No grouping, as it has no meaning.

\item[Constructors:] No grouping, as it has no meaning.
\end{list}

\subsection{The Type Operators}\label{preceedence}

Type operators have their own separate precedence ordering, as follows:
\begin{enumerate}
\item Function types: {\tt ->, +>} (right grouping).

\item Union type: {\tt |} (left grouping).

\item Other binary type operators: \verb+*+ (no grouping).

\item Map types: \keyw{map} \ldots \keyw{to} \ldots and \keyw{inmap} \ldots
  \keyw{to} \ldots\ (right grouping).\nonstandard{0}

\item Unary type operators: \keyw{seq of}, \keyw{seq1 of}, \keyw{set of}.
\end{enumerate}

\section{Differences between the two Concrete Syntaxes}\label{sec:diff}

Below is a list of the symbols which are different in the mathematical
syntax and the ASCII syntax:\\
%\samepage
%\begin{center}
\begin{longtable}{|l|l|}\hline
 \ldots$\Gmap$\ldots & {\tt map ... to ...} \kill
 Mathematical syntax & ASCII syntax  \\ \hline\hline
\endhead
\hline
\endfoot
 $\Dot$            & {\tt\char'046} \\
 $\Mult$              & {\tt *}        \\
 $\Le$            & {\tt <=}        \\
 $\Ge$            & {\tt >=}        \\
 $\Neq$            & {\tt <>}       \\
 $\Oto$            & {\tt ==>}      \\
 $\To$             & {\tt ->}       \\
 $\Implies$     & {\tt =>}          \\
 $\Equiv$ & {\tt <=>}               \\
 $\Mapsto$         & {\tt |->}       \\
 $\Fdef$           & {\tt ==}        \\
 $\Iterate$        & {\tt **}        \\
 $\Override$       & {\tt ++}        \\
 $\Mapmerge$         & {\tt munion} \\
 $\Dto$            & {\tt <:}                           \\
 $\Rto$            & {\tt :>}                          \\
 $\Dby$            & {\tt <-:}                          \\
 $\Rby$            & {\tt :->}                         \\
 $\Psubset$         & {\tt psubset}                     \\
 $\Subset$       & {\tt subset}                         \\
 $\Sconc$          & {\tt\char'136}                     \\
 $\Dinter$          & {\tt dinter}                      \\
 $\Dunion$          & {\tt dunion}                      \\
 $\Power$          & {\tt power}                        \\
 \ldots$\Set$            & {\tt set of ...}                    \\
 \ldots$\Seq*$              & {\tt seq of ...}                 \\
 \ldots$\Seq+$              & {\tt seq1 of ...}                 \\
 \ldots$\Gmap$\ldots           & {\tt map ... to ...}                 \\
 \ldots$\Bmap$\ldots           & {\tt inmap ... to ...}                 \\
 $\Muop$           & {\tt mu}                           \\
 $\Bool$           & {\tt bool}                         \\
 $\Nat$            & {\tt nat}                          \\
 $\Int$            & {\tt int}                          \\
 $\Real$           & {\tt real}                         \\
 $\Not$            & {\tt not}                          \\
 $\Inter$          & {\tt inter}                        \\
 $\Union$          & {\tt union}                        \\
 $\In$             & {\tt in set}                       \\
 $\Notin$          & {\tt not in set}                   \\
 $\And$            & {\tt and}                          \\
 $\Or$             & {\tt or}                           \\
 $\All$            & {\tt forall}                       \\
 $\Exists$         & {\tt exists}                       \\
 $\Exists!$        & {\tt exists1}                      \\
 $\Lambdaop$       & {\tt lambda} \\
 $\Iotaop$         & {\tt iota} \\
 $\ldots\Inverse$  & {\tt inverse ...} \\
%#ifdef VDMPP
% $\kWeave$         & {\tt w\_} \\
% $\kTraceset$      & {\tt t\_} \\
% $\kAlphabet$      & {\tt a\_} \\
%#endif VDMPP
\hline
\end{longtable}
% \end{center}

\newpage

\section{Standard Libraries}\label{stdlib}\index{Standard libraries}\index{library}\index{Math}\index{IO}

\subsection{Math Library}
%When more than just the Math is available name should be given to each library by \subsubsection*

The Math library is defined in the 
\ifthenelse{\boolean{VDMsl}}{{\tt math.vdm}}{{\tt math.vpp}} 
file.  It provides the following math functions:

\begin{center}
\begin{tabular}{|l|l|p{6cm}|}\hline
\multicolumn{2}{|l|}{\bf Functions} & \bf Pre-conditions\\ \hline
\verb/sin: real +> real/ & Sine &  \index{Sine} \\ \hline
\verb/cos: real +> real/ & Cosine &  \index{Cosine} \\ \hline
\verb/tan: real -> real/ & Tangent & The argument is not an integer multiple 
                                     of $^\pi\!/\!_2$ \index{Tangent} \\ \hline 
\verb/cot: real -> real/ & Cotagent & The argument is not an integer multiple 
                                      of $\pi$ \index{Cotangent} \\ \hline
\verb/asin: real -> real/ & Inverse sine & The argument is not in the interval
                                           from -1 to 1 (both inclusive). 
                                           \index{Inverse sine}\\ \hline
\verb/acos: real -> real/ & Inverse cosine & The argument is not in the 
                                      interval from -1 to 1 (both inclusive). 
                                      \index{Inverse cosine}\\ \hline
\verb/atan:real +> real/ & Inverse tangent & \index{Inverse tangent}\\ \hline
\verb/sqrt: real -> real/ & Square root & The argument is non-negative. 
                                          \index{Square root}\\ \hline
\end{tabular}
\end{center}

and the value:

\begin{quote}
\texttt{pi} = 3.14159265358979323846\index{pi}
\end{quote}

If the functions are applied with arguments that violate possible
pre-conditions they will return values that are not proper
\vdmslpp{\vdmsl}{\vdmpp} values, {\tt Inf} (infinity, e.g.\ {\tt
  tan(pi/2)}) and {\tt NaN} (not a number, e.g.\ {\tt sqrt (-1)}).


% \subsubsection{Using the Math Standard Library with Flat Specifications}%
% \index{Math!use with flat specifications}
% 
% To use the standard library in a flat specification, the library file 
% \begin{quote}
% \verb+$TOOLBOXHOME/stdlib/mathflat.vdm+
% \end{quote}
% should be added to the
% current project. Functions from the standard library may then be
% accessed directly as the example below demonstrates:
% \begin{alltt}
% \keyw{types}
% 
% coord :: x : \keyw{real}
%          y : \keyw{real}
% 
% \keyw{functions}
% 
% -- euclidean metric between two points
% dist : coord * coord -> \keyw{real}
% dist (c1,c2) ==
%   sqrt((c1.x - c2.x) * (c1.x - c2.x) +
%        (c1.y - c2.y) * (c1.y - c2.y));
% 
% 
% -- outputs angle of line joining coord with origin
% -- from horizontal, in degrees
% angle : coord -> \keyw{real}
% angle (c) ==
%   atan (c.y / c.x) * 360 / ( 2 * pi)
% \end{alltt}
% 
% \subsubsection{Using the Math Standard Library with Modular Specifications}%
% \index{Math!use with modular specifications}
% 
To use the standard library in a modular specification, the library file 
\begin{quote}
\verb+$TOOLBOXHOME/stdlib/math.vdm+
\end{quote}
should be added to the
current project. This contains the module \texttt{MATH}. Functions
from this library may then be accessed in the usual way, by importing
them into modules as needed. The example below demonstrates this:

\begin{alltt}
\keyw{module} UseLib

  \keyw{imports}
    \keyw{from} MATH \keyw{all}

  \keyw{definitions}

  \keyw{types}

  coord :: x : \keyw{real}
           y : \keyw{real}

  \keyw{functions}

  -- euclidean metric between two points
  dist : coord * coord -> \keyw{real}
  dist (c1,c2) ==
    MATH`sqrt((c1.x - c2.x) * (c1.x - c2.x) +
              (c1.y - c2.y) * (c1.y - c2.y));


  -- outputs angle of line joining coord with origin
  -- from horizontal, in degrees
  angle : coord -> \keyw{real}
  angle (c) ==
    MATH`atan (c.y / c.x) * 360 / ( 2 * MATH`pi)

\keyw{end} UseLib
\end{alltt}


\subsection{IO Library}\index{IO}

The IO library is defined in the 
\ifthenelse{\boolean{VDMsl}}{{\tt io.vdm}}{{\tt io.vpp}} file, and it
is located
in the directory \verb+$TOOLBOXHOME/stdlib/+.  
It provides the IO functions and
operations listed below. Each read/write function or operation returns
a boolean 
value (or a tuple with a boolean component) representing the success
(\keyw{true}) or failure (\keyw{false}) of the corresponding IO
action. 

\begin{description}
\item[\texttt{writeval[@p]:[@p] +> bool}] \mbox{}\\
  This function writes a VDM value in ASCII format to standard
  output. There is no pre-condition.
\item[\texttt{fwriteval[@p]:seq1 of char * @p * filedirective +>
    bool}] \mbox{}\\
  This function writes a VDM value (the second argument) in ASCII
  format to a file whose  
  name is specified by the character string in the first argument. The
  third parameter has type \texttt{filedirective} which is defined to be:
  \begin{verbatim}
    filedirective = <start>|<append> 
  \end{verbatim}
  If \texttt{<start>} is used, the existing file (if any) is
  overwritten; if \texttt{<append>} is used, output is appended to the
  existing file and a new file is created if one does not already
  exist. There is no pre-condition.
\item[\texttt{freadval[@p]:seq1 of char +> bool * [@p]}] \mbox{}\\
  This function reads a VDM value in ASCII format from the file
  specified by the character string in the first argument. There is no
  pre-condition. The function returns a pair, the first component
  indicating the success of the read and the second component
  indicating the value read if the read was successful.
\item[\texttt{echo: seq of char ==> bool}] \mbox{}\\
  This operation writes the given text to standard output. Surrounding
  double quotes will be stripped, backslashed characters will be
  interpreted as \hyperlink{rule:escape sequence}{escape sequences}. There is no
  pre-condition. 
\item[\texttt{fecho: seq of char * seq of char * [filedirective] ==> bool}]
  \mbox{}\\
  This operation is similar to \texttt{echo} but writes text to a file
  rather than to standard output. The \texttt{filedirective} parameter
  should be interpreted as for \texttt{fwriteval}. The pre-condition
  for this operation is that if an empty string
  is given for the filename, then the \texttt{[filedirective]}
  argument should be \keyw{nil} since the text is written to standard
  output. 
\item[\texttt{ferror:()  ==> seq of char}]
  The read/write functions and operations return false if an error
  occurs. In this case an internal error string will be set. This
  operation returns this string and sets it to \texttt{""}.
\end{description}

As an example of the use of the IO library, consider a
web server which maintains a log of page hits:

\begin{alltt}
  module LoggingWebServer

    \keyw{imports}
      \keyw{from} IO \keyw{all}

    \keyw{exports} \keyw{all}

    \keyw{definitions}

    \keyw{values}
      logfilename : seq1 of char = "serverlog"

    \keyw{functions}
      URLtoString : URL -> \keyw{seq} \keyw{of} \keyw{char}
      URLtoString = ...

    \keyw{operations}
      RetrieveURL : URL ==> File
      RetrieveURL(url) ==
        (\keyw{def} - = IO`fecho(logfilename, URLtoString(url)^\verb+"\n"+, <append>);
         ... 
        );

      ResetLog : () ==> \keyw{bool}
      ResetLog() ==
        IO`fecho(logfilename,\verb+"\n"+,<start>)

  \keyw{end} LoggingWebServer
\end{alltt}

\subsection{VDMUtil Library}\index{VDMUtil}

The VDMUtil library is defined in the 
\ifthenelse{\boolean{VDMsl}}{{\tt vdmutil.vdm}}{{\tt vdmutil.vpp}} file, and it 
is located 
in the directory \verb+$TOOLBOXHOME/stdlib/+.  
It provides the different kind of VDM utility functions and 
operations listed below. 

\begin{description}
\item[\texttt{set2seq[@T]:set of @T +> seq of @T}] \mbox{}\\
This utility function enables an easy conversion of a set of elements without 
ordering into a sequence with an arbitrary ordering of the elements.
\item[\texttt{get\_file\_pos: () +> [seq of char * nat * nat * seq of char * seq of char]}] \mbox{}\\
This function is able to extract context information (file name, line 
number, class name and function/operation name) for a particular part 
of the source text.
\item[\texttt{val2seq\_of\_char[@T]: @T +> seq of char}] \mbox{}\\
This function is able to transform a VDM value into a string.
\item[\texttt{seq\_of\_char2val[@p]:seq1 of char -> bool * [@p]}] \mbox{}\\
This function is able to transform a string (a sequence of chars) into 
a VDM value.
\end{description}

\begin{alltt}
\keyw{module} VDMUtil

-- 	VDMTools STANDARD LIBRARY: VDMUtil
--      --------------------------------------------
-- 
-- Standard library for the VDMTools Interpreter. When the interpreter
-- evaluates the preliminary functions/operations in this file,
-- corresponding internal functions is called instead of issuing a run
-- time error. Signatures should not be changed, as well as name of
-- module (VDM-SL) or class (VDM++). Pre/post conditions is 
-- fully user customisable. 
-- Dont care's may NOT be used in the parameter lists.

\keyw{exports all
definitions
functions}
-- Converts a set argument into a sequence in non-deterministic order.
set2seq[@T] : \keyw{set of} @T +> \keyw{seq of} @T
set2seq(x) == \keyw{is not yet specified};

-- Returns a context information tuple which represents
-- (file_name * line_num * column_num * module_name * fnop_name) 
-- of corresponding source text
get_file_pos : () +> [ \keyw{seq of char} * \keyw{nat} * \keyw{nat} * \keyw{seq of char} * \keyw{seq of char} ]
get_file_pos() == \keyw{is not yet specified};

-- Converts a VDM value into a seq of char.
val2seq_of_char[@T] : @T +> \keyw{seq of char}
val2seq_of_char(x) == \keyw{is not yet specified};

-- converts VDM value in ASCII format into a VDM value
-- RESULT.#1 = false implies a conversion failure
seq_of_char2val[@p]:\keyw{seq1 of char} -> \keyw{bool} * [@p]
seq_of_char2val(s) ==
  \keyw{is not yet specified}
  \keyw{post let mk}_(b,t) = \keyw{RESULT in not} b => t = \keyw{nil};

\keyw{end} VDMUtil
\end{alltt}

\newpage
\addcontentsline{toc}{section}{Index}
\printindex

\end{document}


