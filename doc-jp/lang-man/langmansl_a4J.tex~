%%
%% Toolbox Language Manual
%% $Id: lang_man.tex,v 1.16 2006/04/19 10:26:51 vdmtools Exp $
%% 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PDF compatibility code. 

\makeatletter
\newif\ifpdflatex@
\ifx\pdftexversion\@undefined
\pdflatex@false
%\message{Not using pdf}
\else
\pdflatex@true
%\message{Using pdf}
\fi

\newcommand{\latexpdf}[2]{
  \ifpdflatex@ #1
  \else #2
  \fi
}

\newcommand{\latexorpdf}[2]{
  \ifpdflatex@ #2
  \else #1
  \fi
}

\newcommand{\pformat}{a4paper}

\makeatother

\newcommand{\RuleTarget}[1]{\hypertarget{rule:#1}{}}
\newcommand{\Ruledef}[2]
{
  \RuleTarget{#1}\Rule{#1}{#2}%
  }
\newcommand{\Ruleref}[1]{
  \hyperlink{rule:#1}{#1}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\latexorpdf{
\documentclass[\pformat,12pt]{jarticle}
}{
% pdftex option is used by graphic[sx],hyperref,toolbox.sty
\documentclass[\pformat,pdftex,12pt]{jarticle}
}

\usepackage{toolbox}
\usepackage{vdmsl-2e}
\usepackage{makeidx}
\usepackage{alltt}
%\usepackage{epsfig}
%\usepackage{here}
\usepackage{array}
\usepackage{longtable}
\usepackage{ifthen}
% plainpages=false: avoid warning
%   destination with the same identifier already exists
%   but it do not seem to work a the first pages

%\ifnum 42146=\euc"A4A2 \AtBeginDvi{\special{pdf:tounicode EUC-UCS2}}\else
%\AtBeginDvi{\special{pdf:tounicode 90ms-RKSJ-UCS2}}\fi
\usepackage{atbegshi}
\ifnum
  42146=\euc"A4A2 \AtBeginShipoutFirst{\special{pdf:tounicode EUC-UCS2}}
\else
  \AtBeginShipoutFirst{\special{pdf:tounicode 90ms-RKSJ-UCS2}}
\fi

\usepackage[dvipdfm,bookmarks=true,bookmarksnumbered=true,colorlinks,plainpages=true]{hyperref}


\newcommand{\vdmslpp}[2]{%
#1
}

\newcommand{\vdmsl}{VDM-SL}
\newcommand{\vdmpp}{VDM++}
\newcommand{\Index}[1]{#1\index{#1}}

% The use of /VDMPP ifdef's have basicly been exchanged with the
% use of LaTeX ifthenelse's.  For this two LaTeX boolean value  and
% VDMpp have been defined  (Lowercase p's are used to avoid conflict with
% the VDMPP environment variable.  The typical use are:
%   \ifthenelse{\boolean{VDMsl}}{vdmsl-text}{vdmpp-text}
%   \ifthenelse{\boolean{VDMsl}}{vdmsl-text}{}
%   \ifthenelse{\boolean{VDMpp}}{vdmpp-text}{}
% The advantage of this as opposed to ifdef's is that within a general
% paragraph specific VDM-SL and VDM++ parts can be distinguished without
% problematic empty lines.
% 
% The values are initialised such that exactly one of the values is true
% and the other is false.  This should hopefully avoid strange behaviour
% due to possible preprossing errors.  The default case is VDM-SL.
\newboolean{VDMsl}
\setboolean{VDMsl}{true}
\newboolean{VDMpp}
\setboolean{VDMpp}{false}
\setboolean{VDMsl}{true}
\setboolean{VDMpp}{false}

%\latexpdf{\usepackage[pdftex,colorlinks=true,bookmarks=true]{hyperref}}{}

\newcommand{\MYEQUIV}{$\equiv$}
\newlength{\nonstandlen}
\newcommand{\nonstandard}[1]{%
\setlength{\nonstandlen}{#1\baselineskip}%
  \marginpar{\hspace*{-3mm}\raisebox{\nonstandlen}[0pt][0pt]{\fbox{{\footnotesize Non standard}}}}%
}
\newenvironment{TypeSemantics}{\begin{longtable}[r]{|p{3.5cm}|p{9cm}|}\hline%
  演算子名称 & 意味記述 \\ \hline\hline \endhead}% 
  {\hline\end{longtable}}
  
%\renewcommand{\vdmpp}{{\small VDM}$^{++}$}

\makeatletter
% ------------- TOC manipulation ------------
\def\docglbldepth{1}
%\setcounter{secnumdepth}{\docglbldepth}
%\setcounter{tocdepth}{\docglbldepth}
\def\@pnumwidth{3.0em}
% more space for for >10 subsections
%\def\l@section{\@dottedtocline{1}{1.5em}{3.1em}}
\def\l@subsection{\@dottedtocline{2}{1.5em}{2.8em}}
%\def\l@subsubsection{\@dottedtocline{3}{4.3em}{3.6em}}
%\def\l@paragraph{\@dottedtocline{4}{7.9em}{4.1em}}
%\def\l@subparagraph{\@dottedtocline{5}{10em}{5em}}
\makeatother

\makeindex
%\latexpdf{\pdfinfo{
% /Title (The IFAD VDM-SL Language)
% /Author (The VDM Tool Group, The Institute of Applied Computer Science)
%}}{}


\begin{document}
%\latexpdf{\pdfcatalog{/PageMode /UseOutlines} openaction goto page 1 {/Fit}}{}


\vdmtoolsmanualscsk{VDM-SL 言語マニュアル}{2.0}


\newcommand{\Lit}[1]{`{\tt #1}\Quote}
\newcommand{\Rule}[2]{
  \begin{quote}\begin{tabbing}
    #1\index{#1}\ \ \= = \ \ \= #2  ; %    Adds production rule to index
    
  \end{tabbing}\end{quote}
  }
\newcommand{\SeqPt}[1]{\{\ #1\ \}}
\newcommand{\lfeed}{\\ \> \>}
\newcommand{\dsepl}{\ $|$\ }
\newcommand{\dsep}{\\ \> $|$ \>}
\newcommand{\Lop}[1]{`{\sf #1}\Quote}
\newcommand{\blankline}{\vspace{\baselineskip}}
\newcommand{\Brack}[1]{(\ #1\ )}
\newcommand{\nmk}{\footnotemark}
\newcommand{\ntext}[1]{\footnotetext{{\bf Note: } #1}}
\newlength{\kwlen}
\newcommand{\Keyw}[1]{\settowidth{\kwlen}{\tt #1}\makebox[\kwlen][l]{\sf
    #1}}
\newcommand{\keyw}[1]{{\sf #1}}
\newcommand{\id}[1]{{\tt #1}}
\newcommand{\metaiv}[1]{\begin{alltt}\input{#1}\end{alltt}}

\newcommand{\OptPt}[1]{[\ #1\ ]}
\newcommand{\MAP}[2]{\kw{map }#1\kw{ to }#2}
\newcommand{\INMAP}[2]{\kw{inmap }#1\kw{ to }#2}
\newcommand{\SEQ}[1]{\kw{seq of }#1}
\newcommand{\NSEQ}[1]{\kw{seq1 of }#1}
\newcommand{\SET}[1]{\kw{set of }#1}
\newcommand{\PROD}[2]{#1 * #2}
\newcommand{\TO}[2]{$#1 \To #2$}
\newcommand{\FUN}[2]{#1 \To #2}
\newcommand{\PUBLIC}{\ifthenelse{\boolean{VDMpp}}{public\mbox{}}{\mbox{}}}
\newcommand{\PRIVATE}{\ifthenelse{\boolean{VDMpp}}{private}{\mbox{}}}
\newcommand{\PROTECTED}{\ifthenelse{\boolean{VDMpp}}{protected}{\mbox{}}}


% No line numbering
%\nolinenumbering
%\setindent{outer}{\parindent}
%\setindent{inner}{0.0em}


\section{導入}


この文書では、基本的には標準ISO/VDM-SL \cite{ISOVDM96}だが、モジュールに関して拡張された、VDM-SL言語の構文と意味定義を述べる
\footnote{その他にもいくつかの拡張が含まれている。}。
全ての構文上正しい{\vdmsl}仕様記述は{\vdmsl}として正しいことに注意すること。
私たちは、明確に、理解しやすい方法で言語を提供しようとしているが、
この文書は完全な{\vdmsl}の参照マニュアルではない。
言語の説明のより詳しいところは、文献\footnote{VDM-SLにおける証明が\cite{Jones90a}と\cite{Bicarregui&94}で最もよく扱われるにもかかわらず、より多くの参考書は、
\cite{Fitzgerald&98}で与えられる}を参照している。
VDM-SL記法がVDM-SL標準の表記法と異なっているところは全て、言うまでもなく、意味定義を入念に説明する。

VDM-SL言語はVDM-SL Toolboxによってサポートされた言語である。
(\cite{UserMan-SCSK}参照)
このToolboxは構文チェッカー、静的な意味定義チェッカー、インタープリタ\footnote{Toolboxは清書機能、デバック機能、
テスト適用範囲のサポートを提供するのに加わっているが、これらは基本的なコンポーネントである。} 、
およびC++へのコードジェネレータを含んでいる。
一般的に、ISO/VDM-SLは非実行可能な言語であるので、インタープリタは言語の部分集合だけをサポートする。
この文書は特にVDM-SL の意味定義がインタープリタで使用され
る意味定義と異なっている部分に焦点をあてていく。この文書内では、VDM-SL Toolboxからイン
タープリタについて言及するときは、いつも、「インタープリ
タ」という用語を使用していく。そして、ある言語の構成要素の意味定義がVDM-SL標準
と全く同じであるときは、”VDM-SL”について言及していく

その結果、ASCII(あるいは、置き換えと呼ばれる) 具象構文を使用するが、
私たちは特別なキーワード字体ですべての予約語を表示していく。こうする理由は、
その文書ではASCII記法が入力として使用されているVDM-SL Toolboxの言語マニュアルとして機能するからである。
数学的な具象構文は、Toolboxによって、自動的に生成することができ、より見やすい構文を作り出すことができる。

セクション~\ref{conformance}は、その言語がどうここで紹介されるのか、また、対応しているVDM-SL Toolbox
がどのようにVDM-SL標準に一致するのかを示す。

セクション~\ref{syntax-notation}は構文の構成要素の記述に使用されるBNF記法を紹介する。VDM-SL
の表記法はセクション~\ref{typedef}からセクション~\ref{top-level}で述べられる。セクション~\ref{diff}は
ISO/VDM-SLとVDM-SLの違いに関する全リストを提供する。さらにセクション~\ref{static}はVDM-SLの静的な意味定義の短い説明を含む。

付録~\ref{app-a}では、完全な言語の構文、付録~\ref{app-b}では語彙詳細、付録~\ref{app-c}では演算子の優先順位を紹介する。
付録~\ref{sec:diff}では数学の構文シンボルとASCII 具象構文の違いをリストで紹介する。
付録~\ref{stdlib}では、標準 ライブラリの詳細と使用方法を提供する。
最終的には、文書内における全ての構文ルールの存在を定義するインデックスを提供する。


\section{準拠事項}
\label{conformance}

標準規格であるVDM-SLには、いくつかの準拠レベルを記載する準拠事項の節がある。
最も低レベルでの準拠事項は構文一致である。
\vdmslpp{\vdmsl}{\vdmpp} Toolboxでは、\vdmslpp{標準}{標準のもの、例外は第\ref{diff}章にて記述される}の構文記述に従った仕様記述を受け入れる。
加えて、準拠条項に従えば排除されるべき多くの拡張記述(第\ref{diff}章参照)についても受け入れる。

準拠事項レベル1では、恐らくの正しさに対する静的意味を扱う(第~\ref{static}章参照)。
ここでは、恐らくは良形である標準記述を対象にし、他に多く存在するさまざまな記述は極力排除することとした
\footnote{例えば述語が存在する集合の理解において、標準記述では(恐らくは良形であることのチェックでは)
要素式に対する検査をまったく行わない。なぜなら、述語はfalseとなる可能性がある
(したがって全式が空集合を表すことになる可能性がある)からである。
読者はこの例を実際試すことにも興味をもつであろうと確信する。}。

準拠事項レベル2およびこれ以降のレベル(最終レベル以外)では、絶対的な良形であることの静的意味チェックと、静的意味に加えられるいくつかのおこりうる拡張チェックについて扱う。
絶対的に良形であることの検査機能はToolboxが持っている。
しかしながら、実際例においてはこれが最も価値あるものとは考えない。
なぜなら「現実にある」例に対し、ほとんどすべての記述がこの検査をパスすることはないからである。

準拠最終レベルでは動的意味を扱う。
ここで、標準の動的意味(これは実行可能でない)からどのように逸脱しているかについては、添付書類を用いた詳細の提供が求められている。
本書では、どのような構成要素がToolboxにて翻訳されるか、ほんの少しの構成要素において逸脱するものが何であるかを説明し、この要求に事実上答える。
このようにこの準拠レベルは、\vdmslpp{VDM-SL}{\vdmpp}Toolboxの存在で条件が満たされている。

まとめれば、 \vdmslpp{VDM-SL}{\vdmpp}はきわめて標準準拠に近いと言うことができるが、これを保証するに十分な時間は未だ費やされていない。

\section{具象構文表記法}
\label{syntax-notation}

本書の中で、一部の言語構文については常にBNF表記を用いる。
使用されるBNF表記法には、以下に示すような特殊記号が用いられる:

\newcommand{\singleQuote}{\texttt{\symbol{34}}}
\begin{tabular}{l@{\hspace{1cm}}p{10cm}}
  , &  連結記号 \\
  = &  定義記号 \\
  \dsepl & 定義分離記号(選択枝)\\
  \OptPt{} & オプションの構文項目を囲む \\
  \SeqPt{} & 0回以上出現する構文項目を囲む \\
  \Lit{ } & シングル引用リテラルは終端記号を囲むのに使用される \\
    メタ識別子 & 非終端記号は小文字(空白も含む)で記される \\
  ;  & 1つの規則の終わりを表わす終了記号\\
  (\ ) & グループ化に用いられる、つまり``a, (b\dsepl c)'' は
    ``a, b\dsepl a, c''と等しい。 \\
  -- & 終端記号の集合からの減算を表す(つまり ``character -- (\Lit{\singleQuote})'' はダブル引用リテラルを除くすべての文字を表す。)
\end{tabular}

\section{データ型定義}
\label{typedef}

伝統的なプログラミング言語と同様に、\vdmslpp{\vdmsl}{\vdmpp}においてもデータ型を定義し適切な名称を与えることができる。
例えば次のような等式が与えられたとする:

\begin{alltt}
  Amount = \keyw{nat}
\end{alltt}
ここでは``{\tt Amount(合計)}''という名のデータ型を定義し、この型に属する値は自然数であると述べている(\keyw{nat(自然数)} は以下に記述される基本型の1つである)。
\vdmslpp{\vdmsl}{\vdmpp}の型体系で全般に共通する1つは、今この点について述べることは重要だが、相等と不等とはどのような値間にも用いることができるということである。 
プログラミング言語においてはしばしば、演算対象が同じ型であることを要求される。
\vdmslpp{\vdmsl}{\vdmpp}では合併型(以下に示す)と呼ばれる構造があるので、これには当てはまらない。

この節では、データ型定義の構文について述べる。
加えて、ある型に属する値はどのように構成され操作されうるのか(組込み演算子を用いて)について述べる。
最初に基本データ型を示し、次に合成型へと進めよう。

\subsection{基本データ型}

以下にいくつかの基本型を提示する。
その各々は次を含む:

\begin{itemize}
\item 構成の名称
\item 構成の記号
\item そのデータに属する特殊な値
\item そのデータ型に属する値のための組込み演算子。
\item 組込み演算子の意味定義。
\item 組込み演算子の使用例
  \footnote{これらの例題中では、メタ記号`$\equiv$'を用いて与えられた例題が何と同等であるかを示す。}
\end{itemize}
組込み演算子の各々については、その意味定義の記述と共に、名称、記号、そして演算子の型が与えられる(ただし相等と不等の意味については、通常の意味に従うので、記述されていない。)
意味定義の記述において、識別子は例えば\ {\tt a}, {\tt b}, {\tt x}, {\tt y}他 といったもので、対応する演算子型の定義で使用されるものを参照している。

基本型とは、言語により定義されていて、それ以上単純な値には分解することができない異なる値をもっている型とされる。
主要な基本型として5つ：ブール型、数値型、文字型、トークン型、引用型 が挙げられる。
以下にこの基本型について1つずつ説明していこう。

\subsubsection{ブール型}\label{bool}

一般的に \vdmslpp{\vdmsl}{\vdmpp} では、その中で計算が終了しなかったり結果を出せなかったりするかもしれないシステムを対象とすることも許されている。
このような潜在的な未定義状態を取り扱うために、\vdmslpp{\vdmsl}{\vdmpp} では3値論理：値は「true(真)」、「false(偽)」、「bottom/undefined(未定義)」のいずれかであるとする、を取り入る。
インタプリターの意味定義は、演算対象の順番に重きをおかないLPF (Logic of Partial Functions、部分関数の論理) の3値論理(\cite{Jones90a}参照)をもつものではないという意味において、 \vdmsl\ のものとは異なる。
それでも、論理積\keyw{and}、論理和\keyw{or}、それに含意演算子は、最初の演算対象のみで結果を決定するのに十分であるならば、次の演算対象をあえて評価しようとはしない、という条件つきの意味定義をもつ。
ある意味で、インタプリターの論理の意味定義は3値であると、VDM-SLに関してはまだ考えることができるであろう。
しかしながら、未定義値は無限大ループやランタイムエラーになる可能性がある。

\begin{description}
\item[名称:] \Index{ブール}
\item[記号:] \Index{\keyw{bool}}
\item[値:] \Index{\keyw{true}}, \Index{\keyw{false}}
\item[演算子:] 下記の{\tt a} と {\tt b} は任意のブール式を表す:

  \begin{tabular}{|l|l|l|}\hline
    演算子       & 名称       & 型                       \\ \hline
    {\tt \keyw{not} b}& 否定   & \TO{\keyw{bool}}{\keyw{bool}} \\
    {\tt a \keyw{and} b}& 論理積& \TO{\PROD{\keyw{bool}}{\keyw{bool}}}{\keyw{bool}} \\
    {\tt a \keyw{or} b}& 論理和 & \TO{\PROD{\keyw{bool}}{\keyw{bool}}}{\keyw{bool}} \\
    {\tt a => b}& 含意 & \TO{\PROD{\keyw{bool}}{\keyw{bool}}}{\keyw{bool}} \\
    {\tt a <=> b}& 同値 & \TO{\PROD{\keyw{bool}}{\keyw{bool}}}{\keyw{bool}} \\
    {\tt a = b} & 相等 & \TO{\PROD{\keyw{bool}}{\keyw{bool}}}{\keyw{bool}} \\
    {\tt a <> b}& 不等 & \TO{\PROD{\keyw{bool}}{\keyw{bool}}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\keyw{not}}\index{Negation}\index{\keyw{and}}\index{Conjunction}%
\index{\keyw{or}}\index{Disjunction}%
\index{\texttt{=>}}\index{Implication}\index{\texttt{<=>}}\index{Biimplication}%
\index{\texttt{=}!boolean equality}\index{Equality!boolean type}\index{\texttt{<>}!boolean inequality}\index{Inequality!boolean type}


\item[演算子の意味定義:] 意味定義では、ブール値を扱う場合の {\tt <=>} と {\tt =} は等しい。 
\keyw{and}、 \keyw{or}、および {\tt=>}においては条件つきの意味定義がある。
$\perp$によって定義されていない項目 (たとえば定義域外のキーをもつ写像に適用される)を表示しよう。
ブール演算子に対する真理値表は次のとおり%
  \footnote{標準 VDM-SL ではこれらの真理値表は({\tt =>}以外は)対称性をもつことに注目しよう。}:
     
  \begin{tabular}{ll}
    否定 {\tt \keyw{not} b} &
    \begin{tabular}{|l|l|l|l|}\hline
      $ b $   & \keyw{true}  & \keyw{false} & $\perp$ \\ \hline
      {\tt \keyw{not} b}  & \keyw{false}  & \keyw{true} & $\perp$ \\ \hline
    \end{tabular}\\
    \mbox{} & \\
    論理積 {\tt a \keyw{and} b} &
    \begin{tabular}{|l|l|l|l|}\hline
      $a \backslash b $   & \keyw{true}  & \keyw{false} & $\perp$ \\ \hline
      \keyw{true}  & \keyw{true}  & \keyw{false} & $\perp$ \\
      \keyw{false} & \keyw{false} & \keyw{false} & \keyw{false} \\
      $\perp$& $\perp$&$\perp$&$\perp$\\\hline
    \end{tabular}\\
    \mbox{} & \\
    論理和 {\tt a \keyw{or} b} &
    \begin{tabular}{|l|l|l|l|}\hline
      $a \backslash b $   & \keyw{true}  & \keyw{false} & $\perp$ \\ \hline
      \keyw{true}  & \keyw{true}  & \keyw{true} & \keyw{true} \\
      \keyw{false} & \keyw{true} & \keyw{false} & $\perp$ \\
      $\perp$& $\perp$&$\perp$&$\perp$\\\hline
    \end{tabular}\\
    \mbox{} & \\
    含意 {\tt a => b} &
    \begin{tabular}{|l|l|l|l|}\hline
      $a \backslash b $   & \keyw{true}  & \keyw{false} & $\perp$ \\ \hline
      \keyw{true}  & \keyw{true}  & \keyw{false} & $\perp$ \\
      \keyw{false} & \keyw{true} & \keyw{true} & \keyw{true} \\
      $\perp$& $\perp$&$\perp$&$\perp$\\\hline
    \end{tabular}\\
    \mbox{} & \\
    同値 {\tt a <=> b} &
    \begin{tabular}{|l|l|l|l|}\hline
      $ a \backslash b$    & \keyw{true}  & \keyw{false} & $\perp$ \\ \hline
      \keyw{true}  & \keyw{true}  & \keyw{false} & $\perp$ \\
      \keyw{false} & \keyw{false} & \keyw{true}  & $\perp$ \\
      $\perp$&$\perp$ &$\perp$ & $\perp$ \\ \hline
    \end{tabular}\\
  \end{tabular}     

\item[例題:] 
   {\tt a = \keyw{true}} で {\tt b = \keyw{false}} と仮定すると次のとおり:
  
  \begin{tabular}{lcl}
    {\tt \keyw{not} a} & $\equiv$ & \keyw{false} \\
    {\tt a \keyw{and} b} & $\equiv$ & \keyw{false} \\
    {\tt b \keyw{and} $\perp$} & $\equiv$ & \keyw{false} \\
    {\tt a \keyw{or} b} & $\equiv$ & \keyw{true} \\
    {\tt a \keyw{or} $\perp$} & $\equiv$ & \keyw{true} \\
    {\tt a => b} & $\equiv$ & \keyw{false} \\
    {\tt b => b} & $\equiv$ & \keyw{true} \\
    {\tt b => $\perp$} & $\equiv$ & \keyw{true} \\
    {\tt a <=> b} & $\equiv$ & \keyw{false} \\
    {\tt a = b} & $\equiv$ & \keyw{false} \\
    {\tt a <> b} & $\equiv$ & \keyw{true} \\
    {\tt $\perp$ \keyw{or} \keyw{not} $\perp$} & $\equiv$ & $\perp$\\
    {\tt (b \keyw{and} $\perp$) \keyw{or} ($\perp$ \keyw{and}
    \keyw{false})} & $\equiv$ & $\perp$
  \end{tabular}
\end{description}

\subsubsection{数値型}\label{numeric}

数値型には5つの基本型：正の自然数、自然数、整数、有理数、そして実数がある。
3つを除きどの数値演算子も、演算対象として5つの型の混在を許す。
例外である3つとは、整数除算、法算、剰余算、である。

5つの数値型は階層構造をなし、\Index{\keyw{実数(real)}}が最も一般的な型で{\keyw{有理数(rat)}}\footnote{\vdmslpp{\vdmsl}{\vdmpp}\ Toolboxの見地からすれば \keyw{実数(real)} と \keyw{有理数(rat)} は違いがない。コンピューター上では有理数しか表現できないからである。}、\Index{\keyw{整数(int)}}、\Index{\keyw{自然数(nat)}}、\Index{\keyw{正の自然数(nat1)}}と続く。 

\vspace{1ex}
\begin{tabular}{|l|l|} \hline
  型 & 値 \\ \hline
  \keyw{nat1}& {\tt 1, 2, 3, \ldots}\\
  \keyw{nat} & {\tt 0, 1, 2, \ldots}\\
  \keyw{int} & {\tt \ldots, -2, -1, 0, 1, \ldots}\\
  \keyw{real} & {\tt \ldots, -12.78356, \ldots, 0, \ldots, 3, \ldots, 1726.34, \ldots}\\ \hline
\end{tabular}

\mbox{}\\
この表より、\keyw{int}ならばどのような数でも自動的に\keyw{real}であるが、\keyw{nat}であるとは限らないということがわかる。
言い換えると、正の自然数は自然数の一部であり、その自然数は整数の、その整数は有理数の、有理数は最終的には実数の一部である、と表現することができる。
次の表でいくつかの数が属する型を示す：

\vspace{1ex}
\begin{tabular}{|c|l|} \hline
  数 & 型 \\ \hline
  {\tt 3}      & \keyw{real, rat, int, nat, nat1} \\
  {\tt 3.0}    & \keyw{real, rat, int, nat, nat1} \\
  {\tt 0}      & \keyw{real, rat, int, nat} \\
  {\tt -1}     & \keyw{real, rat, int}\\
  {\tt 3.1415} & \keyw{real, rat} \\ \hline
\end{tabular}

\mbox{}\\
すべての数が必然的に \keyw{real}型 (そして\keyw{rat}型)であることに注意。

\begin{description}
\item[名称:] 実数, 有理数, 整数, 自然数、そして 正の自然数
\item[記号:] \keyw{real}, \keyw{rat}, \keyw{int}, \keyw{nat},
  \keyw{nat1}
\item[値:] {\tt \ldots, -3.89, \ldots, -2, \ldots, 0, \ldots, 4,
    \ldots, 1074.345, \ldots}
\item[演算子:]  以下における{\tt x} と {\tt y} は数式を表すとする。  
 これらの型について仮定はなされない。

  \begin{tabular}{|l|l|l|}\hline
    演算子       & 名称 & 型 \\ \hline
    {\tt -x}& 負符号 & \TO{\keyw{real}}{\keyw{real}} \\
    {\tt \keyw{abs} x}& 絶対値 & \TO{\keyw{real}}{\keyw{real}} \\
    {\tt \keyw{floor} x}& 底値  & \TO{\keyw{real}}{\keyw{int}} \\
    {\tt x + y}& 加算 & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{real}} \\
    {\tt x - y}& 減算& \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{real}} \\
    {\tt x * y}& 乗算& \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{real}} \\
    {\tt x / y}& 除算& \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{real}} \\
    {\tt x \keyw{div} y}& 整数除算& \TO{\PROD{\keyw{int}}{\keyw{int}}}{\keyw{int}} \\
    {\tt x \keyw{rem} y}& 剰余算& \TO{\PROD{\keyw{int}}{\keyw{int}}}{\keyw{int}} \\
    {\tt x \keyw{mod} y}& 法算 & \TO{\PROD{\keyw{int}}{\keyw{int}}}{\keyw{int}} \\
    {\tt x**y}& べき算& \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{real}} \\
    {\tt x < y}& より小さい& \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{bool}} \\
    {\tt x > y}& より大きい& \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{bool}} \\
    {\tt x <= y}& より小さいか等しい& \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{bool}} \\
    {\tt x >= y}& より大きいか等しい& \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{bool}} \\
    {\tt x = y}& 相等 & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{bool}} \\
    {\tt x <> y}& 不等& \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{bool}} \\
    \hline     
  \end{tabular}%
\index{\texttt{-}}\index{Unary minus}\index{\keyw{abs}}\index{Absolute value}%
\index{\keyw{floor}}\index{Floor}\index{\texttt{+}}\index{Sum}\index{Difference!numeric}%
\index{\texttt{*}}\index{Product}\index{\texttt{/}}\index{Division}%
\index{\keyw{div}}\index{Integer division}\index{\keyw{mod}}\index{Remainder}%
\index{\keyw{mod}}\index{Modulus}\index{\texttt{**}!numeric power}\index{Power}%
\index{\texttt{<}}\index{Less than}\index{\texttt{>}}\index{Greater than}%
\index{\texttt{<=}}\index{Less or equal}\index{\texttt{>=}}\index{Greater or equal}%
\index{\texttt{=}!numeric equality}\index{Equality!numeric type}\index{\texttt{<>}!numeric inequality}\index{Inequality!numeric type}

  演算対象として書かれた型は、許される限りでの最も広範な型である。
 例えば負符号は5つのすべての型 (\keyw{nat1}, \keyw{nat}, \keyw{int} \keyw{rat} そして \keyw{real})を演算対象とすることを示している。
     
\item[演算子の意味:] 演算子であるマイナス符号、総和、差、積、商、小さい、大きい、等しいか小さい、等しいか大きい、相等関係、不等関係はこのような演算の通常の意味をもつ。

 \vspace{1ex}
 \begin{TypeSemantics}
    底値 &  {\tt x}と等しいかより小さい整数のうちで最大のもの \\ \hline

    絶対値 &  {\tt x}の絶対値、つまり {\tt x >= 0} ならば\ {\tt   x} そのままで{\tt x < 0}ならば {\tt -x}となる \\ \hline

    冪 &  {\tt x} を {\tt y}回乗じたもの \\ \hline
  \end{TypeSemantics}

  \vspace{1ex}
 整数商、剰余、そして法　が負の数にどのように作用するかについては、しばしば混乱がおきる。 
事実  {\tt -14 \keyw{div} 3}に対して有効な答えが２つある:  Toolboxにおいてと同様{\tt -4} (the intuitive)となるか、たとえば\ Standard ML  \cite{Paulson91}においてと同様に{\tt -5}となるかである。
したがってこれらの演算については詳細に説明しておくべきであろう。

  整数除算は {\sf floor} と実数除算を用いて定義される:

  \begin{alltt}
    x/y <  0:   x \keyw{div} y = -\keyw{floor}(\keyw{abs}(-x/y))
    x/y >= 0:   x \keyw{div} y =  \keyw{floor}(\keyw{abs}(x/y))
  \end{alltt}

 右辺の \keyw{floor}と \keyw{abs}の順により違いが生じ、その順を交換することで上記の例題は{\tt -5} となる。 
これは \keyw{floor} は常により小さい（か等しい）整数に従うからである、たとえば\ {\tt \keyw{floor} (14/3)} は {\tt    4}である一方  {\tt \keyw{floor} (-14/3)} は {\tt -5}である。

剰余 {\tt x \keyw{rem} y} と　法 {\tt x \keyw{mod} y} は、
 {\tt x} と {\tt y} の符号が同じであれば同じ値となるが、そうでない場合は異なる値となり、 \keyw{rem}は{\tt x}の符号を\keyw{mod}は{\tt y}の符号をとる。
剰余と法の公式は次のとおり:
  \begin{alltt}
    x \keyw{rem} y = x - y * (x \keyw{div} y)
    x \keyw{mod} y = x - y * \keyw{floor}(x/y)
  \end{alltt}
 そのため, {\tt -14 \keyw{rem} 3} は {\tt -2} に等しく、 {\tt -14
    \keyw{mod} 3} は {\tt 1}に等しい。 
実数軸をたどり、 {\tt -14} から進め {\tt 3}づつジャンプすることで、これらの結果を確認することができる。 
剰余はたどった負の数の最後の値であるが、それは{\tt x}にあたる最初の引数が負であるからであり、一方の法はたどった正の数の最初の値であるが、それは {\tt y} にあたる２番目の引数が正であるからである。

\item[例題:]  {\tt a = 7, b = 3.5, c = 3.1415, d = -3, e = 2} とすると:

  \begin{longtable}{lcl}
    {\tt - a}&$\equiv$& -7                     \\
    {\tt \keyw{abs} a}&$\equiv$& 7                    \\
    {\tt \keyw{abs} d}&$\equiv$& 3                    \\
    {\tt \keyw{floor} a <= a}&$\equiv$& \keyw{true}   \\
    {\tt a + d}&$\equiv$& $4$                  \\
    {\tt a * b}&$\equiv$& $24.5$               \\
    {\tt a / b}&$\equiv$& $2$                \\
    {\tt a \keyw{div} e}&$\equiv$& $3$                \\
    {\tt a \keyw{div} d}&$\equiv$& $-2$               \\
    {\tt a \keyw{mod} e}&$\equiv$& $1$                \\
    {\tt a \keyw{mod} d}&$\equiv$& $-2$               \\
    {\tt -a \keyw{mod} d}&$\equiv$& $-1$               \\
    {\tt a \keyw{rem} e}&$\equiv$& $1$                \\
    {\tt a \keyw{rem} d}&$\equiv$& $1$                \\
    {\tt -a \keyw{rem} d}&$\equiv$& $-1$              \\
    {\tt 3**2 + 4**2 = 5**2} &$\equiv$ &\keyw{true}   \\
    {\tt b < c}&$\equiv$& \keyw{false}                \\
    {\tt b > c}&$\equiv$& \keyw{true}                 \\
    {\tt a <= d}&$\equiv$& \keyw{false}               \\
    {\tt b >= e}&$\equiv$& \keyw{true}                \\
    {\tt a = e}&$\equiv$& \keyw{false}                \\
    {\tt a = 7.0}&$\equiv$& \keyw{true}               \\
    {\tt c <> d}&$\equiv$& \keyw{true}                \\
    {\tt \keyw{abs} c < 0} & $\equiv$ & \keyw{false}  \\
    {\tt (a \keyw{div} e) * e} & $\equiv$ & 6       
  \end{longtable}
\end{description}

\subsubsection{文字型}

文字型は、VDM 文字集合(~\pageref{charSetTable}ページの表~\ref{charSetTable}を参照)中の単一の文字すべてを含む。

\begin{description}
\item[名称:] \Index{文字}
\item[記号:] \Index{\keyw{char}}
\item[値:] {\tt 'a', 'b',} \ldots, {\tt '1', '2',} \ldots {\tt
                '+', '-'} \ldots
\item[演算子:]  次の{\tt c1} と {\tt c2} は任意の文字を表す:

  \begin{tabular}{|l|l|l|}\hline
    演算子       & 名称      & 型 \\ \hline
    {\tt c1 = c2}  & 相等     & \TO{\PROD{\keyw{char}}{\keyw{char}}}{\keyw{bool}} \\
    {\tt c1 <> c2} & 不等 & \TO{\PROD{\keyw{char}}{\keyw{char}}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{=}!char equality}\index{Equality!char}\index{\texttt{<>}!char inequality}\index{Inequality!char}


\item[例題:] 
 \mbox{}

  \begin{tabular}{lcl}
    {\tt 'a' = 'b'} &$\equiv$& \keyw{false}\\
    {\tt '1' = 'c'} &$\equiv$& \keyw{false}\\
    {\tt 'd' <> '7'} &$\equiv$& \keyw{true}\\
    {\tt 'e' = 'e'} &$\equiv$& \keyw{true}\\
  \end{tabular}
\end{description}

\subsubsection{引用型}

引用型は、パスカルのようなプログラミング言語における列挙型に相当する。
しかしながら\vdmslpp{\vdmsl}{\vdmpp}\ においては、中括弧の中に個別の引用リテラルを書くのではなく、シングル引用リテラルからなる引用型と、それらを合併型の一部とすることで書き表す。
%Quote literals are recognized
%by being a sequence of $\const{distinguished letters}$ (which cannot be
%used for any other purpose).

\begin{description}
\item[名称:] \Index{引用}
\item[記号:] たとえば {\tt <QuoteLit>}\index{\texttt{<>}!引用値}
\item[値:] {\tt <RED>, <CAR>, <QuoteLit>,} \ldots
\item[演算子:] 以下の \texttt{q} と \texttt{r} が、列挙型{\tt T}に属する任意の引用値を表していると仮定すると: 

  \begin{tabular}{|l|l|l|}\hline
    演算子     & 名称      & 型 \\ \hline
    {\tt q = r}  & 相等     & \TO{\PROD{T}{T}}{\keyw{bool}} \\
    {\tt q <> r} & 不等 & \TO{\PROD{T}{T}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{=}!quote equality}\index{Equality!quote type}\index{\texttt{<>}!quote inequality}\index{Inequality!quote}


\item[例題:]  \texttt{T} を次に定義された型とする:

  \begin{tabular}{l}
    {\tt T = <France> | <Denmark> | <SouthAfrica> | <SaudiArabia>} \\
  \end{tabular}

  ここで {\tt a = <France>}であるならば次のとおり:

  \begin{tabular}{lcl}
     {\tt <France> = <Denmark>} & $\equiv$ & \keyw{false}\\
     {\tt <SaudiArabia> <> <SouthAfrica>} & $\equiv$ & \keyw{true}\\
     {\tt a <> <France>} & $\equiv$ & \keyw{false}
  \end{tabular}
\end{description}

\subsubsection{トークン型}

トークン型は、トークンと呼ばれる異なる値の可算無限集合からなる。
トークンに対して実行される操作は、相等と不等のみである。
 \vdmslpp{\vdmsl,}{\vdmpp,}におけるトークンは、\keyw{mk\_token}を用いて任意の式を囲む記述ができるのにもかかわらず、単独に表現することはできない。
これが、トークン型を含む仕様のテストを可能にする方法である。
しかしながら\vdmsl\ 標準に似せるためには、これらのトークン値はどんなパターンマッチングによっても分解できず、相等または不等の比較以外どのような演算にも用いることはできない。

\begin{description}
\item[名称:] \Index{トークン}
\item[記号:] \Index{\keyw{token}}
\item[値:] \index{\keyw{mk\_}!token value}{\tt \keyw{mk\_token}(5)},
  {\tt \keyw{mk\_token}(\{9, 3\})}, {\tt
    \keyw{mk\_token}([\keyw{true}, \{\}])}, \ldots%\index
\item[演算子:] 以下の {\tt s} と {\tt  t} は任意のトークン値を表す:

  \begin{tabular}{|l|l|l|}\hline
    演算子     & 名称      & 型 \\ \hline
    {\tt s = t}  & 相等     & \TO{\PROD{\keyw{token}}{\keyw{token}}}{\keyw{bool}} \\
    {\tt s <> t} & 不等 & \TO{\PROD{\keyw{token}}{\keyw{token}}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{=}!token equality}\index{Equality!token type}\index{\texttt{<>}!token inequality}\index{Inequality!token type}

\item[例題:] 次においてたとえば {\tt s = \keyw{mk\_token}(6)} 、 {\tt t
    = \keyw{mk\_token}(1)} とすると:

  \begin{tabular}{lcl}
    {\tt s = t} &$\equiv$& \keyw{false} \\
    {\tt s <> t} &$\equiv$& \keyw{true} \\
    {\tt s = \keyw{mk\_token}(6)} & $\equiv$& \keyw{true} \\
  \end{tabular}
\end{description}

\subsection{合成型}

以下に合成型について記述する。 
各々は次を含む：
\begin{itemize}
\item 合成型定義の構文
\item 構成要素をどのように用いるか示す等式
\item この型に属する値をどのように構成するか示す例題
ほとんどの場合に、基本構成子式の構文が与えられている前の節への参照が示される。
\item この型に属する値に対する演算子 \footnote{これらの演算子は、第~\ref{unandbin}節で全演算子が与えられるなかの単項式か2項式に用いられている。}
\item 演算子の意味定義
\item 演算子の使用例
\end{itemize}
演算子の各々に対し、名称、記号、演算子の型がその意味定義と共に与えられる (ただし相等と不等については、通常の意味に従うとして除かれる)。 
意味定義記述において、識別子はたとえば \ {\tt m}, {\tt m1}, {\tt s}, {\tt s1} 他 というような、対応する演算子型定義で用いられたものを参照する。

\subsubsection{集合型}
\label{sets}

集合とは、値を順番をつけずに集めたものであり、それらはすべて同じ型のもので\footnote{ただし合併型を用いれば、2つの値に共通な型を見つけ出すのは常に可能であることに注意 (第~\ref{unions}節参照)。}、全体は1つとして扱われる。
\vdmslpp{\vdmsl}{\vdmpp}\ におけるすべての集合は有限である、すなわち有限個の要素しか含められない。 
集合型の要素は任意の合成型でありうるし、例えば集合自身の集合であってもよい。

以下の記述には次の合意を用いる：{\tt A}は任意の型、 {\tt S} は集合型、 {\tt s}、 {\tt s1}、 {\tt s2} は集合値、 {\tt ss} は集合値の集合、 {\tt e}、 {\tt e1}、 {\tt e2}、 {\tt en} は集合の要素、 {\tt bd1,} {\tt bd2}、 \ldots、{\tt bdm} は集合または型を示す識別子を束ねたもの、そして {\tt P} は論理述語である。

\begin{description}
\item[構文:] 
  \Rule{型}{
   \Ruleref{集合型} \dsep
    \ldots
    }
  
  \Rule{集合型}{\Lop{set of}, \Ruleref{型}}

\item[等式:] {\tt S = \keyw{set of} A}\index{\keyw{set of}}

\item[構成子:] \mbox{}

  \begin{description}
  \item[集合列挙:] \verb|{e1, e2, ..., en}|  は列挙された要素の集合を構成する。
空集合は {\tt \{\}}と表記される。
  
  \item[集合内包:] \verb+{e | bd1, bd2, ..., bdm & P}+
    は、述語{\tt P}が\keyw{true}となるすべての束縛について式{\tt e} を評価することにより集合を定義する。
    束縛は集合束縛と型束縛のどちらかとなる\footnote{型束縛は実行可能ではないので一般的にはインタープリタで実行されない (これについては第~\ref{bind}節を参照)。}。  
集合束縛 {\tt bdn} は {\tt pat1, \ldots, patp \keyw{in set} s}という形式をもつが、ここでの{\tt pati}はパターン (通常は単純な識別子である)であり、 {\tt s} は1つの式で構成される集合である。 
型束縛も、\keyw{in set}がコロンに換わり {\tt s}が型式となるという意味において、同様のものである。 
  \end{description}
  すべての集合式に対する構文と意味定義は、第~\ref{setexpr}節に与えられる
\index{\texttt{\{\}}!set enumeration}\index{\texttt{\{"|\}}!set comprehension}\index{\texttt{\&}!set comprehension}
\item[演算子:] \mbox{}

  \begin{tabular}{|l|l|l|}\hline
    演算子 & 名称 & 型 \\ \hline 
    {\tt e \keyw{in set} s1} & 帰属 & \TO{\PROD{A}{\SET{A}}}{\keyw{bool}} \\
    {\tt e \keyw{not in set} s1} & 非帰属 & \TO{\PROD{A}{\SET{A}}}{\keyw{bool}} \\
    {\tt s1 \keyw{union} s2}& 合併 & \TO{\PROD{\SET{A}}{\SET{A}}}{\SET{A}} \\
    {\tt s1 \keyw{inter} s2}& 共通部分 & \TO{\PROD{\SET{A}}{\SET{A}}}{\SET{A}} \\
    {\tt s1 {\tt \char'134} s2}& 差 & \TO{\PROD{\SET{A}}{\SET{A}}}{\SET{A}} \\
    {\tt s1 \keyw{subset} s2}& 包含 & \TO{\PROD{\SET{A}}{\SET{A}}}{\keyw{bool}} \\
    {\tt s1 \keyw{psubset} s2} & 真包含 & \TO{\PROD{\SET{A}}{\SET{A}}}{\keyw{bool}} \\
    {\tt s1 = s2}& 相等 & \TO{\PROD{\SET{A}}{\SET{A}}}{\keyw{bool}} \\
    {\tt s1 <> s2}& 不等 & \TO{\PROD{\SET{A}}{\SET{A}}}{\keyw{bool}} \\
    {\tt \keyw{card} s1}& 濃度 & \TO{\SET{A}}{\keyw{nat}} \\
    {\tt \keyw{dunion} ss}& 分配的合併& \TO{\SET{\SET{A}}}{\SET{A}} \\
    {\tt \keyw{dinter} ss}&分配的共通部分 & \TO{\SET{\SET{A}}}{\SET{A}} \\
    {\tt \keyw{power} s1}&有限べき集合 & \TO{\SET{A}}{\SET{\SET{A}}} \\
    \hline
  \end{tabular}%
\index{\keyw{in set}}\index{Membership}\index{\keyw{not in set}}\index{Not membership}%
\index{\keyw{union}}\index{Union}\index{\keyw{inter}}\index{Intersection}%
\index{\texttt{\char'134}}\index{Difference!set}\index{\keyw{subset}}\index{Subset}%
\index{\keyw{psubset}}\index{Proper subset}\index{\texttt{=}!set equality}\index{Equality!set type}%
\index{\texttt{<>}!set inequality}\index{Inequality!set type}\index{\keyw{card}}\index{Cardinality}%
\index{\keyw{dunion}}\index{Distributed union}\index{\keyw{dinter}}\index{Distributed intersection}%
\index{\keyw{power}}\index{Finite power set}

  {\tt A, \SET{A}}型と {\tt \SET{\SET{A}}}型は単に型の構造を表すだけではないことに注意。 
たとえば、任意の集合 {\tt s1} と {\tt s2}の合併を行った場合、結果の集合の型は2つの集合型の合併型とすることができる。
これについての例は第 \ref{unions}節に与えられる。
      
\item[演算子の意味:] \mbox{}

\begin{TypeSemantics}
帰属関係 &  {\tt e} が集合 {\tt s1}の要素であるかどうか検査する \\ \hline
非帰属関係 &  {\tt e} が集合 {\tt s1}の要素でないことを検査する \\ \hline
合併 & 集合 {\tt s1} と {\tt s2}の合併、つまり\  {\tt s1} と {\tt s2}の両方の要素をすべて含む集合である。 \\ \hline
共通部分 & 集合 {\tt s1} と {\tt s2}の共通部分、つまり\  {\tt s1} と{\tt s2}の両方にある要素を含む集合である。 \\ \hline
差 &  {\tt s2}に含まれていない{\tt s1}の要素をすべて含む集合。 {\tt s2} は{\tt s1}の部分集合である必要はない。 \\ \hline
包含関係 &  {\tt s1}が {\tt s2}の部分集合であるかどうかを検査する、つまり\  {\tt s1} のすべての要素が {\tt s2}の要素であるかどうかである。どの集合もそれ自身の部分集合であることには注意。 \\ \hline
真包含関係 &  {\tt s1} が {\tt s2}の真部分集合であることを検査する、つまり\ 部分集合でありしかも {\tt s2$\backslash$s1} が空集合でないことである。 \\ \hline
濃度 &  {\tt s1}の要素の数。 \\ \hline
分配的合併 & 結果の集合は{\tt ss}のすべての要素(それら自身が集合である)の合併である、つまり{\tt ss}のすべての要素／集合のすべての要素を含む。 \\ \hline
分配的共通部分 & 結果の集合はすべての要素の共通部分であり、つまり\ {\tt ss}のすべての要素／集合の中の要素を含むということ。 {\tt ss}は空集合であってはならない。 \\ \hline
有限べき集合 & {\tt s1}のべき集合である、つまり\  {\tt s1}のすべての部分集合の集合である。 \\ \hline
\end{TypeSemantics}

\item[例題:]%
  {\tt s1 = \{<France>,<Denmark>,<SouthAfrica>,<SaudiArabia>\}}、{\tt s2 = \{2, 4, 6, 8, 11\}} 、 {\tt s3 = \{\}} であるときには以下のとおり: 

  \begin{longtable}{lcl}
    {\tt <England> \keyw{in set} s1} & $\equiv$ & \keyw{false}\\
    {\tt 10 \keyw{not in set} s2}    & $\equiv$ & \keyw{true}\\
    {\tt s2 \keyw{union} s3}         & $\equiv$ & \texttt{\{2, 4, 6, 8, 11\}}\\
    \texttt{s1 \keyw{inter} s3}      & $\equiv$ & \texttt{\{\}}\\
    \texttt{(s2 \char'134 \ \{2,4,8,10\}) union \{2,4,8,10\} = s2} &
    $\equiv$ & \keyw{false}\\
    \texttt{s1 \keyw{subset} s3} & $\equiv$ & \keyw{false}\\
    \texttt{s3 \keyw{subset} s1} & $\equiv$ & \keyw{true}\\
    \texttt{s2 \keyw{psubset} s2} & $\equiv$ & \keyw{false}\\
    \texttt{s2 <> s2 \keyw{union} \{2, 4\}} & $\equiv$ & \keyw{false}\\
    \texttt{\keyw{card} s2 \keyw{union} \{2, 4\}} & $\equiv$ & \texttt{5}\\
    \texttt{\keyw{dunion} \{s2, \{2,4\}, \{4,5,6\}, \{0,12\}\}} &
    $\equiv$ & \texttt{\{0,2,4,5,6,8,11,12\}}\\
    \texttt{\keyw{dinter} \{s2, \{2,4\}, \{4,5,6\}\}} & $\equiv$ &
    \texttt{\{4\}}\\
    \texttt{\keyw{dunion} \keyw{power} \{2,4\}} & $\equiv$ &
    \texttt{\{2,4\}}\\
    \texttt{\keyw{dinter} \keyw{power} \{2,4\}} & $\equiv$ & \texttt{\{\}}
  \end{longtable}
\end{description}

\subsubsection{列型}
\label{sequences}

列値とは、ある型の要素を順に並べた集まりで {\tt n}が列の長さのときに、{\tt 1, 2, \ldots, n}によって索引づけられるものである。 
列型は同一型の要素を有限個連続させた型であり、空列を含む場合(空列を含む列型)と含まない場合(空列を含まない列型)のいずれかとなる。
列型の要素は、例えば列型自身のように、任意の複合型が許されている。

以下、ここに示す慣例的な表記を用いる: {\tt A}は任意の型であり、{\tt L}は列型であり、 {\tt S}は集合型であり、  {\tt l}, {\tt  l1}, {\tt l2} は列値であり、 {\tt ll}は列値の列である。 
{\tt e1}, {\tt e2} および {\tt en} はこれらの列の要素、 {\tt i}は自然数、 {\tt P} は述語、 {\tt e}は任意の式である。

\begin{description}
\item[構文:] 
  \Rule{型}{
    \Ruleref{列型} \dsep
    \ldots
    }

  \Rule{列型}{\Ruleref{空列を含む列型} \dsep
    \Ruleref{空列を含まない列型}}

  \Rule{空列を含む列型}{\Lop{seq of}, \Ruleref{型}}
  
  \Rule{空列を含まない列型}{\Lop{seq1 of}, \Ruleref{型}}
\item[等式:] {\tt L = \keyw{seq of} A} または {\tt L = \keyw{seq1 of} A}%
\index{\keyw{seq of}}\index{\keyw{seq1 of}}

%                 $L = \seqof*{A}$ or
%                 $L = \seqof+{A}$ where the notation has been adopted
%                 from regular expressions. Thus $\seqof*{A}$ means the type 
%                 containing sequences of $A$ elements (also the empty
%                 sequence), while $\seqof+{A}$ means the type containing
%                 non-empty sequences of $A$ elements. 

\item[構成子:] \mbox{}

  \begin{description}
  \item[列列挙:] \verb+[e1, e2,..., en]+ は、列挙された要素によって列を構成する。 
空列は \verb+[]+と表現する。 
テキストリテラルは文字の列挙の簡約記法である (たとえば\ {\tt "csk" = ['c','s','k']})

  \item[列内包:] {\tt [e | id \keyw{in set} S \& P]}
    は、述語{\tt P}が  \keyw{true}となるようなすべての束縛に対して式 {\tt e}を評価することで列を構成する。
式 {\tt e} は識別子 {\tt id}を用いる。 
{\tt S} は数の集合であり、 {\tt id} は通常の順で数とマッチする (最小の数を最初として)
  \end{description}
  すべての列式の構文と意味定義については、第~\ref{seqexpr}節で述べる。%
\index{\texttt{[]}!sequence enumeration}\index{\texttt{["|]}!sequence comprehension}\index{\texttt{\&}!sequence comprehension}

      
\item[演算子:] \mbox{}

  \begin{tabular}{|l|l|l|}\hline
    演算子 & 名称 & 型 \\ \hline 
    {\tt \keyw{hd} l} & 先頭 & \TO{\NSEQ{A}}{A} \\
    {\tt \keyw{tl} l} & 尾部 & \TO{\NSEQ{A}}{\SEQ{A}} \\
    {\tt \keyw{len} l} & 長さ & \TO{\SEQ{A}}{\keyw{nat}} \\
    {\tt \keyw{elems} l} & 要素集合 & \TO{\SEQ{A}}{\SET{A}} \\
    {\tt \keyw{inds} l} & 索引集合 & \TO{\SEQ{A}}{\SET{\keyw{nat1}}} \\
    {\tt l1 \char'136\ l2} & 連結 & \TO{\PROD{(\SEQ{A})}{(\SEQ{A})}}{\SEQ{A}} \\
    {\tt \keyw{conc} ll} & 分配的連結 & \TO{\SEQ{\SEQ{A}}}{\SEQ{A}}\\
    {\tt l ++ m} & 列修正 & \TO{\PROD{\SEQ{A}}{\MAP{\keyw{nat1}}{A}}}{\SEQ{A}}\\
    {\tt l(i)} & 列適用 & \TO{\PROD{\SEQ{A}}{\keyw{nat1}}}{A} \\
    {\tt l1 = l2} & 相等 & \TO{\PROD{(\SEQ{A})}{(\SEQ{A})}}{\keyw{bool}} \\
    {\tt l1 <> l2} & 不等 & \TO{\PROD{(\SEQ{A})}{(\SEQ{A})}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\keyw{hd}}\index{Head}\index{\keyw{tl}}\index{Tail}%
\index{\keyw{len}}\index{Length}\index{\keyw{elems}}\index{Elements}%
\index{\keyw{inds}}\index{Indexes}\index{\texttt{\char'136}}\index{Concatenation}%
\index{\keyw{conc}}\index{Distributed concatenation}%
\index{\texttt{++}!sequence modification}\index{Sequence modification}%
\index{\texttt{()}!sequence apply}\index{Sequence application}%
\index{\texttt{=}!sequence equality}\index{Equality!sequence type}\index{\texttt{<>}!sequence inequality}\index{Inequality!sequence type}%


 型{\tt A}は任意の型であって、連結や分配的連結の演算子に対する演算対象は、同じ型({\tt A}) である必要はない。 
結果列の型は、複数の演算対象の型の合併型となる。
第 \ref{unions}節に例題が与えられている。

\item[演算子の意味定義:] \mbox{}

\begin{TypeSemantics}
先頭 & {\tt l}の最初の要素。 {\tt l} は空列であってはならない。 \\ \hline
尾部 &  {\tt l}から最初の要素を取り除いた部分列。 {\tt l} は空列であってはならない。\\ \hline
長さ &  {\tt l}の長さ。 \\ \hline
要素集合 & {\tt l}の要素すべてを含む集合。 \\ \hline
索引集合 &  {\tt l}の索引すべてを含む集合。 \mbox{\tt \{1,...,len l\}}。 \\ \hline
連結 & {\tt l1} と {\tt l2}の連結、つまり順に、 {\tt l1} の列要素のあとに{\tt l2}の列要素を続けた列。 \\ \hline
分配的連結 &  {\tt ll}の列要素(これら自体が列である)が連結された列: 最初と第２の列要素を連結し、次に第３の列要素を連結し、等々。 \\ \hline
列修正 &  列索引が{\tt m}の定義域にある{\tt l} の列要素は、その索引が写像された先の値域値に修正される。 {\tt dom m} は索引 {\tt l}の部分集合でなければならない。 \\ \hline
列適用 &  {\tt l}から始まる索引の要素。 {\tt i} は {\tt l}の索引集合になければならない。 \\ \hline
\end{TypeSemantics}

\item[例題:]  \texttt{l1 = [3,1,4,1,5,9,2]}, \texttt{ l2 = [2,7,1,8]}, \newline
    \texttt{ l3 = [<England>, <Rumania>, <Colombia>,
    <Tunisia>]} とすると以下のとおり： 

  \begin{longtable}{lcl}
    \texttt{\keyw{len} l1}        & $\equiv$ & \texttt{7}\\
    \texttt{\keyw{hd} (l1\char'136 l2)}    & $\equiv$ & \texttt{3}\\
    \texttt{\keyw{tl} (l1\char'136 l2)}    & $\equiv$ &
      \texttt{[1,4,1,5,9,2,2,7,1,8]}\\
    \texttt{l3(\keyw{len} l3)}    & $\equiv$ & \texttt{<Tunisia>}\\
    \texttt{"England"(2)}       & $\equiv$ & \texttt{'n'}\\
    \texttt{\keyw{conc} [l1,l2] = l1\char'136 l2} 
                                  & $\equiv$ & \keyw{true}\\
    \texttt{\keyw{conc} [l1,l1,l2] = l1\char'136 l2} 
                                  & $\equiv$ & \keyw{false}\\
    \texttt{\keyw{elems} l3}      & $\equiv$ & \{
      \parbox[t]{5cm}{\texttt{<England>, <Rumania>, }\\
                      \texttt{<Colombia>,<Tunisia>\}}}\\
    \texttt{(\keyw{elems} l1) \keyw{inter} (\keyw{elems} l2)} 
                                  & $\equiv$ & \texttt{\{1,2\}}\\
    \texttt{\keyw{inds} l1}       & $\equiv$ & \texttt{\{1,2,3,4,5,6,7\}}\\
    \texttt{(\keyw{inds} l1) \keyw{inter} (\keyw{inds} l2)}
                                  & $\equiv$ & \texttt{\{1,2,3,4\}}\\
    \texttt{l3 ++ \{2 |-> <Germany>,4 |-> <Nigeria>\}}
                                  & $\equiv$ & [
      \parbox[t]{5cm}{\texttt{<England>, <Germany>, }\\
                      \texttt{<Colombia>, <Nigeria>]}}
  \end{longtable}
\end{description}

\subsubsection{写像型}\label{maps}

 {\tt A}型から {\tt B}型への写像型とは、 {\tt A} (または {\tt A}の部分集合)の要素各々を {\tt B}の1つの要素と結合する型のことである。 
写像の値とは、この2つの要素の組を順不同で集めたものと考えることができる。
各々の組の最初の要素をキーと呼ぶが、これは各組で最初の要素を用いて2番目の要素 (情報部分と呼ばれる) を得ることができるからである。
よって1つの写像におけるキー要素は、すべて異なるものでなければならない。
すべてのキー要素の集合をこの写像の定義域と呼び、一方すべての情報値の集合を値域と呼ぶ。
\vdmslpp{\vdmsl}{\vdmpp}\ におけるすべての写像とは有限のものである。
写像型の定義域と値域の要素には任意の合成が許されていて、たとえば要素を写像とすることもできる。

特別な写像としては1対1写像がある。 
1対1写像とは、値域の要素で2つ以上の定義域の要素と結合するものはない写像のことである。
この1対1写像では、写像を逆にすることが可能である。

以下では次のとおりに用いる: {\tt m}, {\tt m1}、および{\tt m2} は、任意の{\tt A}型からもう1つの任意の{\tt B}型への写像を表し、{\tt ms} は写像値の集合であり。
 {\tt a}, {\tt a1}, {\tt a2}、および{\tt an}は {\tt A}から取り出した要素である一方、 {\tt b}, {\tt b1}, {\tt b2} および{\tt bn}は{\tt B}から取り出した要素である。{\tt P}は論理述語である。
{\tt  e1}、{\tt e2} は任意の式であり、 {\tt s}は任意の集合である。

\begin{description}
\item[構文:] 
  \Rule{型}{
    \Ruleref{写像型} \dsep
    \ldots
    }
  
  \Rule{写像型}{\Ruleref{一般写像型} \dsep
    \Ruleref{1対1写像型}}
  
  \Rule{一般写像型}{\Lop{map}, \Ruleref{型}, \Lop{to}, \Ruleref{型}}
  
  \Rule{1対1写像型}{\Lop{inmap}, \Ruleref{型}, \Lop{to}, \Ruleref{型}}

\item[等式:] {\tt M = \keyw{map} A \keyw{to} B} または {\tt M =
    \keyw{inmap} A \keyw{to} B}\index{\keyw{map to}}\index{\keyw{inmap to}}

\item[構成子:] \mbox{}

  \begin{description}
  \item[写像列挙:] 
{\tt \{a1 |-> b1, a2 |-> b2, \ldots, an |-> bn\}}
    は、列挙された写からなる写像を構成する。 
空写像は {\tt \{|->\}}と表す。

  \item[写像内包:] {\tt \{ed |-> er | bd1, \ldots, bdn \& P\}}は、述語{\tt P}が \keyw{true}と判断するすべてのありうる束縛上で、式{\tt ed} と {\tt er}を評価することによって写像を構成する。
  \end{description}
すべての写像式の構文と意味定義については、第~\ref{mapexpr}節で述べる。%
\index{\texttt{\{\}}!map enumeration}\index{\texttt{\{"|\}}!map comprehension}\index{\texttt{\&}!map comprehension}


\item[演算子:]\mbox{}

  \begin{tabular}{|l|l|l|}\hline
    演算子 & 名称 & 型 \\ \hline 
    {\tt \keyw{dom} m} & 定義域 & \TO{(\MAP{A}{B})}{\SET{A}} \\
    {\tt \keyw{rng} m} & 値域 & \TO{(\MAP{A}{B})}{\SET{B}} \\
    {\tt m1 \keyw{munion} m2} & 併合 & \TO{\PROD{(\MAP{A}{B})}{(\MAP{A}{B})}}{\MAP{A}{B}} \\
    {\tt m1 ++ m2} & 上書 & \TO{\PROD{(\MAP{A}{B})}{(\MAP{A}{B})}}{\MAP{A}{B}} \\
    {\tt \keyw{merge} ms} & 分配的併合 & \TO{\SET{(\MAP{A}{B})}}{\MAP{A}{B}} \\
    {\tt s <: m} & 定義域限定 & \TO{\PROD{(\SET{A})}{(\MAP{A}{B})}}{\MAP{A}{B}} \\
    {\tt s <-: m} & 定義域削減 & \TO{\PROD{(\SET{A})}{(\MAP{A}{B})}}{\MAP{A}{B}} \\
    {\tt m :> s} & 値域限定 & \TO{\PROD{(\MAP{A}{B})}{(\SET{B})}}{\MAP{A}{B}} \\
    {\tt m :-> s} & 値域削減 & \TO{\PROD{(\MAP{A}{B})}{(\SET{B})}}{\MAP{A}{B}} \\
    {\tt m(d)} & 写像適用 & \TO{\PROD{(\MAP{A}{B})}{A}}{B} \\
    {\tt m1 \keyw{comp} m2} & 写像合成 & \TO{\PROD{(\MAP{B}{C})}{(\MAP{A}{B})}}{\MAP{A}{C}} \\
    {\tt m ** n} & 写像反復 & \TO{\PROD{(\MAP{A}{A})}{\keyw{nat}}}{\MAP{A}{A}} \\
    {\tt m1 = m2} & 相等 & \TO{\PROD{(\MAP{A}{B})}{(\MAP{A}{B})}}{\keyw{bool}} \\
    {\tt m1 <> m2} & 不等 & \TO{\PROD{(\MAP{A}{B})}{(\MAP{A}{B})}}{\keyw{bool}} \\
    {\tt \keyw{inverse} m} & 逆写像 & \TO{\INMAP{A}{B}}{\INMAP{B}{A}} \\
    \hline
  \end{tabular}%
\index{\keyw{dom}}\index{Domain}\index{\keyw{rng}}\index{Range}%
\index{\keyw{munion}}\index{Merge}\index{\texttt{++}!map override}\index{Override}%
\index{\keyw{merge}}\index{Distribute merge}\index{\texttt{<:}}\index{Domain restrict to}%
\index{\texttt{<-:}}\index{Domain restrict by}\index{\texttt{:>}}\index{Range restrict to}%
\index{\texttt{:->}}\index{Range restrict by}\index{\texttt{()}!map apply}\index{Map apply}%
\index{\keyw{comp}!map composition}\index{Map composition}\index{\texttt{**}}\index{Map iteration}%
\index{\texttt{=}!map equality}\index{Equality!map type}\index{\texttt{<>}!map inequality}\index{Inequality!map type}%
\index{\keyw{inverse}}\index{Map inverse}

\item[演算子の意味定義:] ２つの写像 {\tt m1} と {\tt m2} は、{\tt dom m1} と {\tt dom m2}に共通の要素が両写像により同じ値に写像されるならば、両立している。

\vspace{1ex}
\begin{TypeSemantics}
定義域 & {\tt m}の定義域 (キーの集合)。 \\ \hline
値域 & {\tt m}の値域 (情報値の集合)。  \\ \hline
併合 &  {\tt m1} と {\tt m2}が結合した写像で、結果の写像は  {\tt m1}と同様に{\tt dom m1}の要素に、 また{\tt m2}と同様に {\tt dom m2} の要素に、写像を行う。２つの写像は両立していなければならない。 \\ \hline
上書 &  {\tt m1} に {\tt m2}を上書または併合する、つまり\  {\tt m1} と {\tt m2}は必ずしも両立する必要はないということを除けば、併合と似ている。
共通の要素はいずれも {\tt m2} によるものとして写像される(したがって {\tt m2} は{\tt m1}を上書する)。 \\ \hline
分配的併合 &  {\tt ms}に含まれるすべての写像を併合することにより構成される写像。 {\tt ms}に含まれる写像は両立していなければならない。 \\ \hline
定義域限定 & {\tt m}の要素のうちでキーが{\tt s}に含まれるもの、から構成される写像をつくりだす。{\tt s}は {\tt dom m}の部分集合である必要はない。 \\ \hline
値域限定 & {\tt m}の要素のうちで情報値が {\tt s}に含まれるもの、から構成される写像をつくりだす。 {\tt s}は {\tt rng m}の部分集合である必要はない。 \\ \hline
写像の適用 & キーが {\tt d}である写像の情報値。 {\tt d} は {\tt m}の定義域に含まれていなければならない。 \\ \hline
写像の合成 &  {\tt  m2} の要素に {\tt m1} の要素を合成してつくった写像。結果は {\tt m2}と同じ定義域をもった１つの写像である。 あるキーに対応する情報値は、最初に{\tt m2} をキーに適用しその後 {\tt m1} をその結果に適用することによって見つけられるものである。{\tt rng m2}は {\tt  dom m1}の部分集合でなければならない。 \\ \hline
写像の反復 &  {\tt m} からそれ自体を{\tt n}回繰り返すことで構成された写像。 {\tt n = 0} は{\tt dom m}の各々の要素がそれ自体への写像である同一写像； {\tt n = 1} は{\tt m} 自体である。{\tt n > 1}に対して、 {\tt m}の値域は {\tt dom m}の集合でなければならない。\\ \hline
逆写像 & {\tt m}の逆写像。 {\tt m} は１対１写像でなければならない。 \\ \hline
\end{TypeSemantics}

\item[例題:] 次を仮定すると

  {\ttfamily\selectfont
  \begin{tabular}{l}
    m1 = \{ <France> |-> 9, <Denmark> |-> 4, \\
          \mbox{\hspace{3em}}  <SouthAfrica> |-> 2, <SaudiArabia> |-> 1\}, \\
    m2 = \{ 1 |-> 2, 2 |-> 3, 3 |-> 4, 4 |-> 1 \}, \\
    Europe = \{ <France>, <England>, <Denmark>, <Spain> \}
  \end{tabular}}

  以下のとおり：

  \begin{longtable}{lcl}
    \texttt{\keyw{dom} m1}           & $\equiv$ & 
       \texttt{\{}\parbox[t]{5.3cm}{%
           \texttt{<France>, <Denmark>,}\\
           \texttt{<SouthAfrica>, <SaudiArabia>\}}}\\
    \\
    \texttt{\keyw{rng} m1}           & $\equiv$ & \texttt{\{1,2,4,9\}}\\
    \\
    \texttt{m1 \keyw{munion} \{<England> |-> 3\}}
                                     & $\equiv$ & 
       \texttt{\{}%
       \parbox[t]{5.3cm}{\ttfamily\selectfont
          <France> |-> 9, \\
          <Denmark> |-> 4,\\
          <England> |-> 3, \\ 
          <SaudiArabia> |-> 1,\\
          <SouthAfrica> |-> 2\}}\\
    \\
    \texttt{m1 ++ \{\parbox[t]{4cm}{\ttfamily\selectfont
       <France> |-> 8,\\ <England> |-> 4\}}}
                                     & $\equiv$ &
       \texttt{\{}%
           \parbox[t]{5.3cm}{\ttfamily\selectfont
              <France> |-> 8, \\
              <Denmark> |-> 4,\\
              <SouthAfrica> |-> 2, 
              <SaudiArabia> |-> 1,\\
              <England> |-> 4\}}\\
    \\
    
    \texttt{\keyw{merge}\{}
         \parbox[t]{5.7cm}{\ttfamily\selectfont
                 \{<France> |-> 9, \\
                   \mbox{\hspace{0.0cm}} <Spain> |-> 4\} \\
                 \{<France> |-> 9, \\
                    \mbox{\hspace{0.0cm}} <England> |-> 3, \\
                    \mbox{\hspace{0.0cm}} <UnitedStates> |-> 1\}\}}
                                     & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont%
         <France> |-> 9, \\
         <England> |-> 3, \\
         <Spain> |-> 4,\\
         <UnitedStates> |-> 1\}}\\ \\
    \\
    \texttt{Europe <: m1}            & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont
          <France> |-> 9, \\
          <Denmark> |-> 4\}}\\
    \\
    \texttt{Europe <-: m1}           & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont
          <SouthAfrica> |-> 2,\\
          <SaudiArabia> |-> 1\}}\\
    \\
    \texttt{m1 :> \{2,...,10\}}      & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont
          <France> |-> 9, \\
          <Denmark> |-> 4, \\
          <SouthAfrica> |-> 2\}}\\
    \\
    \texttt{m1 :-> \{2,...,10\}}     & $\equiv$ &
       \texttt{\{<SaudiArabia> |-> 1\}}\\
    \\
    \texttt{m1 \keyw{comp} (\{"France" |-> <France>\})}
                                     & $\equiv$ & 
       \texttt{\{"France" |-> 9\}}\\
    \\
    \texttt{m2 ** 3}                 & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont
            1 |-> 4, 2 |-> 1, \\
            3 |-> 2, 4 |-> 3 \}}\\
    \\
    \texttt{\keyw{inverse} m2}       & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont
            2 |-> 1, 3 |-> 2, \\
            4 |-> 3, 1 |-> 4 \}}\\
    \\
    \texttt{m2 \keyw{comp} (\keyw{inverse} m2)} & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont
            1 |-> 1, 2 |-> 2,\\
            3 |-> 3, 4 |-> 4 \}}
  \end{longtable}
\end{description}



\subsubsection{組型}\label{tuples}

組型の値を組と呼ぶ。
組とは固定長のリストであり、組のｉ番目の要素は組型のｉ番目の型に属さなければならない。

\begin{description}
\item[構文:] 
  \Rule{型}{
    \Ruleref{組型} \dsep
    \ldots
    }

  \Rule{組型}{
    \Ruleref{型}, \Lop{{\tt *}}, \Ruleref{型}, \SeqPt{\Lop{{\tt *}}, \Ruleref{型}}
    }

  組型は少なくとも2つの部分型から構成される。

\item[等式：] {\tt T = A1 * A2 * \ldots\ * An}\index{\texttt{*}!組型}

\item[構成子：] 組構成子： {\tt \keyw{mk\_}(a1, a2,
%    \ldots, an)}\index{\keyw{mk\_}!tuple constructor}
    \ldots, an)}\index{\keyw{mk\_}!組構成子}

     組構成子についての構文と意味定義は第~\ref{tupexpr}節で述べられる。 
\item[演算子:] \mbox{}

  \begin{tabular}{|l|l|l|} \hline
    演算子 & 名称 & 型 \\ \hline
    \texttt{t.\#n}   & 選択     & \TO{\PROD{T}{\keyw{nat}}}{Ti}\\
    {\tt t1 = t2}  & 相等   & \TO{\PROD{T}{T}}{\keyw{bool}} \\
    {\tt t1 <> t2} & 不等 & \TO{\PROD{T}{T}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{=}!tuple equality}\index{Equality!tuple}\index{\texttt{<>}!tuple inequality}\index{Inequality!tuple}


  組に対して有効な演算子は、構成要素選択、相等、不等、のみである。
組構成要素は、選択演算子を用いたり組パターンとマッチングさせることで、アクセスすることもできる。
組選択演算子についての意味定義の詳細および使用例は、第 \ref{app-expr}節に述べる。 

\item[例題:]  {\tt a = \keyw{mk\_}(1, 4, 8)}, {\tt b =
    \keyw{mk\_}(2, 4, 8)} とすると以下のとおり:

  \begin{tabular}{lcl}
    {\tt a = b}     &$\equiv$& \keyw{false}\\
    {\tt a <> b}    &$\equiv$& \keyw{true}\\
    {\tt a = \keyw{mk\_}(2,4)} &$\equiv$& \keyw{false}\\
  \end{tabular}
\end{description}

\subsubsection{レコード型}\label{records}

レコード型は、プログラミング言語においての構造体に相当する。
したがってこの型の要素は、前述の組型の節で述べられた組にいくぶんか似ている。
レコード型と組型の違いは、レコードの異なる構成要素は相応の選択関数を用いることで、直接選択することができることである。 
さらに加えて、レコードは操作するとき用いられるべき識別子によってタグ付けされる。一般的な使い方として、タグを与えるためにはただ1つの項目からなるレコードも定義される。
組とのもうひとつの違いは、組は少なくとも2つの実体をもつ必要があるが、レコードは空でもよいところである。

\vdmslpp{\vdmsl,}{\vdmpp,} \keyw{is\_} は名称に対する予約接頭辞であって{\it is式}の中で使用される。 
これは、あるレコード値がどのレコード型に属するのか決定するために用いられる、組込演算子である。
しばしば合併型の部分型同士を区別することに用いられるため、更なる説明が第~\ref{unions}節になされている。 
\keyw{is\_}演算子は、レコード型を決定するのに加え、ある値が基本型のひとつであるかどうかの決定も行うことができる。
 
以下では次の約束に従う： {\tt A}はレコード型、 {\tt A1, \ldots, Am}は任意の型、 {\tt r}, {\tt r1}, {\tt r2}はレコード値、 {\tt i1, \ldots, im}はレコード値 {\tt r}からの選択子、 {\tt e1, \ldots, em}は任意の式である。

\begin{description}
\item[構文:] 
  \Rule{型}{
    \Ruleref{レコード型} \dsep
    \ldots
    }
  
  \Rule{レコード型}{
    \Lop{compose}, \Ruleref{識別子}, \Lop{of}, \Ruleref{項目リスト},
    \Lop{end}
    }
  
  \Rule{項目リスト}{\SeqPt{\Ruleref{項目}}}
  
  \Rule{項目}{\OptPt{\Ruleref{識別子}, \Lit{:}}, \Ruleref{型}
  \dsep  \OptPt{\Ruleref{識別子}, \Lit{:-}}, \Ruleref{型}
  }
  
  または省略型表記法で
  
  \Rule{レコード型}{
    \Ruleref{識別子}, \Lit{::}, \Ruleref{項目リスト}}
  
  この識別子が表すものは型名かタグ名である。

\item[等式:]
\mbox{}\label{a-type}
  \begin{alltt}
    A :: selfirst : A1
         selsec   : A2
  \end{alltt}%
\index{\texttt{::}}

	または

  \begin{alltt}
    A :: selfirst :  A1
         selsec   :- A2
  \end{alltt}%
\index{\texttt{:-}}

	または

  \begin{alltt}
    A :: A1 A2
  \end{alltt}

  2番目の表記では、 {\it 比較対象外\/} 項目
  \index{equality abstraction field} が第2項 {\tt selsec}に対し用いられる。
この負符号は、等号演算子を使ってレコード比較を行うときにこの項が無視されることを指定している。
最後の表記法では {\tt A} の項目はひとつひとつに名称が付けられていないため、パターンマッチングによってのみ(組についてそうだったように)アクセスを行うことができる。
  
省略型表記である {\tt ::} は前の2例でも使われ、タグ名が型名と等しいというものだが、この表記法は最もよく用いられている。
 より一般的である \keyw{compose} 表記法は、次のようにレコード型がそれより複雑な型の構成要素として直接記述されなければならない場合に、典型的に用いられる:

  \begin{alltt}
    T = \keyw{map} S \keyw{to compose} A \keyw{of} A1 A2 \keyw{end}
  \end{alltt}
しかしながら、レコード型は型定義においてのみ用いることができるもので、例えば関数や操作に対するシグネチャにおいてではないことは明記しておくべきであろう。

レコード型は、合併型定義における代案(~\ref{unions}を参照)として、典型的に用いられる:

  \begin{alltt}
   MasterA = A | B | ...
  \end{alltt}
ここで \texttt{A} と \texttt{B} は、自身がレコード型として定義されている。
この状態で、 \keyw{is\_} 前置詞を代案と区別するために用いることができる。

\item[構成子:]
レコード構成子: {\tt \keyw{mk\_}A(a, b)} において、 {\tt a} は型 {\tt A1} に属し {\tt b} は型 {\tt A2}に属す。

 すべてのレコード式に対する構文と意味定義は第~\ref{recexpr}節で与えられる。
%\index{\keyw{mk\_}!record constructor}
\index{\keyw{mk\_}!レコード構成子}

\item[演算子:] 
 \mbox{}

  \begin{tabular}{|l|l|l|} \hline
    演算子 & 名称 & 型 \\ \hline
    {\tt r.i} & 項目選択 & \TO{\PROD{A}{Id}}{Ai} \\
    {\tt r1 = r2} & 相等  & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    {\tt r1 <> r2} & 不等  & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    {\tt \keyw{is\_}A(r1)} & Ｉｓ & \TO{\PROD{Id}{MasterA}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{.}!record field selector}\index{Field select}%
\index{\texttt{=}!record equality}\index{Equality!record}\index{\texttt{<>}!record inequality}\index{Inequality!record}

\item[演算子の意味定義:]  \mbox{}

\begin{TypeSemantics}
項目選択 & レコード値 {\tt r}の中で項目名が {\tt i} である項目の値。
{\tt r} は {\tt i} という名の項目をもっていなければならない。 \\ \hline
\end{TypeSemantics}

\item[例題:] \texttt{Score} は以下のように定義される
\begin{alltt}\label{scoredef}
   Score :: team : Team
            won : \keyw{nat}
            drawn : \keyw{nat}
            lost : \keyw{nat}
            points : \keyw{nat};
   Team = <Brazil> | <France> | ...
\end{alltt}
さらに次の通りとする 

\begin{tabular}{l}
\texttt{sc1 = \keyw{mk\_}Score (<France>, 3, 0, 0, 9)}, \\
\texttt{sc2 = \keyw{mk\_}Score (<Denmark>, 1, 1, 1, 4)},\\
\texttt{sc3 = \keyw{mk\_}Score (<SouthAfrica>, 0, 2, 1, 2)} そして \\
\texttt{sc4 = \keyw{mk\_}Score (<SaudiArabia>, 0, 1, 2, 1)}
\end{tabular}

\noindent%
このとき

  \begin{tabular}{lcl}
    \texttt{sc1.team}            & $\equiv$ & \texttt{<France>}\\
    \texttt{sc4.points}          & $\equiv$ & \texttt{1}\\
    \texttt{sc2.points > sc3.points} 
                                 & $\equiv$ & \keyw{true}\\
    \texttt{\keyw{is\_}Score(sc4)} 
                                 & $\equiv$ & \keyw{true}\\
    \texttt{\keyw{is\_bool}(sc3)}
                                 & $\equiv$ & \keyw{false}\\
    \texttt{\keyw{is\_int}(sc1.won)}
                                 & $\equiv$ & \keyw{true}\\
    \texttt{sc4 = sc1}           & $\equiv$ & \keyw{false}\\
    \texttt{sc4 <> sc2}          & $\equiv$ & \keyw{true}  
  \end{tabular}

  `{\tt :}'の代わりに`{\tt :-}'を用いて記述する比較対象外項目は、たとえばプログラム言語の抽象構文における低水準モデルにおいて役立つことがある。
例としては、識別子の一意性に影響を与えることなく、それらの識別子の型に位置情報項目を加えたい場合などである。

\begin{alltt}
  Id :: name :  seq of char
        pos  :- nat
\end{alltt}

この効果は{\tt pos}項が相等比較において無視されることにあり、たとえば次の例はtrueと評価されるであろう：

\begin{alltt}
  mk_Id("x",7) = mk_Id("x",9)
\end{alltt}

特にこのことは、以下の形の写像の典型的な環境において検索を行う場合に役に立つはずである:

\begin{alltt}
  Env = map Id to Val
\end{alltt}

このような写像は指定の識別子に対し最大1つの索引を含み、写像検索は {\tt pos}項目から独立したものとなる。

そのうえ、比較対象外項目は集合式に影響を与える。
たとえば、 
\begin{alltt}
  \{mk_Id("x",7),mk_Id("y",8),mk_Id("x",9)\}
\end{alltt}

は次と等しくなる

\begin{alltt}
  \{mk_Id("x",?),mk_Id("y",8)\}
\end{alltt}

ここにおける疑問符は7から9までを表している。

最後に比較対象外項目に対する有効なパターンとしては、don't careあるいは識別子パターンに限定されていることには注意しよう。
比較対象外項目は2つの値を比較するときに無視されるものであり、それ以上複雑なパターンを用いることに対しては意味をなさないからである。
\end{description}

\subsubsection{合併型と選択型}\label{unions}

合併型は集合論理における和に相当する、つまり合併型として定義される型はその合併型の構成要素各々からすべての要素を含むことになる。
合併型の中で互いに素であるとはいえない複数の型を用いることは、あまりよくない使用法だが可能ではある。 
しかし通常は、属する型として可能な複数の型から1つを考える場合には合併型が用いられる。 
合併型を構成する型としてしばしばレコード型がある。
\keyw{is\_}演算子を用いることで、合併型のある値がこういった型のいずれに属するものであるのかを決定することが可能である。

選択型 {\tt [T]} とは合併型{\tt T | \keyw{nil}}に対してのいわゆる省略であり、 この\keyw{nil} は値が存在しないことを表記するために用いられるものである。
ただし集合 {\tt \{\keyw{nil}\}}をひとつの型として用いることはできないので、 \keyw{nil}を含む型のみが選択型となりうる。 


\begin{description}
\item[構文:] 
  \Rule{型}{
    \Ruleref{合併型} \dsep
    \Ruleref{選択型} \dsep
    \ldots
    }
  
  \Rule{合併型}{
    \Ruleref{型}, \Lit{|}, \Ruleref{型}, \SeqPt{\Lit{|}, \Ruleref{型}}
    }
  
  \Rule{選択型}{\Lit{[}, \Ruleref{型}, \Lit{]}}

\item[等式:] {\tt B = A1 | A2 | \ldots\ | An}%
\index{\texttt{|}!union type}\index{\texttt{[]}!optional type}

\item[構成子:] なし

\item[演算子:] \mbox{}

  \begin{tabular}{|l|l|l|}\hline
    演算子 & 名称 & 型 \\ \hline
    {\tt t1 = t2} & 相等 & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    {\tt t1 <> t2} & 不等 & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{=}!union equality}\index{Equality!union type}%
\index{\texttt{<>}!union inequality}\index{Inequality!union type}%
\index{\texttt{=}!optional equality}\index{Equality!optional type}%
\index{\texttt{<>}!optional inequality}\index{Inequality!optional type}


\item[例題:] この例題中で 
  {\tt Const}, {\tt Var}, {\tt Infix} および {\tt Cond} は省略 {\tt ::} 記法を用いて定義されたレコード型であることから、{\tt Expr} は合併型である。

  \begin{alltt}\label{exprdef}
    Expr  = Const | Var | Infix | Cond;
    Const :: \keyw{nat} | \keyw{bool};
    Var   :: id:Id
             tp: [<Bool> | <Nat>];
    Infix :: Expr * Op * Expr;
    Cond  :: test : Expr
             cons : Expr
             altn : Expr
  \end{alltt}    
  また {\tt expr = \keyw{mk\_}Cond(\keyw{mk\_}Var("b",<Bool>),%
    \keyw{mk\_}Const(3),}\\ {\tt \keyw{mk\_}Var("v",\keyw{nil}))} とすると:

  \begin{tabular}{lcl}\label{exprIsExs}
    {\tt \keyw{is\_}Cond(expr)} &$\equiv$& \keyw{true}\\
    {\tt \keyw{is\_}Const(expr.cons)} &$\equiv$& \keyw{true}\\
    {\tt \keyw{is\_}Var(expr.altn)}   &$\equiv$& \keyw{true}\\
    {\tt \keyw{is\_}Infix(expr.test)}  &$\equiv$& \keyw{false}\\
  \end{tabular}

  合併型を用いることで、今までで定義してきた演算子の使用を拡張することができる。たとえば \texttt{=}を \texttt{\keyw{bool} | \keyw{nat}}上でのテストと解釈することで次を得る。
 
 \begin{tabular}{lcl}
    \texttt{1 = \keyw{false}}    & $\equiv$ & \keyw{false}
  \end{tabular}

  同様に、集合の合併や列の連結の代わりに合併型を用いることができる:
  
  \begin{tabular}{lcl}
     \texttt{ \{1,2\} \keyw{union} \{\keyw{false},\keyw{true}\}}
                                 & $\equiv$ & 
        \texttt{\{1,2, \keyw{false},\keyw{true}\}}\\
     \texttt{ ['a','b']\char'136 [<c>,<d>]}
                                 & $\equiv$ &
        \texttt{['a','b', <c>,<d>]}
  \end{tabular}

集合合併においては、 \texttt{\keyw{nat} | \keyw{bool}}型の集合上での合併を考える；一方列連結に対しては、 \texttt{\keyw{char} | <c> | <d>}型の列を操作している。 \end{description}


\subsubsection{関数型}

\vdmslpp{\vdmsl}{\vdmpp}では関数型もまた型定義に用いることができる。
型{\tt A} (実際は型のリスト) から型 {\tt B}への関数型というのは、型 {\tt A} の各々の要素に対して {\tt B}の要素を結びつける型である。
関数の値は、プログラム言語においての関数と同じもので他に副作用をおよぼすことのない(つまりグローバル変数を使用していない)ものとして考えることができる。

このような用い方は、関数が値として用いられるという意味で上級向けの使用法と考えることができる(したがって初読ではこの節はとばしていただいてもよい)。
関数値は、ラムダ式 (以下を参照)によって生成されることもあるし、第~\ref{functiondef}節に述べる関数定義による場合もある。 
関数値は、関数を引数としたりまた戻り値にすることができるという意味で、高階なものとなり得る。
この方法を用いれば、最初のパラメーターの組が与えられると新しい関数が1つ返されるというように、関数はカリー化されることが可能である (次の例題を参照)。

%Type definitions may not be recursive {\it through} function types, though
%they may be recursive {\it over} them. That is, no chain of
%definitions derived from a set of recursive type definitions from a
%type back to itself may pass through a function type operator (see the
%next subsection for more information about recursive type
%definitions). Thus, a type definition like {\tt A = A -> A |
%\keyw{bool}} is illegal while a type definition like: {\tt A = A * A |
%(\keyw{nat} -> \keyw{nat})} is legal.

\begin{description}
\item[構文:]
  \Rule{型}{
    \Ruleref{関数型} \dsep
    \ldots
    }
  
  \Rule{関数型}{
    \Ruleref{部分関数型} \dsep
    \Ruleref{全関数型}
    }

  \Rule{部分関数型}{
    \Ruleref{任意の型}, \Lit{->}, \Ruleref{型}}
  
  \Rule{全関数型}{
    \Ruleref{任意の型}, \Lit{+>}, \Ruleref{型}}
  
  \Rule{任意の型}{\Ruleref{型} \dsepl \Lit{(},\Lit{)}} 
  
\item[等式:] {\tt F = A +> B}\footnote{全関数矢印は全定義関数のシグネチャにおいてのみ用いることができ、型定義においては用いることはできないことに注意したい。} または {\tt F = A -> B}%
\index{\texttt{->}}\index{\texttt{+>}}

\item[構成子:] 伝統的な関数定義に加えて、関数を構成する唯一の方法がラムダ式によるものである: {\tt \keyw{lambda} pat1 : T1, \ldots, patn : Tn \& body}
ここにおける {\tt patj} はパターン、 {\tt Tj} は型式、そして{\tt body} は本体式で全パターンよりパターン識別子を用いることが許されている。

  ラムダ式に対する構文や意味定義は、第~\ref{lambda}節にある。
\item[演算子:] \mbox{}

  \begin{tabular}{|l|l|l|} \hline
    演算子 & 名称 & 型 \\ \hline
    {\tt f(a1,\ldots,an)} & 関数適用 & \TO{A1 * \cdots * An}{B} \\
    {\tt f1 \keyw{comp} f2}& 関数合成 & \TO{\PROD{(\FUN{B}{C})}{(\FUN{A}{B})}}{(\FUN{A}{C})} \\
    {\tt f ** n} & 関数反復 & \TO{\PROD{(\FUN{A}{A})}{\keyw{nat}}}{(\FUN{A}{A})} \\
    {\tt t1 = t2} & 相等 & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    {\tt t1 <> t2} & 不等 & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{=}!function equality}\index{Equality!function type}\index{\texttt{<>}!function inequality}\index{Inequality!function type}%
\index{\keyw{comp}!function composition}\index{Function composition}%
\index{\texttt{**}!function iteration}\index{Function iteration}%
\index{\texttt{()}!function apply}\index{Function apply}
  
 型値間での相等と不等については、最大の注意を払うべきである。
 \vdmslpp{\vdmsl}{\vdmpp}\ においてこれは、数学上の相等 (または不等)に相等するが、一般関数と同様に無限値に対して計算不能となる。
このように、インタプリターでの相等は関数値の抽象構文上のものである ( 以下の{\tt
    inc1}と {\tt inc2}を参照)。

\item[演算子の意味定義:]  \mbox{}

\begin{TypeSemantics}
関数適用 & 関数 {\tt f}を {\tt a$_j$}の値に適用した結果。
第 \protect\ref{app-expr}章の適用式の定義を参照のこと。 \\ \hline
関数合成 & 最初に {\tt f2}を適用して次はその結果に {\tt f1} を適用することと同等な関数。
{\tt f1}はカリー化されてもよいが，{\tt f2}はいけない。 \\ \hline
関数繰り返し & {\tt  f}を{\tt n}回適用することと同等な関数。 {\tt n = 0} の場合はそのパラメーター値をそのまま返す恒等関数となる。 {\tt n = 1} の場合はその関数自身となる。 {\tt n > 1}の場合、 {\tt f} の戻り値はそれ自身のパラメーター型に含まれるものでなければならない。 \\ \hline
\end{TypeSemantics}

\item[例題:]  以下に関数の値を定義してみよう:
  \begin{alltt}
    f1 = \keyw{lambda} x : \keyw{nat} \& \keyw{lambda} y : \keyw{nat} \& x + y
    f2 = \keyw{lambda} x : \keyw{nat} \& x + 2
    inc1 = \keyw{lambda} x : \keyw{nat} \& x + 1
    inc2 = \keyw{lambda} y : \keyw{nat} \& y + 1
  \end{alltt}
  ここで次のことが導かれる:
  
  \begin{tabular}{lcl}
    {\tt f1(5)} &$\equiv$& {\tt \keyw{lambda} y :\keyw{nat} \& 5 + y}\\
    {\tt f2(4)} &$\equiv$& {\tt 6}\\
    {\tt f1 \keyw{comp} f2}&$\equiv$& {\tt \keyw{lambda} x :\keyw{nat} \&
      \keyw{lambda} y :\keyw{nat} \& (x + 2) + y}\\
    {\tt f2 ** 4}&$\equiv$& {\tt \keyw{lambda} x :\keyw{nat} \& x + 8}\\
    {\tt inc1 = inc2}&$\equiv$& \keyw{false}\\
  \end{tabular}
  
 相等判定は、\vdmslpp{\vdmsl}{\vdmpp}の意味定義に基づいての期待される結果に従うものではないことに注意したい。 
このように、関数といった無限値に対する相等の使用には{\bf 十分}注意深くなる必要がある。
\end{description}

%\subsection{Recursive Types}
%
%In the data type equations given so far we have only used the equations in
%a hierarchical manner (the data type identifiers occurring on the
%right-hand-side in the equations have already been defined).  However,
%there are occasions when it is appropriate to use a collection of
%equations which are mutually recursive. 
%
%Without going into the mathematical details about how such recursive
%equations are solved, it will shortly be explained what they denote and how
%their usage must be restricted. We define that the semantics of such a
%collection of mutually recursive equations is that the data types become
%the set of all those values which can be constructed by using the equations
%a finite number of times. Thus, types containing infinite values cannot be
%constructed by means of recursive definitions.
%
%In order to achieve this, the recursive equations need to fulfill two
%requirements:
%\begin{enumerate}
%\item There must exist at least one alternative in a union type which is
%  fully defined elsewhere (a so-called base case).
%
%\item It must not be possible for a data value to belong to two different
%  alternatives in a union type. Thus, for recursive equations the
%  alternatives in union types must be disjunct.
%\end{enumerate}
%If these two requirements are fulfilled then the recursive type definitions
%are interpreted as the collection of finite values which are constructed by
%a finite number of steps in this process.
%
%To illustrate the use of recursive type definitions here is an example
%modelling a forest using recursive type definitions.
%
%\begin{alltt}
%  Forest = Forest * Node * Forest;
%  Node = \keyw{nat} | Forest
%\end{alltt}
%
%\noindent It is clear that the first requirement (1) cannot be fulfilled,
%because there is no base case for the forest type. Thus, these type
%definitions only specify infinite forests, and thus are not valid in
%\vdmslpp{\vdmsl}{\vdmpp}.
%
%Let us try to repair this by letting a node be the base case in the
%first definition:
%
%\begin{alltt}
%  Forest = Node | (Forest * Node * Forest);
%  Node = \keyw{nat} | Forest
%\end{alltt}
%
%\noindent However, these two definitions do not fulfill the second
%requirement. This can be seen from the fact that a forest can be a node, and 
%that node in turn can be a forest, etc. In this case it is not possible to say
%which alternative a given value belongs to. Thus, these definitions are
% not valid in \vdmslpp{\vdmsl}{\vdmpp}\ either.
%
%Now let us try to repair it by letting the base case be empty (i.e.\ 
%a nil value):
%
%\begin{alltt}
%  Forest = [Forest * Node * Forest];
%  Node = \keyw{nat} | Forest
%\end{alltt}
%
%\noindent These definitions are valid, but they specify something slightly
%different than the intention behind the definitions above. With these
%definitions an empty forest exists, and this is not the case for the
%definitions above.
%
%Finally we try to repair it by means of tagging:
%
%\begin{alltt}
%  Forest = Node | (Forest * Node * Forest);
%  Node :: \keyw{nat} | Forest
%\end{alltt}
%
%\noindent By making {\tt Node} a composite type, the definitions are valid,
%because the second requirement is also fulfilled here, due to tagging of
%the node. With these definitions an empty forest will not exist.
%
\subsection{不変条件}

もし先に述べた等式によって指定されたデータ型が許されるべきでない値を含むような場合、それは1つの不変条件により1つの型の値に制限することができる。
結果として、その型はもともとの値の部分集合に制限されるということである。
このように、述語の手段によって、定義された型の条件にかなう値はこの式がtrueとなる値に制限されるのである。

不変条件の使用についての一般的構成は次の通り:

\begin{alltt}
  Id = Type
  \keyw{inv} pat == expr
\end{alltt}

\noindent 
 ここで {\tt pat}は{\tt Id}型に属する値にマッチングさせるパターンであり、{\tt expr}はtrueとなる式であり、パターン{\tt pat}から識別子のいくつかまたはすべてを含んでいる。

ある不変条件が定義された場合、1つの新しい (全) 関数がシグネチャと共に暗黙に生成される:
\begin{alltt}
  \keyw{inv\_}Id : Type +> \keyw{bool}
\end{alltt}

この関数は、他の不変条件、関数、あるいは操作の定義中で用いることも可能である。

たとえば、\pageref{scoredef}ページ上に定義されたレコード型\texttt{Score}を思い返してみよう。
不変条件を用いることで、得点数は勝つか引き分けたゲームの数と一致する、ということが保障できる:
\begin{alltt}
  Score :: team : Team
           won : nat
           drawn : nat
           lost : nat
           points : nat
  inv sc == sc.points = 3 * sc.won + sc.drawn;
\end{alltt}
この型に対して暗黙に作成される不変条件関数は次の通り:
\begin{alltt}
  \keyw{inv\_}Score : Score +> \keyw{bool}
  \keyw{inv\_}Score (sc) == 
    sc.points = 3 * sc.won + sc.drawn;
\end{alltt}

\section{アルゴリズム定義}
\label{algorithm}


\vdmslpp{\vdmsl}{\vdmpp}では、アルゴリズムが関数と操作の両方により定義できる。 
しかしながら、伝統的なプログラム言語における関数にただちに相当するというものではない。
\vdmslpp{\vdmsl}{\vdmpp}において関数と操作を区別するものは、ローカルおよびグローバル変数の使用である。
操作は、グローバル変数といくらかのローカル変数の両方を扱うことができる。
ローカル変数とグローバル変数の両者については後に述べられる。
関数は、グローバル変数にアクセスすることはできないしローカル変数を定義することも許されていないという意味で、純粋なものである。
このように、操作が命令的なものである一方で、関数は純粋に作用的なものである。

関数と操作は、陽に(明確なアルゴリズム定義によって)あるいは陰に(事前条件または事後条件によって)、両方法で定義することができる。
関数に対する明示的なアルゴリズム定義を式と呼ぶ一方、操作に対するそれは文と呼ぶ。事前条件は、関数や操作が評価される前に何を保持していなくてはならないかを指定するtrueの値をとる式である。
事前条件は、パラメーター値と(操作の場合は)グローバル変数のみを参照することができる。
%事前条件のみは(それが操作である場合に)パラメーター値やグローバル変数を参照することができる。
事後条件もまた、関数や操作が評価された後に何が保持されなければならないかを指定するtrueの値をとる式である。
事後条件は、結果識別子、パラメーター値、グローバル変数の現在値、そしてグローバル変数の旧値、を参照することができる。
グローバル変数の旧値とは、操作が評価される前の変数の値のことである。
関数ではグローバル変数の変更は許されていないが、操作だけはグローバル変数の旧値を参照することができる。

しかしながら、インタープリタにより関数と操作の両方の実行を可能にするためには、それらは明示的に定義されていなければならない\footnote{陰関数と陰操作は一般的に実行できない。というのもそれらの事後条件は出力を入力へ直接関係づけるものとは限らないからである。事後条件として出力が満たさなくてはならないプロパティを指定するときに、しばしばそのようになる。}。
\vdmslpp{VDM-SL}{\vdmpp}では、陽関数および操作定義に対して追加の事前または事後条件を指定することもできる。
陽関数および操作定義の事後条件において、結果の値は予約語 \keyw{RESULT}によって参照されなければならない。
 
\section{関数定義}\label{functiondef}

\vdmslpp{VDM-SL}{\vdmpp}では、1階関数と高階関数を定義することができる。 
高階関数とは、カリー化関数(結果として関数を返す関数)かまたは関数を引数にとる関数である。
さらには、1階のものも高階のものもいずれも多相であることが可能である。
一般的に、ある関数を定義するための構文は次の通り:

\Rule{関数定義}{
  \Lop{functions}, 
  \OptPt{\ifthenelse{\boolean{VDMpp}}{\Ruleref{アクセス関数定義}}%
                                     {\Ruleref{関数定義}}, \lfeed
         \SeqPt{\Lit{;}, 
                \ifthenelse{\boolean{VDMpp}}{\Ruleref{アクセス関数定義}}%
                                     {\Ruleref{関数定義}}}, 
         \OptPt{\Lit{;}}
        }
  }

\ifthenelse{\boolean{VDMpp}}{
  \Rule{アクセス関数定義}{
    (\OptPt{\Ruleref{アクセス}}, \OptPt{\Lop{static}})  \dsepl\  (\OptPt{\Lop{static}}, \OptPt{\Ruleref{アクセス}}), \lfeed
      \Ruleref{関数定義}
  }}{}


\ifthenelse{\boolean{VDMpp}}{
  \Rule{アクセス}{
    \Lop{public} \dsep \Lop{private} \dsep \Lop{protected}
  }
}{}

\Rule{関数定義}{
  \Ruleref{陽関数定義} \dsep
  \Ruleref{陰関数定義} \dsep
  \Ruleref{拡張陽関数定義}
  }

\Rule{陽関数定義}{
  \Ruleref{識別子}, 
\lfeed
  \OptPt{\Ruleref{型変数リスト}}, 
  \Lit{:}, \Ruleref{関数型}, \lfeed
  \Ruleref{識別子}, \Ruleref{パラメーターリスト}, \Lit{$==$}, \lfeed
  \Ruleref{関数本体}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{式}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{式}}, \lfeed

  \OptPt{\Lop{measure}, \Ruleref{名称}}
  }                                 

\Rule{陰関数定義}{
  \Ruleref{識別子}, 
  \OptPt{\Ruleref{型変数リスト}},\lfeed
  \Ruleref{パラメーター型}, \Ruleref{識別子型ペアリスト}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{式}}, \lfeed
  \Lop{post}, \Ruleref{式}
}

\Rule{拡張陽関数定義}{
  \Ruleref{識別子}, \OptPt{\Ruleref{型変数リスト}}, \lfeed
  \Ruleref{パラメーター型},\lfeed
  \Ruleref{識別子型ペアリスト}, \lfeed
  \Lit{==}, \Ruleref{関数本体}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{式}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{式}}
}

\Rule{型変数リスト}{
  \Lit{[}, \Ruleref{型変数識別子}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{型変数識別子}}, \Lit{]}
  }

\Rule{識別子型ペアリスト}{
  \Ruleref{識別子}, \Lit{:}, \Ruleref{型}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{識別子}, \Lit{:}, \Ruleref{型}}
}

\Rule{パラメーター型}{
  \Lit{(}, \OptPt{\Ruleref{パターン型ペアリスト}}, \Lit{)}
  }

\Rule{パターン型ペアリスト}{
  \Ruleref{パターンリスト}, \Lit{:}, \Ruleref{型}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{パターンリスト},\Lit{:}, \Ruleref{型}}
  }

\Rule{関数型}{
  \Ruleref{部分関数型} \dsep
  \Ruleref{全関数型}
  }

\Rule{部分関数型}{
  \Ruleref{任意の型}, \Lit{->}, \Ruleref{型}
  }

\Rule{全関数型}{
  \Ruleref{任意の型}, \Lit{+>}, \Ruleref{型}
  }

\Rule{任意の型}{
  \Ruleref{型} \dsepl \Lit{(},\Lit{)}
  }

\Rule{パラメーター群}{
  \Lit{(}, \OptPt{\Ruleref{パターンリスト}}, \Lit{)}
  }

\Rule{パターンリスト}{
  \Ruleref{パターン},\SeqPt{\Lit{,}, \Ruleref{パターン}}
  }

\Rule{関数本体}{
  \Ruleref{式} \dsep 
  \Lop{is not yet specified}\index{\keyw{is not yet specified}!functions}
  }

ここで、あるモデルが発展過程にある間は\keyw{is not yet specified}の指定が関数本体として用いられることが許されている%
。


陽関数定義の簡単な例は関数\texttt{map\_inter}であり、これは自然数上の2つの両立する写像をもってきて、両者に共通する写を返すものである
\begin{alltt}
  map_inter: (\keyw{map nat to nat}) * (\keyw{map nat to nat}) -> \keyw{map nat to nat}
  map_inter (m1,m2) ==
    (\keyw{dom} m1 \keyw{inter} \keyw{dom} m2) <: m1
  \Keyw{pre} \keyw{forall} d \keyw{in set dom} m1 \keyw{inter dom} m2 & m1(d) = m2(d)
\end{alltt}
関数結果についての主張を許すために選択事後条件をさらにまた用いることができることにも注意しよう:
\begin{alltt}
  map_inter: (\keyw{map nat to nat}) * (\keyw{map nat to nat}) -> \keyw{map nat to nat}
  map_inter (m1,m2) ==
    (\keyw{dom} m1 \keyw{inter} \keyw{dom} m2) <: m1
  \Keyw{pre} \keyw{forall} d \keyw{in set dom} m1 \keyw{inter dom} m2 & m1(d) = m2(d)
  \Keyw{post} \keyw{dom} \keyw{RESULT} = \keyw{dom} m1 \keyw{inter} \keyw{dom} m2
\end{alltt}

同じ関数が暗黙的にまた定義されることも可能である:
\begin{alltt}
  map_inter2 (m1,m2: \keyw{map nat to nat}) m: \keyw{map nat to nat}
  \Keyw{pre} \keyw{forall} d \keyw{in set dom} m1 \keyw{inter dom} m2 & m1(d) = m2(d)
  \Keyw{post} \keyw{dom} m = \keyw{dom} m1 \keyw{inter dom} m2 and
       \keyw{forall} d \keyw{in set dom} m & m(d) = m1(d);
\end{alltt}

拡張陽関数定義(標準ではない)の簡単な例は関数 \texttt{map\_disj} で、これは自然数上で2つの両立する写像を持ってきて、それらのどちらかの写像に対して唯一の写からなる写像を返す:

\begin{alltt}\label{mapdisj}
  map_disj (m1:\keyw{map nat to nat},m2:\keyw{map nat to nat}) res : \keyw{map nat to nat} ==
    (\keyw{dom} m1 \keyw{inter dom} m2) <-: m1 \keyw{munion}
    (\keyw{dom} m1 \keyw{inter dom} m2) <-: m2
  \Keyw{pre} \keyw{forall} d \keyw{in set dom} m1 \keyw{inter dom} m2 & m1(d) = m2(d)
  \Keyw{post} \keyw{dom} res = (\keyw{dom} m1 \keyw{union dom} m2) \verb+\+ (\keyw{dom} m1 \keyw{inter dom} m2) 
       and
       \keyw{forall} d \keyw{in set dom} res & res(d) = m1(d) or res(d) = m2(d)
\end{alltt}
(ここにおいて事後条件をインタープリタに通す試みは、もしかすると実行時エラーを引き起こすかもしれない、というのは \texttt{m1(d)} と\texttt{m2(d)}は同時に両者が定義される必要はないからなのである。)

関数 {\tt map\_inter} と {\tt map\_disj} はインタプリターにより評価することが可能であるが、暗黙的関数である {\tt map\_inter2} は評価することができない。
しかしながら、これら3つの場合における事前条件と事後条件は他の関数のなかで使用することが可能である; たとえば\texttt{map\_inter2}の定義から、関数 \texttt{\keyw{pre\_}map\_inter2}と \texttt{\keyw{post\_}map\_inter2}を以下のシグネチャで得る:

\begin{alltt}
  \keyw{pre\_}map_inter2 : (\keyw{map nat to nat}) * (\keyw{map nat to nat}) +> \keyw{bool}
  \keyw{post\_}map_inter2 : (\keyw{map nat to nat}) * (\keyw{map nat to nat}) *
                   (\keyw{map nat to nat}) +> \keyw{bool}
\end{alltt}
これらの種類の関数は自動的にインタープリタで作成され、他の定義においても用いることができる(この技術は引用とよばれる)。
一般的に、次のシグネチャをもつ関数 \texttt{f} に対して
\begin{alltt}
  f : T1 * ... * Tn -> Tr
\end{alltt}
関数に対する事前条件を定義することで、次のシグネチャの関数 \texttt{\keyw{pre\_}f}が生成される。
\begin{alltt}
  \keyw{pre\_}f : T1 * ... * Tn +> bool
\end{alltt}
そして関数に対する事後条件を定義することで、次のシグネチャの関数 \texttt{\keyw{post\_}f} が生成される。
\begin{alltt}
  \keyw{post\_}f : T1 * ... * Tn * Tr +> bool
\end{alltt}

関数は再帰 (自分自身の呼び出し) を使って定義することもできる。
再帰呼び出しを使う場合、\Lop{measure} 関数を追加することが推奨される。
これによって、実行が終了すること保証する証明課題を生成することができるようになる。
シンプルな階乗関数の例を以下に定義する:

\begin{alltt}
functions

fac: nat +> nat
fac(n) ==
  if n = 0
  then 1
  else n * fac(n - 1)
measure id
\end{alltt}
ここで、 \texttt{id}は以下のように定義されている:
\begin{alltt}
id: nat +> nat
id(n) == n
\end{alltt}

\subsection{多相関数}

関数はまた多相であることが可能である。
これは、複数の異なる型の値のもとに使用可能な包括的な関数を生成することができるということを意味する。
この目的のために、型引数 (または接頭辞{\tt @}記号をおき通常の識別子と同様に記述された型変数) が用いられる。
空のバッグをつくりだすための多相関数を考える:
\footnote{多相関数の例は\cite{Dawes91}から引用する。
バッグというのは、バッグの中での要素からその要素の重複度への写像をモデル化したものである。 
ここでの重複度は少なくも1以上であり、つまり要素がないならこの写像の役目は負えないので、0に写像されるものではない。}
\begin{alltt}
  empty_bag[@elem] : () +> (\keyw{map} @elem \keyw{to nat1})
  empty_bag() ==
    \{ |-> \}
\end{alltt}
上記の関数が使用できる以前のこととして、関数 {\tt empty\_bag}の、たとえば整数といったある型のインスタンス生成を行わなくてはならない:
\begin{alltt}
  emptyInt = empty_bag[int]
\end{alltt}
さぁこれで整数をいれるための新しいバッグをつくるために、関数 {\tt emptyInt} を使用することができる。
更なる多相関数の例としては:
\begin{alltt}
  num_bag[@elem] : @elem * (\keyw{map} @elem \keyw{to nat1}) +> \keyw{nat}
  num_bag(e, m) ==
    \keyw{if} e \keyw{in set dom} m
    \Keyw{then} m(e)
    \Keyw{else} 0;

  plus_bag[@elem] : @elem * (\keyw{map} @elem \keyw{to nat1}) +> (\keyw{map} @elem \keyw{to nat1})
  plus_bag(e, m) ==
    m ++ \{ e |-> num_bag[@elem](e, m) + 1 \}
\end{alltt} 
もし事前条件や事後条件が多相関数に対して定義された場合は、対応する述語関数もまた多相である。
たとえばもし \texttt{num\_bag}が下記のように定義されていたとすると
\begin{alltt}
  num_bag[@elem] : @elem * (\keyw{map} @elem \keyw{to nat1}) +> \keyw{nat}
  num_bag(e, m) ==
    m(e)
  \Keyw{pre} e \keyw{in set dom} m
\end{alltt}
事前条件は次のようになるであろう
\begin{alltt}
  \keyw{pre\_}num_bag[@elem] :@elem * (\keyw{map} @elem \keyw{to nat1}) +> \keyw{bool}
\end{alltt}


また、\keyw{measure}は機能が多相的に定義された時も使用されるべきである。
ただし、現在は \keyw{measure} を高階関数では使うことができない。

\subsection{高階関数}

関数は他の関数を引数として受け取ることが許される。
この簡単な例は、自然数の列となる関数\texttt{nat\_filter} であり、1つの述語をもち、この述語を満足させる部分列を返すものである:
\begin{alltt}
  nat_filter : (\keyw{nat} -> \keyw{bool}) * \keyw{seq of nat} -> \keyw{seq of nat}
  nat_filter (p,ns) ==
    [ns(i) | i \keyw{in set inds} ns & p(ns(i))];
\end{alltt}
このとき 
  \texttt{nat\_filter (\keyw{lambda} x:\keyw{nat} \& x \keyw{mod} 2 = 0, [1,2,3,4,5])} $\equiv$ \texttt{[2,4]}.
実際、このアルゴリズムは自然数に限ったものではない、したがってこの関数の多相版を定義してもよいであろう:
\begin{alltt}\label{filterdef}
  filter[@elem]: (@elem -> \keyw{bool}) * \keyw{seq of} @elem -> \keyw{seq of} @elem
  filter (p,l) ==
    [l(i) | i \keyw{in set inds} l & p(l(i))];
\end{alltt}
so \texttt{filter[\keyw{real}](\keyw{lambda} x:\keyw{real} \&
  \keyw{floor} x = x, [2.3,0.7,-2.1,3])} $\equiv$  \texttt{[3]}.

関数はまた結果として関数を返してもよい。
これの例は関数 \texttt{fmap}である:
\begin{alltt}
  fmap[@elem]: (@elem -> @elem) -> \keyw{seq} of @elem -> \keyw{seq} of @elem
  fmap (f)(l) ==
    \keyw{if} l = []
    \keyw{then} []
    else [f(\keyw{hd} l)]\verb+^+(fmap[@elem] (f)(\keyw{tl} l));
\end{alltt}
よって 
 \texttt{fmap[\keyw{nat}](\keyw{lambda} x:\keyw{nat} \& x * x)([1,2,3,4,5])} $\equiv$ 
\texttt{[ 1,4,9,16,25 ]}
\section{式}

この中の節では異なる種類の式の1つ1つについて述べていこう。
各々を次の方法で記述する:
\begin{itemize}
\item BNF構文記法
\item 非公式な意味定義記述
\item 使用の記述例
\end{itemize}

\subsection{let式}\label{let-exp}

\begin{description}
\item[構文:]
  \Rule{式}{
    \Ruleref{let式} \dsep
    \Ruleref{let be式} \dsep
    \ldots
    }

  \Rule{let式}{
    \Lop{let}, 
    \Ruleref{ローカル定義}
    \SeqPt{\Lit{,}, \Ruleref{ローカル定義}}, \lfeed
    \Lop{in}, \Ruleref{式}
    }

  \Rule{let be式}{ 
    \Lop{let}, \Ruleref{束縛},
    \OptPt{\Lop{be}, \Lop{st}, \Ruleref{式}}, \Lop{in}, \lfeed
    \Ruleref{式}
    } 

  \Rule{ローカル定義}{
    \Ruleref{値定義} \dsep
    \Ruleref{関数定義}
    }

  \Rule{値定義}{ 
    \Ruleref{パターン}, \OptPt{\Lit{:}, \Ruleref{型}}, \Lit{=}, \Ruleref{式}
    }

  \noindent ここでの構成要素である ``関数定義'' は第~\ref{functiondef}節で述べられている。

\item[意味定義:] 単純な {\it let式} は次の形式をもつ:
  \begin{alltt}
    \keyw{let} p1 = e1, \ldots, pn = en \keyw{in} e
  \end{alltt}
ここで、 {\tt p1, \ldots, pn} はパターン、 {\tt e1, \ldots, en} はそれぞれの対応パターン {\tt pi}にマッチさせる式であって、{\tt e} は任意の型でよいが {\tt p1, \ldots, pn}の中のパターン識別子を含む式である。 
これは、パターン{\tt p1,\ldots, pn}が対応する式{\tt e1, \ldots, en}とマッチさせられる文脈中での、式 {\tt e}の値を示している。 

 ローカル関数定義を用いることで、より発展した形のlet式をつくることもできる。
そのようなことを行う意味は単に、このようなローカル定義関数のスコープはlet式の本体に制限されているということにある。

標準の \vdmsl\ においては、定義の収集が相互に再帰するものとなる可能性がある。
しかしながら\vdmslpp{\vdmsl}{\vdmpp}においては、このようなものがインタープリタでサポートされることはない。 
さらに、すべての構成子が使用される前に定義されているように、定義に順番付けがされていなければならない。
     
   {\it let-be-such-that 式}は次の形式をもつ:
  \begin{alltt}
    \keyw{let} b \keyw{be st} e1 \keyw{in} e2
  \end{alltt}%
ここでは、 {\tt b} は集合値(または型)に対する束縛で、 {\tt e1}は ブール式、 {\tt e2} は式だが何の型であってもよく、{\tt b}におけるパターンのパターン識別子を含むものである。
 {\tt \keyw{be st} e1} 部分はオプション。
この式は、{\tt b}のパターンが{\tt b}の集合要素かまたは{\tt b}の中の型の値とマッチさせる文脈中での式 {\tt e2}の値を示す
  \footnote{集合束縛のみはインタープリタによって実行できることを思い出そう。}。 {\tt \keyw{st} e1}式がある場合は、マッチングの文脈中で{\tt e1}がtrueとなる束縛のみが用いられる。

\item[例題:] {\it let式} は読みやすさの改善に役立つ、特に何回も使われる複雑な式は縮めることで改善される。
たとえば \pageref{mapdisj}ページの関数 \texttt{map\_disj}を改善することができる:\begin{alltt}
  map_disj : (\keyw{map nat to nat}) * (\keyw{map nat to nat}) -> \keyw{map nat to nat}
  map_disj (m1,m2) ==
    \keyw{let} inter_dom = \keyw{dom} m1 \keyw{inter dom} m2
    \keyw{in}
      inter_dom <-: m1 \keyw{munion}
      inter_dom <-: m2
  \Keyw{pre} \keyw{forall} d \keyw{in set dom} m1 \keyw{inter dom} m2 & m1(d) = m2(d)
\end{alltt}
また複雑な構造体を構成要素に分解する上でも便利である。
たとえば、前に定義したレコード型 \texttt{Score} (\pageref{scoredef}ページ) を使用することで、あるスコアがもうひとつより大きいかどうかをテストすることができる:
  \begin{alltt}
    \keyw{let} \keyw{mk\_}Score(-,w1,-,-,p1) = sc1,
       \keyw{mk\_}Score(-,w2,-,-,p2) = sc2
    \keyw{in} (p1 > p2) \keyw{or} (p1 = p2 \keyw{and} w1 > w2)
  \end{alltt}
この特別な例では、2つのスコアから2番目と5番目の構成要素を抽出している。
 don't careパターン(\pageref{patterns}ページ)が、この式本体で行われた処理と残りの構成要素が無関係であることを示するために用いられていることに注目しよう。
  {\it let-be-such-that式} は、1つの集合から1つの要素を選ぶ意味のない選択を減らすために、特に集合上での再帰定義の形式化において用いられる。
これについての例は、列のfilter関数 (\pageref{filterdef}ページ)を集合上で考えたものである:
\label{setfilterdef}
  \begin{alltt}
    set_filter[@elem] : (@elem -> \keyw{bool}) -> (\keyw{set of} @elem) -> 
                        (\keyw{set of} @elem)
    set_filter(p)(s) ==
      \keyw{if} s = \{\}
      \keyw{then} \{\}
      \keyw{else let} x \keyw{in set} s
          \keyw{in} (\keyw{if} p(x) \keyw{then} \{x\} \keyw{else} \{\}) \keyw{union}
             set_filter[@elem](p)(s \verb+\+ \{x\});
   \end{alltt}
別の方法として、この関数を集合内包 (第 \ref{setexpr}節参照)を用いて定義することもできるであろう:
  \begin{alltt}
    set_filter[@elem] : (@elem -> \keyw{bool}) -> (\keyw{set of} @elem) -> 
                        (\keyw{set of} @elem)
    set_filter(p)(s) ==
      \{ x | x \keyw{in set} s & p(x)\};
  \end{alltt} 

 最後の例はオプションである ``be such that'' 部分をどのように用いることができるかを示す。
いくつかのプロパティをもつある要素が存在することはわかっているがその要素に対する明示的な式がわからないまたは記述することが難しい場合に、この部分は特に役に立つ。たとえばこの式を選択ソートアルゴリズムを書くために活用することができる:
   \begin{alltt}\label{selectionSortdef}
   remove : \keyw{nat} * \keyw{seq of nat} -> \keyw{seq of nat}
   remove (x,l) ==
     \keyw{let} i \keyw{in set inds} l \keyw{be st} l(i) = x
     \keyw{in} l(1,...,i-1)\verb+^+l(i+1,...,\keyw{len} l)
   \Keyw{pre} x \keyw{in set elems} l;

   selection_sort : \keyw{seq of nat} -> \keyw{seq of nat}
   selection_sort (l) ==
     \keyw{if} l = []
     \keyw{then} []
     \keyw{else let} m \keyw{in set elems} l \keyw{be st}
         \keyw{forall} x \keyw{in set elems} l & m <= x
         \keyw{in} [m]\verb+^+(selection_sort (remove(m,l)))
   \end{alltt}
   ここでは、最初の関数は与えられたリストから与えられた要素を取り除く；
2番目の関数は並び替えされていないリスト部分から最も小さい要素を繰り返し取り除き、並び替えされた部分の頭に置く。
\end{description}

\subsection{def式} \label{define-exp}

この式は、第~\ref{op-def}節で述べられる操作の内部でのみ用いることができる。
式の部分でグローバル変数を取り扱うために、操作の内部で特別な式(すなわちdef式)が許されている。

\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep 
    \Ruleref{def式} \dsep
    \ldots
    }

\Rule{def式}{
  \Lop{def}, 
  \Ruleref{パターン束縛}, \Lit{=}, \Ruleref{式}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{パターン束縛}, \Lit{=}, \Ruleref{式}}, \OptPt{\Lit{;}},
  \lfeed
  \Lop{in}, \Ruleref{式}
  } 

\item[意味定義:] {\it def式} は次の形式をもつ:
  \begin{alltt}
    \Keyw{def} pb1 = e1;
        \ldots
        pbn = en
    \Keyw{in}
      e
  \end{alltt}
   {\it def式} は、右辺の式がローカル変数やグローバル変数の値に従属する可能性はあるが相互に再帰するものではない、といったことを除けば、let式に相等する。
これは、パターン(または束縛){\tt pb1, \ldots, pbn}が対応する式 {\tt e1, \ldots,    en}とマッチする文脈中で、式{\tt e}の値を示す\footnote{束縛が用いられている場合は、簡単に言えばパターンと一致した値はさらに第~\ref{patterns}章で述べられる型式または集合式によって制限を受けるということを意味する。}。

\item[例題:] 式の値はグローバル変数に従属するという事実に気づいてもらえるよう、{\it def式} が合理的な方法で用いられる。

 これは小さな例で説明することができる:
  \begin{alltt}
    \Keyw{def} user = lib(copy) \keyw{in}
      \keyw{if} user = <OUT>
      \Keyw{then} \keyw{true}
      \Keyw{else} \keyw{false}
  \end{alltt}      
   {\tt copy} が文脈中に定義されている場所で、{\tt lib} はグローバル変数である(このように {\tt lib(copy)} は変数の一部の内容検索と考えることができる)。

  第\ref{letstmt}節の操作 \texttt{GroupRunnerUp\_expl} でもまたdef式の例が与えられている。
\end{description}

\subsection{単項式または2項式}\label{unandbin}

\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep
    \Ruleref{単項式} \dsep \Ruleref{2項式} \dsep \ldots
    }

\Rule{単項式}{
  \Ruleref{接頭辞式} \dsep
  \Ruleref{逆写像}
  }

\Rule{接頭辞式}{
  \Ruleref{単項演算子}, \Ruleref{式}
  }

  \Rule{単項演算子}{
    \Lit{+} \dsepl \Lit{-} \dsepl \Lop{abs} \dsepl
    \Lop{floor} \dsepl \Lop{not} \dsep
    \Lop{card} \dsepl \Lop{power} \dsepl \Lop{dunion} \dsepl
    \Lop{dinter} \dsep
    \Lop{hd} \dsepl \Lop{tl} \dsepl \Lop{len} \dsepl \Lop{elems} \dsepl
    \Lop{inds} \dsepl \Lop{conc} \dsep
    \Lop{dom} \dsepl \Lop{rng} \dsepl \Lop{merge} 
    }

\Rule{逆写像}{
  \Lop{inverse}, \Ruleref{式}
  }

  \Rule{2項式}{
    \Ruleref{式}, \Ruleref{2項演算子}, \Ruleref{式}}

  \Rule{2項演算子}{
    \Lit{+} \dsepl \Lit{-} \dsepl \Lit{*} \dsepl \Lit{/} \dsep
    \Lop{rem} \dsepl \Lop{div} \dsepl \Lop{mod} \dsepl \Lit{**} \dsep
    \Lop{union} \dsepl \Lop{inter} \dsepl \Lit{\char'134} \dsepl
    \Lop{subset} \dsep
    \Lop{psubset} \dsepl \Lop{in set} \dsepl \Lop{not in set} \dsep
    \Lit{\char'136} \dsep
    \Lit{++} \dsepl \Lop{munion} \dsepl \Lit{<:} \dsepl \Lit{<-:} \dsepl \Lit{:>} \dsepl \Lit{:->} \dsep
    \Lop{and} \dsepl \Lop{or} \dsep
    \Lit{=>} \dsepl \Lit{<=>} \dsepl \Lit{=} \dsepl \Lit{<>} \dsep
    \Lit{<} \dsepl \Lit{<=} \dsepl \Lit{>} \dsepl \Lit{>=} \dsep
    \Lop{comp}
    }

\item[意味定義:] 
単項式と2項式は、特定の型の値を記述する演算子と演算対象の結合である。
これらすべての演算子のシグネチャについては、すでに第~\ref{typedef}節で述べてあるのでそれ以上の説明はここでは行わない。
逆写像単項演算子は、数学的構文における接尾辞記号で記述されるため、別に取り扱う。
\item[例題:] これらの演算子を用いた例題は第~\ref{typedef}節で与えられるため、ここでは触れない。
\end{description}

\subsection{条件式}
\label{if-exp} \label{cases-exp}
\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep
    \Ruleref{if式} \dsep \Ruleref{cases式} \dsep \ldots
    }

  \Rule{if式}{
    \Lop{if}, \Ruleref{式}, \Lop{then}, \Ruleref{式},\lfeed
    \SeqPt{\Ruleref{elseif式}}, \Lop{else}, \Ruleref{式}
    }

  \Rule{elseif式}{
    \Lop{elseif}, \Ruleref{式}, \Lop{then}, \Ruleref{式}
    }
                     
  \Rule{cases式}{
    \Lop{cases}, \Ruleref{式}, \Lit{:}, \lfeed
    \Ruleref{cases式選択肢群}, \lfeed
    \OptPt{\Lit{,}, \Ruleref{others式}}, \Lop{end}
    }

  \Rule{cases式選択肢群}{
    \Ruleref{cases式選択肢},\lfeed
    \SeqPt{\Lit{,}, \Ruleref{cases式選択肢}}
    }

  \Rule{cases式選択肢}{
    \Ruleref{パターンリスト}, \Lit{->}, \Ruleref{式}
    } 

  \Rule{others式}{
    \Lop{others}, \Lit{->}, \Ruleref{式}
    }

\item[意味定義:]  {\it if式} と {\it cases式}は、1つの特定の式の値を基に、複数の中から1つの式を選ぶことを可能にする。

  {\it if式} は次の形式をもつ:
  \begin{alltt}
    \keyw{if} e1
    \Keyw{then} e2
    \Keyw{else} e3
  \end{alltt}
ここで {\tt e1} はブール式であり、一方  {\tt e2} と {\tt e3} はどのような型であってもよい。
もし {\tt e1}が与えられた文脈中でtrueであるならば、 if式は与えられた文脈中で評価された{\tt e2}の値を表す。
そうでなければ、if式は与えられた文脈上で {\tt e3}の値を表す。
 \keyw{elseif}式の使用は、ある式の\keyw{else}部分においてネストされたif-then-else式を単に省略したものである。

  {\it cases式} は次の形式をもつ
  \begin{alltt}
    \keyw{cases} e :
      p11, p12, ..., p1n -> e1,
      ...                -> ...,
      pm1, pm2, ..., pmk -> em,
      \Keyw{others}             -> emplus1
    \keyw{end}
  \end{alltt}
 ここで {\tt e} は1つの任意の型の式であり、{\tt pij} で表すすべては1つ1つが式 {\tt e}にマッチするパターンである。 
{\tt  ei}で表すのは任意の型の式であり、キーワードの \keyw{others} とそれに対応する式{\tt emplus1}とはオプションとなる。 
cases式では、 {\tt pij} パターンの1つが {\tt e}にマッチした文脈中で評価された{\tt ei} 式の値を示す。 
選択された {\tt ei} は、パターンの1つを式 {\tt e}とマッチさせることができた最初の入口である。
もしパターンのうちのどれも{\tt e}にマッチしない場合には、 \keyw{others} 節がなくてはならないし、そこでcases式は与えられた文脈中で評価される{\tt emplus1}の値を示す。
     
\item[例題:] 
 \vdmslpp{\vdmsl}{\vdmpp}\ におけるif式は、大部分のプログラム言語において用いられているものに相等するが、その一方 \vdmslpp{\vdmsl}{\vdmpp}\ における cases式は、大部分のプログラム言語よりもより一般的なものとなる。
このことは実際にパターンマッチングがおきる事例から見て取れるであろうが、しかしまた大部分のプログラム言語におけるようなパターンが定数である必要がないためでもある。
  条件式の使用例はマージソートアルゴリズムの記述により提供される:
  \begin{alltt}
  lmerge : \keyw{seq of nat} * \keyw{seq of nat} -> \keyw{seq of nat}
  lmerge (s1,s2) ==
    \keyw{if} s1 = [] \keyw{then} s2
    \keyw{elseif} s2 = [] \keyw{then} s1
    \keyw{elseif} (\keyw{hd} s1) < (\keyw{hd} s2)
    \keyw{then} [\keyw{hd} s1]\verb+^+(lmerge (\keyw{tl} s1, s2))
    \keyw{else} [\keyw{hd} s2]\verb+^+(lmerge (s1, \keyw{tl} s2));

  mergesort : \keyw{seq of nat} -> \keyw{seq of nat}
  mergesort (l) ==
    \keyw{cases} l:
      [] -> [],
      [x] -> [x],
      l1\verb+^+l2 -> lmerge (mergesort(l1), mergesort(l2))
    \keyw{end}
  \end{alltt}
cases式によって提供されたパターンマッチングは、型の合併を扱うことに役立つ。
たとえば、\pageref{exprdef} ページからの型定義\texttt{Expr}を用いることで次を得る:
  \begin{alltt}\label{printExprDef}
  print_Expr : Expr -> \keyw{seq1 of char}
  print_Expr (e) ==
    \keyw{cases} e:
      \keyw{mk\_}Const(-) -> "Const of"\verb+^+(print_Const(e)),
      \keyw{mk\_}Var(id,-) -> "Var of"\verb+^+id,
      \keyw{mk\_}Infix(\keyw{mk\_}(e1,op,e2)) -> "Infix of"\verb+^+print_Expr(e1)^","
                                      \verb+^+print_Op(op)\verb+^+","
                                      \verb+^+print_Expr(e2),
      \keyw{mk\_}Cond(t,c,a) -> "Cond of"\verb+^+print_Expr(t)\verb+^+","
                                 \verb+^+print_Expr(c)\verb+^+","
                                 \verb+^+print_Expr(a)
    end;

  print_Const : Const -> \keyw{seq1 of char}
  print_Const(\keyw{mk\_}Const(c)) ==
    \keyw{if} \keyw{is\_nat}(c)
    \keyw{then} "nat"
    \keyw{else} -- must be bool
         "bool";
  \end{alltt}
  関数 \texttt{print\_Op}は同様に定義されるであろう。
\end{description}

\subsection{限量式}

\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep \Ruleref{限量式} 
    \dsep \ldots
    }

  \Rule{限量式}{
    \Ruleref{全称限量式} \dsep
    \Ruleref{存在限量式} \dsep
    \Ruleref{1存在限量式}
    } 

  \Rule{全称限量式}{
    \Lop{forall}, \Ruleref{束縛リスト}, \Lit{\char'046}, \Ruleref{式}
    }
    
  \Rule{存在限量式}{
      \Lop{exists}, \Ruleref{束縛リスト}, \Lit{\char'046}, \Ruleref{式}
    }

  \Rule{束縛リスト}{
    \Ruleref{多重束縛}, \SeqPt{\Lit{,}, \Ruleref{多重束縛}}
    }

  \Rule{1存在限量式}{
    \Lop{exists1}, \Ruleref{束縛}, \Lit{\char'046}, \Ruleref{式}
    }

\item[意味定義:] 限量式には3つの形式がある:
  {\it 全称} ( \keyw{forall}と記述される), {\it 存在} ( \keyw{exists}と記述される), そして {\it 1 存在} ( \keyw{exists1}と記述される)である。
以下に述べられるように、各々はブール値である \keyw{true} または \keyw{false}の値をとる。

   {\it 全称限量式} は次の形式をもつ:
  \begin{alltt}
    \keyw{forall} mbd1, mbd2, \ldots, mbdn \& e
  \end{alltt}
  ここで各々の {\tt mbdi} は多重束縛 {\tt pi \keyw{in set} s} (あるいは型束縛であるならば {\tt pi : 型})であり、 {\tt e} は {\tt mbdi}のパターン識別子を含むブール式である。 
この値は、{\tt e}を {\tt mbd1, mbd2, \ldots,
    mbdn}における束縛のすべてにおいて文脈上で評価して、\keyw{true}であるならば \keyw{true}となりそうでない場合は\keyw{false} となる。

   {\it 存在限量式} は次の形式をもつ:
  \begin{alltt}
    \keyw{exists} mbd1, mbd2, \ldots, mbdn \& e
  \end{alltt}
  ここで {\tt mbdi} および {\tt e} は、全称限量式におけるものと同じである。
ここで{\tt mbd1, mbd2, \ldots, mbdn}における束縛の少なくとも1つを選択した文脈上で評価した場合に{\tt e} が \keyw{true}であったならば、この値は \keyw{true} となりそうでない場合は \keyw{false} となる。

   {\it 1 存在限量式} は次の形式をもつ:
  \begin{alltt}
    \keyw{exists1} bd \& e
  \end{alltt}
  ここで{\tt bd}は 集合束縛か型束縛であり、 {\tt e} は {\tt bd}のパターン識別子を含むブール式である。
束縛のうちのちょうど1つを選択した文脈上で評価して{\tt e} が \keyw{true} であるならば、この値は\keyw{true}となりそうでない場合は \keyw{false} となる。

 すべての限量式は、可能な優先度の中で最も低い優先度を持つ。
これは、可能な限り長い構成式が使われることを意味する。
式は、構文的に可能な限りの右側へ続く。


\item[例題:] 
存在限量の例は以下の \texttt{QualificationOk}で提示される関数で与えられる。
この関数は、\cite{Fitzgerald&98}における化学プラント警報システムの仕様書からとってきたものであるが、ある専門家の集団が要求された資質を満たすか否かを照合するものである。
  \begin{alltt}
  types

  ExpertId = \keyw{token};
  Expert :: expertid : ExpertId
            quali : \keyw{set of} Qualification
  \keyw{inv} ex == ex.quali <> {};
  Qualification = <Elec> | <Mech> | <Bio> | <Chem>

  functions

  QualificationOK: \keyw{set of} Expert * Qualification -> \keyw{bool}
  QualificationOK(exs,reqquali) ==
      \keyw{exists} ex \keyw{in set} exs & reqquali \keyw{in set} ex.quali
  \end{alltt}
  この関数 \texttt{min} は全称限量の例を示す: 
  \begin{alltt}
  min(s:\keyw{set of nat}) x:\keyw{nat}
  \Keyw{pre} s <> \{\} 
  \Keyw{post} x \keyw{in set} s \keyw{and}
       \keyw{forall} y \keyw{in set} s \verb+\+ \{x\} & y < x
  \end{alltt}
1 存在限量は、すべての写像\texttt{m}が満足する関数プロパティを述べるために用いることができる:
  \begin{alltt}
  \keyw{forall} d \keyw{in set dom} m &
    \keyw{exists1} r \keyw{in set rng} m & m(d) = r
  \end{alltt}


\end{description}

\subsection{iota式}\label{iotaexpr}

\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep
    \Ruleref{iota式} \dsep
    \ldots
    }

  \Rule{iota式}{
    \Lop{iota}, \Ruleref{束縛}, \Lit{\char'046}, \Ruleref{式}
    }

\item[意味定義:] {\it iota式}は次の形式をもつ:
  \begin{alltt}
    \keyw{iota} bd \& e
  \end{alltt}
  ここで{\tt bd} は集合束縛かまたは型束縛であり、 {\tt e} は {\tt bd}のパターン識別子を含むブール式である。
束縛に一致して本体式 {\tt e} を \keyw{true} とする唯一の値が存在するならば、\keyw{iota} 演算子を唯一用いることができる(i.e.\ {\tt \keyw{exists1} bd \& e} は \keyw{true}でなくてはならない)。 
 iota式の意味定義は、本体式 ({\tt e})を満たす唯一の値を返すということである。

\item[例題:] 
 次に定義された値 \texttt{sc1,...,sc4} を用いる
  \begin{alltt}
    sc1 = \keyw{mk\_}Score (<France>, 3, 0, 0, 9);
    sc2 = \keyw{mk\_}Score (<Denmark>, 1, 1, 1, 4);
    sc3 = \keyw{mk\_}Score (<SouthAfrica>, 0, 2, 1, 2);
    sc4 = \keyw{mk\_}Score (<SaudiArabia>, 0, 1, 2, 1);
  \end{alltt}
これより
  
  \begin{tabular}{lcl}
    \texttt{ \keyw{iota} x \keyw{in set} \{sc1,sc2,sc3,sc4\} \& 
      x.team = <France>} & $\equiv$ & \texttt{sc1}\\
    \texttt{ \keyw{iota} x \keyw{in set} \{sc1,sc2,sc3,sc4\} \& 
      x.points > 3} & $\equiv$ & $\perp$\\
    \texttt{ \keyw{iota} x : Score \& x.points < x.won} & $\equiv$ &
  $\perp$
  \end{tabular}

  \noindent 最後の例は実行不可能であり、加えて最後の2式は未定義となることに注意しよう竏酎O者は式を満たす値が多くなるからであり、後者は式を満たす値がないからである。

\end{description}

\subsection{集合式}\label{setexpr}

\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep \Ruleref{集合列挙} \dsep \Ruleref{集合内包} \dsep
    \Ruleref{集合範囲式} \dsep \ldots
    }
  
  \Rule{集合列挙}{
    \Lit{\{}, \OptPt{\Ruleref{式リスト}}, \Lit{\}}
    }

  \Rule{式リスト}{
    \Ruleref{式}, \SeqPt{\Lit{,}, \Ruleref{式}}
    }

  \Rule{集合内包}{
    \Lit{\{}, \Ruleref{式}, \Lit{$|$}, \Ruleref{束縛リスト}, \lfeed
    \OptPt{\Lit{\char'046}, \Ruleref{式}}, \Lit{\}}
    }

  \Rule{集合範囲式}{
    \Lit{\{}, \Ruleref{式}, \Lit{,}, \Lit{\Range},
    \Lit{,}, \lfeed
    \Ruleref{式}, \Lit{\}}
    }

\item[意味定義:] {\it 集合列挙}は次の形式をもつ:
  \begin{alltt}
    \{e1, e2, e3, \ldots, en\}
  \end{alltt}
 ここで {\tt e1} から {\tt en} までは一般の式である。
列挙された式の値の集合を構成する。
空集合は \verb+{}+ と書かれなければならない。

    {\it 集合内包}式は次の形式をもつ:
  \begin{alltt}
    \{e | mbd1, mbd2, \ldots, mbdn \& P\}
  \end{alltt}
 述語 {\tt P}が \keyw{true}と評価される束縛すべてのもとで、式{\tt e} を評価することで1つの集合が構成される。
多重束縛には集合束縛と型束縛の両方を含めることができる。
したがって{\tt mbdn} は {\tt pat1 \keyw{in set} s1, pat2 : tp1,
    \ldots \keyw{in set} s2}というようになるであろうが、ここにおける {\tt pati} はパターンであり (通常は単なる識別子である)、 {\tt s1} や {\tt s2} は式で構成される集合である ( これに対して{\tt tp1}は、型束縛もまた用いることができることを示すために使われている)。 
ただし型束縛はインタープリタでは実行できないので注意したい。

   {\it 集合範囲式} は集合内包の特別な場合である。
これは次の形式をもつ
  \begin{alltt}
    \{e1, \ldots, e2\}
  \end{alltt}
 ここでの {\tt e1} と {\tt e2} は数式である。
この集合範囲式は {\tt e1} から {\tt e2} までに含まれる整数の集合を表記する。
 {\tt e2} が {\tt e1} よりも小さい場合には、集合範囲式は空集合を表す。

\item[例題:] 
 \texttt{Europe=\{<France>,<England>,<Denmark>,<Spain>\}} および \\
 \texttt{GroupC = \{sc1,sc2,sc3,sc4\}} (ここでの \texttt{sc1,...,sc4} は前述の例にて定義されたもの) の値を用いて次を得る

  \begin{tabular}{lcl}
    \texttt{\{<France>, <Spain>\} \keyw{subset} Europe} & $\equiv$ &
      \keyw{true}\\
    \parbox[t]{7cm}{\raggedright
      \texttt{\{<Brazil>, <Chile>, <England>\}}\\
      \mbox{\hspace{3em}}\texttt{\keyw{subset} Europe} }
      & $\equiv$ &  \keyw{false}\\
    \parbox[t]{7cm}{\raggedright
      \texttt{\{<France>, <Spain>, {\char'042}France{\char'042}\}} \\
      \mbox{\hspace{3em}}\keyw{subset} \texttt{Europe}} &
      $\equiv$ & \keyw{false}\\
    \parbox[t]{7cm}{\raggedright\texttt{\{sc.team | sc \keyw{in set} GroupC }\\
                    \mbox{\hspace{3em}}\texttt{\& sc.points > 2\}}} &
      $\equiv$ & \texttt{\{\parbox[t]{4cm}{<France>,\\ <Denmark>\}}}\\
    \parbox[t]{7cm}{\raggedright
        \texttt{\{sc.team | sc \keyw{in set} GroupC }\\
        \mbox{\hspace{3em}}\texttt{\& sc.lost > sc.won \}}}
      & $\equiv$ & \texttt{\{\parbox[t]{4cm}{<SouthAfrica>, \\<SaudiArabia>\}}}\\
    \texttt{\{2.718,...,3.141\}} & $\equiv$ & \texttt{\{3\}}\\
    \texttt{\{3.141,...,2.718\}} & $\equiv$ & \texttt{\{\}}\\
    \texttt{\{1,...,5\}} & $\equiv$ & \texttt{\{1,2,3,4,5\}}\\
    \texttt{\{ x | x:\keyw{nat} \& x < 10 \keyw{and} x \keyw{mod} 2 = 0\}}
      & $\equiv$ & \texttt{\{0,2,4,6,8\}}
  \end{tabular}
\end{description}

\subsection{列式} \label{seqexpr}

\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep
    \Ruleref{列列挙} \dsep \Ruleref{列内包} \dsep
    \Ruleref{部分列} \dsep \ldots
    }

  \Rule{列列挙}{
    \Lit{[}, \OptPt{\Ruleref{式リスト}}, \Lit{]}
    }

  \Rule{列内包}{
    \Lit{[}, \Ruleref{式}, \Lit{|}, \Ruleref{集合束縛}, \lfeed
    \OptPt{\Lit{\char'046}, \Ruleref{式}}, \Lit{]}
    }

  \Rule{部分列}{
    \Ruleref{式}, \lfeed
    \Lit{(}, \Ruleref{式},
    \Lit{,}, \Lit{\Range},
    \Lit{,}, \lfeed
    \Ruleref{式}, \Lit{)}
    }

\item[意味定義:]  {\it 列列挙}は次の形式をもつ:
  \begin{alltt}
    [e1, e2, \ldots, en]
  \end{alltt}
  ここでの{\tt e1}から {\tt en} は一般の式である。 
これは列挙された要素の列を構成する。
空列は {\tt []}と書かれなければならない。

   {\it 列内包} は次の形式をもつ:
  \begin{alltt}
    [e | pat \keyw{in set} S \& P]
  \end{alltt}
 ここでの式 {\tt e} は、パターン {\tt pat} からもってきた識別子を用いることになる(通常このパターンは単なる識別子となるが、唯一実際上の必要条件としては、ちょうど1つのパターン識別子のみがパターン中に存在するということである)。 
{\tt S} は値 (通常は自然数)の集合である。
このパターン識別子の束縛は何らかの種類の数値に対するものでなければならず、これにより結果列における要素の順を指示するために用いられる。
述語 {\tt P}が \keyw{true}と評価されるすべての束縛上で式{\tt e}を評価することにより、列を構成する。

列 {\tt l} の{\it 部分列} というのは {\tt l}の連続する要素からなる列;索引 {\tt n1}以上 {\tt n2}以下のもの、である。 
次の形式をもつ:
  \begin{alltt}
    l(n1, ..., n2)
  \end{alltt}
 ここでの {\tt n1} と {\tt n2} は正の整数式である。
 下限の {\tt n1}(空でない列での最初の索引) が1 より小さい場合は、列式は列の最初の要素から始まることとなる。
上限の{\tt n2}(空でない列で索引中最大のもの) が列の長さよりも大きい場合は、列式は列の最後の要素で終わることとなる。

%  A {\it sequence modifier} has the form:
%  \begin{alltt}
%    l ++ \{n1 |-> e1, n2 |-> e2, \ldots, nm |-> em\}
%  \end{alltt}
%  where {\tt l} is an expression denoting a sequence (which is going to be
%  modified), {\tt n1, n2, \ldots, nm} are positive integer expressions
%  (less than the length of {\tt l}) and {\tt e1, e2, \ldots, em} are
%  expressions of any type. The sequence modifier expression denotes the
%  sequence {\tt l} modified in a way so that element {\tt ni} has been
%  replaced by {\tt ei}.

\item[例題:] \texttt{GroupA} が次の列に等しい場合
  \begin{alltt}\label{GroupAdef}
    [ \keyw{mk\_}Score(<Brazil>,2,0,1,6), 
      \keyw{mk\_}Score(<Norway>,1,2,0,5),
      \keyw{mk\_}Score(<Morocco>,1,1,1,4),
      \keyw{mk\_}Score(<Scotland>,0,1,2,1) ]
  \end{alltt} 以下が導かれる:

  \begin{tabular}{lcl}
  \parbox[t]{5.4cm}{\ttfamily\selectfont
            [GroupA(i).team \\
            | i \keyw{in set inds} GroupA \\
                  \mbox{\hspace{1em}} \& GroupA(i).won <> 0]}
    &$\equiv$ & 
        \texttt{[}\parbox[t]{4cm}{\ttfamily\selectfont
                                 <Brazil>, \\
                                 <Norway>, \\
                                 <Morocco>]}\\
  \parbox[t]{5.4cm}{\ttfamily\selectfont
            [GroupA(i) \\
            | i \keyw{in set inds} GroupA\\
            \mbox{\hspace{1em}} \& GroupA(i).won = 0]}
    &$\equiv$ & \texttt{[\keyw{mk\_}Score(<Scotland>,0,1,2,1)]}\\
  \texttt{GroupA(1,...,2)} 
    &$\equiv$ & 
    \texttt{[}\parbox[t]{4cm}{\ttfamily\selectfont
         \keyw{mk\_}Score(<Brazil>,2,0,1,6), \\
         \keyw{mk\_}Score(<Norway>,1,2,0,5)]}\\
  \parbox[t]{5.65cm}{\ttfamily\selectfont
            [GroupA(i) \\
            | i \keyw{in set inds} GroupA \\
            \mbox{\hspace{1em}} \& GroupA(i).points = 9]}
    &$\equiv$ & \texttt{[]}
  \end{tabular}
\end{description}

\subsection{写像式} \label{mapexpr}

\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep
    \Ruleref{写像列挙} \dsep \Ruleref{写像内包} \dsep \ldots
    }

  \Rule{写像列挙}{
    \Lit{\{}, \Ruleref{写}, \SeqPt{\Lit{,}, \Ruleref{写}}, \Lit{\}} \dsep
    \Lit{\{}, \Lit{|->}, \Lit{\}}
    } 
  
  \Rule{写}{
    \Ruleref{式}, \Lit{|->}, \Ruleref{式}
    }
  
  \Rule{写像内包}{
    \Lit{\{}, \Ruleref{写}, \Lit{|}, \Ruleref{束縛リスト},\lfeed
    \OptPt{\Lit{\char'046}, \Ruleref{式}}, \Lit{\}}
    }

\item[意味定義:] {\it 写像列挙} は次の形式をもつ:
  \begin{alltt}
    \{d1 |-> r1, d2 |-> r2, \ldots, dn |-> rn\}
  \end{alltt}
  ここですべての定義域式 {\tt di} と値域式{\tt ri}は一般の式である。
 空写像は {\tt \{|->\}}と書かれなければならない。
      
  {\it 写像内包} は次の形式をもつ:
  \begin{alltt}
    \{ed |-> er | mbd1, \ldots, mbdn \& P\}
  \end{alltt}
 ここでの構成 {\tt mbd1, \ldots, mbdn} は、式 {\tt ed} および {\tt er} から集合 (または型)をきめる変数の多重束縛である。
 {\it 写像内包} は、述語 {\tt P}を\keyw{true}と評価するすべての可能なかぎりの束縛上で、式{\tt ed} および {\tt er}を評価することにより写像を構成する。

\item[例題:] \texttt{GroupG}は次の写像と等しいと仮定する
  \begin{alltt}\label{GroupGdef}
    \{ <Romania> |-> mk_(2,1,0), <England> |-> mk_(2,0,1),
      <Colombia> |-> mk_(1,0,2), <Tunisia> |-> mk_(0,1,2) \}
  \end{alltt}
  この場合に次が成り立つ:

  \begin{tabular}{lcl}
  \parbox[t]{8cm}{\ttfamily\selectfont
    \{ t |-> \keyw{let} \keyw{mk\_}(w,d,-) = GroupG(t)\\
             \mbox{\hspace{4em}}\keyw{in} w * 3 + d \\
             | t \keyw{in set dom} GroupG\}}
    & $\equiv$ & \texttt{\{}\parbox[t]{5cm}{\ttfamily\selectfont
                   <Romania> |-> 7,\\
                   <England> |-> 6,\\
                   <Colombia> |-> 3,\\
                   <Tunisia> |-> 1\}}\\
  \parbox[t]{8cm}{\ttfamily\selectfont
    \{ t |-> w * 3 + d \\
    | t \keyw{in set dom} GroupG, w,d,l:\keyw{nat} \\
    \ \& \keyw{mk\_}(w,d,l) = GroupG(t) \\
    \mbox{\hspace{.7em}}\keyw{and} w > l\}}
   & $\equiv$ & \texttt{\{}\parbox[t]{5cm}{\ttfamily\selectfont
                   <Romania> |-> 7,\\
                   <England> |-> 6\}}
  \end{tabular}
\end{description}

\subsection{組構成子式} \label{tupexpr}

\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep \Ruleref{組構成子} \dsep \ldots
    }

  \Rule{組構成子}{
    \Lop{mk\_}, \Lit{(}, \Ruleref{式}, \Lit{,}, \Ruleref{式リスト}, \Lit{)}
    }

\item[意味定義:]  {\it 組構成子式} は次の形式をとる:
  \begin{alltt}
    \keyw{mk\_}(e1, e2, \ldots, en)
  \end{alltt}
 ここで {\tt ei} は一般の式である。
 相等および不等演算子のみが使用できる。
     
\item[例題:] 前述の例で定義された写像 \texttt{GroupG} を用いて、次が得られる:

  \begin{tabular}{lcl}
  \texttt{\keyw{mk\_}(2,1,0) \keyw{in set rng} GroupG} & $\equiv$ \keyw{true}\\
  \texttt{\keyw{mk\_}({\char'042}Romania{\char'042},2,1,0) \keyw{not in set rng} GroupG} 
       & $\equiv$ \keyw{true}\\
  \texttt{\keyw{mk\_}(<Romania>,2,1,0) <> \keyw{mk\_}({\char'042}Romania{\char'042},2,1,0)}
       & $\equiv$ \keyw{true}
  \end{tabular}
\end{description}

\subsection{レコード式} \label{recexpr}

\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep 
    \Ruleref{レコード構成子} \dsep
    \Ruleref{レコード修正子} \dsep \ldots
    }

  \Rule{レコード構成子}{
    \Lop{mk\_}, \Ruleref{名称}, \Lit{(}, 
    \OptPt{\Ruleref{式リスト}}, \Lit{)}
    }

  \Rule{レコード修正子}{
    \Lop{mu}, \Lit{(}, \Ruleref{式}, \Lit{,}, 
    \Ruleref{レコード修正}, \lfeed \SeqPt{\Lit{,}, \Ruleref{レコード修正}}
    \Lit{)}
    }

  \Rule{レコード修正}{
    \Ruleref{識別子}, \Lit{|->}, \Ruleref{式}
    }

\item[意味定義:] {\it レコード構成子}は次の形式をもつ:
  \begin{alltt}
    \keyw{mk\_}T(e1, e2, \ldots, en)
  \end{alltt}
 ここでの式 {\tt (e1, e2, \ldots, en)} の型は、レコード型{\tt T}にある対応する入り口の型に一致する。

  {\it レコード修正} は次の形式をとる:
  \begin{alltt}
    \keyw{mu} (e, id1 |-> e1, id2 |-> e2, \ldots, idn |-> en)
  \end{alltt}
 ここで式 {\tt e} の評価として、修正されるべきレコード値を返す。
識別子 {\tt idi}は、{\tt e}のレコード型の中ですべて異なる名称をもつ入り口でなければならない。
     
\item[例題:] \texttt{sc} が値 \texttt{\keyw{mk\_}Score(<France>,3,0,0,9)} であるならば
  \begin{alltt}
    \keyw{mu}(sc, drawn |-> sc.drawn + 1, points |-> sc.points + 1)
    \MYEQUIV \keyw{mk\_}Score(<France>,3,1,0,10)
  \end{alltt}
さらなる例題として関数 \texttt{win}の説明を行う。
この関数は2つのチームと1つのスコアをもつ。
スコアの集合から与えられているチームに相当するスコア(勝ったチームには\texttt{wsc}、負けたチームには\texttt{lsc})を各々割り当て、\keyw{mu}演算子を用いてこれらを更新する。
チームの集合はここで、新しいスコアをもとのものと置き換えることで更新される。
  \begin{alltt}
  win : Team * Team * \keyw{set of} Score -> \keyw{set of} Score
  win (wt,lt,gp) ==
    \keyw{let} wsc = \keyw{iota} sc \keyw{in set} gp & sc.team = wt,
       lsc = \keyw{iota} sc \keyw{in set} gp & sc.team = lt
    \keyw{in let} new_wsc = \keyw{mu}(wsc, won |-> wsc.won + 1,
                            points |-> wsc.points + 3),
         new_lsc = \keyw{mu}(lsc, lost |-> lsc.lost + 1)
      \keyw{in} (gp \verb+\+ \{wsc,lsc\}) \keyw{union} \{new_wsc, new_lsc\}
  \Keyw{pre} \keyw{forall} sc1, sc2 \keyw{in set} gp &
          sc1 <> sc2 <=> sc1.team <> sc2.team
          \keyw{and} \{wt,lt\} \keyw{subset} \{sc.team | sc \keyw{in set} gp\}
  \end{alltt}

\end{description}

\subsection{適用式}\label{app-expr}

\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep 
    \Ruleref{適用} \dsep
    \Ruleref{項目選択} \dsep
    \Ruleref{組選択} \dsep
    \Ruleref{関数型インスタンス化} \dsep
    \ldots
    }

  \Rule{適用}{
    \Ruleref{式}, \Lit{(}, \OptPt{\Ruleref{式リスト}}, \Lit{)}
    }

  \Rule{項目選択}{
    \Ruleref{式}, \Lit{.}, \Ruleref{識別子}
    }

  \Rule{組選択}{
    \Ruleref{式}, \Lit{.\#}, \Ruleref{数字}
    }

  \Rule{関数型インスタンス化}{
    \Ruleref{名称}, \Lit{[}, \Ruleref{型}, \SeqPt{\Lit{,}, \Ruleref{型}}, \Lit{]}
    }

\item[意味定義:] 
  {\it 項目選択式} はレコードに対して用いることができるが、第~\ref{records} 節ですでに説明したのでここではそれ以上の説明は行わない。
 {\it 適用} は、ある写像において検索を行い、列に索引をし、最後に関数を呼び出すために用いられる。
第~\ref{maps} 節で、写像において検索を行うとはどういうことかはすでに述べてある。同様に第~\ref{sequences} 節では、列に索引をするとはどのように行うのかが説明されている。

 \vdmslpp{VDM-SL}{\vdmpp}においては、ここで更に1つの操作を呼び出すことが可能である。
これは標準VDM-SLにおいては許されていないことであり、この種の操作呼び出しは状態を変更してしまう可能性があるので、混合式においては慎重に使用されるべきである。
このような操作呼び出しで例外を起こすことが許されてはいないことに注意したい。

 このような操作呼出しでは評価の順が重要となる可能性がある。
したがって型検査では、式の中でユーザーが操作呼出しを有効化や無効化することを許す。

 組選択式は、組から特別な構成要素を抽出するために用いられる。
式の意味は、 もし \texttt{e} がいくつかの組 \keyw{mk\_}\texttt{(v1,...,vN)}であると評価され、 \texttt{M} が範囲 \verb+{1,...,N}+ 内の1つの整数であるならば、 \texttt{e.\#M}は \texttt{vM}となるということである。
\texttt{M} が \verb+{1,...,N}+ からはずれているならば、この式は未定義である。

 {\it 関数型インスタンス化\/} は、適当な型をもつ多相関数のインスタンス生成に用いられる。
これは次の形式をもつ:
  \begin{alltt}
    pf [ t1, ..., tn ]
  \end{alltt}
 ここで {\tt pf} は多相関数の名称であり、 {\tt t1,  \ldots, tn} は型である。
結果の関数は、関数定義で与えられた変数型の名称の代わりに、型 {\tt  t1, \ldots, tn} を用いる。

\item[例題:] 
\texttt{GroupA} は1つの列 ( \pageref{GroupAdef}ページ)、 \texttt{GroupG} は1つの写像 (\pageref{GroupGdef}ページ)、そして \texttt{selection\_sort} は1つの関数( \pageref{selectionSortdef}ページ)であったことを思い起こそう:

  \begin{tabular}{lcl}
  \texttt{GroupA(1)} & $\equiv$ & 
                           \texttt{\keyw{mk\_}Score(<Brazil>,2,0,1,6)}\\
  \texttt{GroupG(<Romania>)} & $\equiv$ &
                           \texttt{\keyw{mk\_}(2,1,0)}\\
  \texttt{GroupG(<Romania>).\#2} & $\equiv$ &
                           \texttt{1}\\
  \texttt{selection\_sort([3,2,9,1,3])} & $\equiv$ &
                           \texttt{[1,2,3,3,9]}
  \end{tabular}

 多相関数使用と関数型インスタンス化の1つの例として、第~\ref{functiondef}節から例題の関数を用いる:
  \begin{alltt}
    \keyw{let} emptyInt = empty_bag[int] \keyw{in}
      plus_bag[int](-1, emptyInt())

  \MYEQUIV

    \{ -1 |-> 1 \}
  \end{alltt}

\end{description}


\subsection{ラムダ式}\label{lambda}

\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep \Ruleref{ラムダ式} \dsep \ldots
    }

  \Rule{ラムダ式}{
    \Lop{lambda}, \Ruleref{型束縛リスト}, \Lit{\&}, \Ruleref{式}
    }

\Rule{型束縛リスト}{
  \Ruleref{型束縛}, \SeqPt{\Lit{,}, \Ruleref{型束縛}}
  }

  \Rule{型束縛}{
    \Ruleref{パターン}, \Lit{:}, \Ruleref{型}
    }
        
\item[意味定義:] {\it ラムダ式} は次の形式をもつ:
  \begin{alltt}
    \keyw{lambda} pat1 : T1, \ldots, patn : Tn \& e
  \end{alltt}
 ここで {\tt pati} はパターン、{\tt Ti} は型式、そして{\tt e} は本体式である。 
パターン{\tt pati} におけるパターン識別子のスコープが本体式である。
ラムダ式は多相ではありえないが、それとは別に、意味定義においては第~\ref{functiondef}節に説明される陽関数定義に相当する。
ラムダ式によって定義される関数は、入れ子になった本体中で新しいラムダ式を用いることでカリー化することが可能となる。
ラムダ式が1つの識別子と結びついたとき、再帰関数を定義することもまた可能である。
\item[例題:] 以下のようにラムダ式を用いて、増加関数を定義することができる:
  \begin{alltt}
    Inc = \keyw{lambda} n : \keyw{nat} \& n + 1
  \end{alltt}
さらに加算関数はカリー化できる:
  \begin{alltt}
    Add = \keyw{lambda} a : \keyw{nat} \& \keyw{lambda} b : \keyw{nat} \& a + b
  \end{alltt}
もしこれが唯一の引数に適用された場合には、新しいラムダ式が返される:
  \begin{alltt}
    Add(5) \(\equiv\) \keyw{lambda} b : \keyw{nat} \& 5 + b
  \end{alltt}
 ラムダ式は、高階関数との関連で用いられる場合に役立つ。
 たとえば \pageref{setfilterdef}ページに定義される関数 \texttt{set\_filter}を用いてみると:
  \begin{alltt}
  set_filter[nat](lambda n:nat & n mod 2 = 0)(\{1,...,10\})
  \MYEQUIV \{2,4,6,8,10\}
  \end{alltt}
\end{description}


\subsection{narrow式}
\label{narrow}

\begin{description}
\item[構文:] 
  \Rule{式}{
    \ldots \dsep
    \Ruleref{ 式} 
    }
  \Rule{ narrow式}{
    \Lit{\keyw{narrow}\_}, \Lit{(}, \Ruleref{式}, \Lit{,}, \Ruleref{型}, \Lit{)}
  }

\item[意味定義:] {\it narrow式}の値は、与えた式の結果の型を、指定された型に変換したものである。

静的型チェックおよび動的型チェックにより、無関係の型間の変換は型エラーとなる。

\item[例題:]
この例では、Test() および Test'() の実行結果には差がないが、
Test() は「def」型チェックエラーとなる。

\begin{alltt}
types
C1 :: a : nat;
C2 :: b : nat;
S = C1 | C2;

operations
Test: () ==> nat
Test() ==
 let s : S = mk_C1(1)
 in
   let c : C1 = s
   in
     return c.a;

Test': () ==> nat
Test'() ==
 let s : S = mk_C1(1)
 in
   let c : C1 = narrow_(s, C1)
   in
     return c.a;
\end{alltt}
\end{description}


\subsection{is式}

\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep
    \Ruleref{一般is式} \dsep
    \ldots
    }

  \Rule{一般is式}{
    \Ruleref{is式} \dsep
    \Ruleref{型判定}
    }


  \Rule{is式}{
    \Lop{is\_}, \Ruleref{名称}, \Lit{(}, \Ruleref{式}, \Lit{)} \dsep
    \Ruleref{is基本型}, \Lit{(}, \Ruleref{式}, \Lit{)}
    }

  \Rule{is基本型}{
    \Lop{is\_}, 
    \Brack{%
      \Lop{bool} \dsepl
      \Lop{nat} \dsepl 
      \Lop{nat1} \dsepl 
      \Lop{int} \dsep 
      \Lop{rat} \dsepl 
      \Lop{real} \dsep
      \Lop{char} \dsepl
      \Lop{token}
      }
    }

  \Rule{型判定}{
    \Lit{\keyw{is}\_}, \Lit{(}, \Ruleref{式}, \Lit{,}, \Ruleref{型}, \Lit{)}
  }

\item[意味定義:] 
 {\it is式} は基本値かまたはレコード値(なにかのレコード型に属するタグ付けされた値)とともに用いられる。 
このis式は、与えられた値が指定された基本型に属する場合、または値が指定されたタグを持つ場合に、trueとなる。他の場合はfalseとなる。

 型判定は、型が静的には決定されえない式に対して用いることができることから、より一般的な形式である。
式 \texttt{\keyw{is}\_(e,t)} は、 \texttt{e} が\texttt{t}型 でありその場合にのみ、trueとなる。
     
\item[例題:]  \pageref{scoredef}ページに定義されたレコード型 \texttt{Score} を用いて次を得る:     
     
  \begin{tabular}{lcl}
    \texttt{\keyw{is\_}Score(\keyw{mk\_}Score(<France>,3,0,0,9))}
      & $\equiv$ & \keyw{true}\\
    \texttt{\keyw{is\_bool}(\keyw{mk\_}Score(<France>,3,0,0,9))}
      & $\equiv$ & \keyw{false}\\
    \texttt{\keyw{is\_real}(0)} & $\equiv$ & \keyw{true}\\
    \texttt{\keyw{is\_nat1}(0)} & $\equiv$ & \keyw{false}
  \end{tabular}

 型判定の例は以下のとおり:
  \begin{alltt}
    Domain : \keyw{map nat to nat} | \keyw{seq of (nat*nat)} -> \keyw{set of nat}
    Domain(m) ==
      \keyw{if is}\_(m, \keyw{map nat to nat})
      \keyw{then dom} m
      \keyw{else} \{d | \keyw{mk}\_(d,-) \keyw{in set elems} m\}
  \end{alltt}
   加えて \pageref{exprIsExs}にも例題が載せられている。
\end{description}



\subsection{リテラルと名称}

\begin{description}
\item[構文:]
  \Rule{式}{    \ldots \dsep
    \Ruleref{名称} \dsep
    \Ruleref{旧名称} \dsep
    \Ruleref{記号リテラル} \dsep
    \ldots
    }

  \Rule{名称}{
    \Ruleref{識別子}, \OptPt{\Lit{`}, \Ruleref{識別子}}
    }

  \Rule{名称リスト}{
    \Ruleref{名称}, \SeqPt{\Lit{,}, \Ruleref{名称}}
    }

  \Rule{旧名称}{
    \Ruleref{識別子}, \Lit{\char'176}
    }

\item[意味定義:] {\it 名称\/} と {\it 旧名称\/} は、関数、操作、値、状態構成要素の定義にアクセスするためによく用いられる。
 {\it 名称\/} は次の形式をもつ:
  \begin{alltt}
    id1`id2
  \end{alltt}
ここで {\tt id1} と {\tt id2} は単なる識別子である。
名称が唯一の識別子で構成される場合は、その識別子はスコープ内で定義されている。つまり、ローカルにパターン識別子かパターン変数として定義されているか、
あるいはグローバルに現モジュール内で関数、操作、値、またはグローバル変数として定義されているか、いずれかである。
そうでない場合は、識別子 {\tt id1}が
コンストラクタが定義されている場所の
モジュール名
を示している (
  第~\ref{modules}節
および付録 \ref{ap:lexis}も参照)。
 {\it 旧名称\/} は、操作定義の事後条件(第~\ref{op-def}節参照)および仕様文の事後条件(第~\ref{se:specification}節参照)において、グローバル変数の旧値にアクセスするためによく用いられる。
これは次の形式をもつ:

  \begin{alltt} 
    id~ 
  \end{alltt} 
 ここで {\tt id} は状態構成要素である。

  {\it 記号リテラル\/} はいくつかの基本型における定数値である。

\item[例題:] {\it 名称} と {\it 記号リテラル\/} はこの本の中ですべての例題を通して用いられている (付録~\ref{Symbols}参照)。


  旧名称の使用の例は、以下のように定義された状態を考える:
  \begin{alltt}
    \keyw{state} sigma \keyw{of}
      numbers : \keyw{seq of nat}
      index   : \keyw{nat}
    \Keyw{inv}  \keyw{mk\_}sigma(numbers, index) == index \keyw{not in set elems} numbers
    \Keyw{init} s == s = \keyw{mk\_}sigma([], 1)
    \keyw{end}
  \end{alltt}

 変数 {\tt index}を増加させる陰操作を定義することができる:
  \begin{alltt}
    IncIndex()
    \keyw{ext wr} index : \keyw{nat}
    \keyw{post} index = index~ + 1
  \end{alltt}
 操作 {\tt IncIndex} は、\keyw{ext wr} 節に示されるように、変数 {\tt index}を操作する。
事後条件の中で、 {\tt index} の新しい値は {\tt index}の旧値に  \texttt{1}を足したものと等しい。
(これ以上は第~\ref{op-def}節の操作についてを参照)。

module 
名の簡単な例としては、以下のように、 \texttt{build\_rel} という関数が \texttt{CGRel} という
module 
において定義された(そしてエクスポートされた)と仮定する:
\begin{alltt}
  \keyw{types}

    Cg = <A> | <B> | <C> | <D> | <E> | <F> | 
         <G> | <H> | <J> | <K> | <L> | <S>;
    CompatRel = \keyw{map} Cg \keyw{to set of} Cg

  \keyw{functions}

    build_rel : \keyw{set of} (Cg * Cg) -> CompatRel
    build_rel (s) == \{|->\}
\end{alltt}
別の
module 
においては、
最初にモジュール\texttt{CGRel}lを輸入し、 
それから、以下の呼出しを行なうことでこの関数をアクセスすることができる
  \begin{alltt}
  CGRel`build_rel({mk_(<A>, <B>)})
  \end{alltt}


\end{description}

\subsection{未定義式}

\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep 
    \Ruleref{未定義式}
    }

  \Rule{未定義式}{
    \Lop{undefined}
    }
  
\item[意味定義:] {\it 未定義式} は、ある式の結果が定義されないことを明白に述べるために用いられる。
 たとえばこれは、if-then-else式でelse分岐を評価した結果をどうすべきかが決定されていない場合などに、用いることができるであろう。
{\it 未定義式} が評価される場合、インタプリタは実行を終了し未定義式が評価されたと記録する。

実用において、未定義式の使用は事前条件のとは異なる:
事前条件の使用とは、関数が呼ばれたときに事前条件が満たされることを保障するのは呼び出す側の責任であることを意味する;
未定義式の使用であれば、エラー処理を行うのは呼び出された関数の責任となる。

\item[例題:] \texttt{Score} 値のbuildの前に、型の不変条件が保たれるかをチェックすることができる:

  \begin{alltt}
  build_score : Team * \keyw{nat} * \keyw{nat} * \keyw{nat} * \keyw{nat} -> Score
  build_score (t,w,d,l,p) ==
    \keyw{if} 3 * w + d = p
    \keyw{then} \keyw{mk\_}Score(t,w,d,l,p)
    \keyw{else undefined}
  \end{alltt}
\end{description}

\subsection{事前条件式}
\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep 
    \Ruleref{事前条件式}
    }
  \Rule{事前条件式}{
    \Lop{pre\_}, \Lit{(}, \Ruleref{式}, \lfeed
                          \OptPt{\SeqPt{\Lit{,}, \Ruleref{式}}},
                 \Lit{)}
    }
  
\item[意味定義:] 
 \texttt{e} が関数型であると仮定すると、 式 \keyw{pre\_}\texttt{(e,e1,...,en)} は、\texttt{e}の事前条件が引数 \texttt{e1,...,em}に対してtrueでありかつその場合にのみtrueとなるが、ここで\texttt{m}は\texttt{e}の事前条件のarity(引数の数)である。
 \texttt{e} が関数でなかったり、 \texttt{m} $>$ \texttt{n} であったりした場合は、結果は \texttt{true}となる。
 \texttt{e} が事前条件をもたない場合は、式はtrueと等しい。
\item[例題:] 
  以下のように定義された関数 \texttt{f} と \texttt{g} を考えよう
  \begin{alltt}
  f : \keyw{nat} * \keyw{nat} -> \keyw{nat}
  f(m,n) == m \keyw{div} n
  \keyw{pre} n <> 0;

  g (n: \keyw{nat}) sqrt:\keyw{nat}
  \keyw{pre} n >= 0
  \keyw{post} sqrt * sqrt <= n \keyw{and}
       (sqrt+1) * (sqrt+1) > n
  \end{alltt}
この場合、次の式は
  \begin{alltt}
  \keyw{pre}\_(\keyw{let} h \keyw{in set} \{f,g, \keyw{lambda mk}\_(x,y):\keyw{nat} * \keyw{nat} & x \keyw{div} y\} 
       \keyw{in} h, 1,0,-1)
  \end{alltt}  
以下と等しくなる
  \begin{itemize}
  \item \texttt{h}が \texttt{f} に束縛されている場合は \texttt{\keyw{pre}\_f(1,0)}と等しいと考えられるため、falseとなる;
  \item \texttt{h}が \texttt{g}に束縛されている場合は \texttt{\keyw{pre}\_g(1)}と等しいと考えられるため、trueとなる;
  \item  \texttt{h} が \texttt{\keyw{lambda} \keyw{mk}\_(x,y):\keyw{nat} * \keyw{nat} \& x \keyw{div} y} に束縛されている場合はこの関数に対して定義された事前条件がないため、 trueとなる。
  \end{itemize}
 \texttt{h} がいかに束縛されていたとしても、最後の引数  (\texttt{-1}) は決して使われないことに注意しよう。
\end{description}


\section{パターン}\label{patterns}

\begin{description}
\item[構文:]
  \Rule{パターン束縛}{
    \Ruleref{パターン} \dsepl
    \Ruleref{束縛}
    }

  \Rule{パターン}{
    \Ruleref{パターン識別子} \dsep
    \Ruleref{一致値} \dsep
    \Ruleref{集合列挙パターン} \dsep
    \Ruleref{集合合併パターン} \dsep
    \Ruleref{列列挙パターン} \dsep
    \Ruleref{列連結パターン} \dsep
    \Ruleref{写像列挙パターン} \dsep
    \Ruleref{写像併合パターン} \dsep
    \Ruleref{組パターン} \dsep
    \Ruleref{レコードパターン}
    }

  \Rule{パターン識別子}{
    \Ruleref{識別子} \dsepl \Lit{-}
    }

  \Rule{一致値}{
    \Ruleref{記号リテラル} \dsep \Lit{(}, \Ruleref{式}, \Lit{)}
    }

  \Rule{集合列挙パターン}{
    \Lit{\{}, [\Ruleref{パターンリスト}], \Lit{\}}
    }

  \Rule{集合合併パターン}{
    \Ruleref{パターン}, \Lit{\keyw{union}}, \Ruleref{パターン}
    }

  \Rule{列列挙パターン}{
    \Lit{[}, [\Ruleref{パターンリスト}], \Lit{]}
    }

  \Rule{列連結パターン}{
    \Ruleref{パターン}, \Lit{\char'136}, \Ruleref{パターン}
    }

  \Rule{写像列挙パターン}{
    \Lit{\{}, [\Ruleref{写パターンリスト}], \Lit{\}}
    }
    
  \Rule{写パターンリスト}{
    \Ruleref{写パターン}, \SeqPt{\Lit{,}, \Ruleref{写パターン}}
    }
    
  \Rule{写パターン}{
    \Ruleref{パターン}, \Lit{|->}, \Ruleref{パターン}
  }

   \Rule{写像併合パターン}{
    \Ruleref{パターン}, \Lit{\keyw{munion}}, \Ruleref{パターン}
    }

  \Rule{組パターン}{
    \Lop{mk\_(}, \Ruleref{パターン}, \Lit{,}, \Ruleref{パターンリスト}, \Lit{)}
    }
 
  \Rule{レコードパターン}{
    \Lop{mk\_}, \Ruleref{名称}, \Lit{(}, [\Ruleref{パターンリスト}], \Lit{)}
    }
   
  \Rule{パターンリスト}{
    \Ruleref{パターン}, \SeqPt{\Lit{,}, \Ruleref{パターン}}
    }

\item[意味定義:] パターンは常に文脈中で用いられ、1つの特定の型の1つの値に一致する。
マッチングでは、あるパターンがある値と一致する可能性があるかの照合を行い、そしてパターン中のパターン識別子に対応する値を結びつけ、識別子がそのスコープ内で、これらの値を意味するようにする。
パターンを用いることのできるいくつかの場合においては、束縛も同様に用いることができる (次節を参照)。
もし束縛が用いられていたら、それは単純に言って、与えられたパターンに一致する可能性のある値を束縛することに更なる情報(型式または集合式)が用いられていることを意味する。

 マッチングは次のように定義される
  \begin{enumerate}
  \item  {\it パターン識別子} はどんな型にも合致するしどんな値にも一致し得る。
それが識別子であるならば、その識別子はその値に束縛される;
それがdon't-care記号 \Lit{-}であるならば、どのような束縛も起こらない。

  \item {\it 一致値} はそれ自身の値に対してのみ一致し得る; どのような束縛もなされない。
一致値がたとえば {\tt 7} とか {\tt <RED>}とかのようにリテラルでない場合は、パターン識別子に対してこれを区別するために、括弧にかこまれた式でなければならない。

  \item  {\it 集合列挙パターン} は集合値のみと適合する。
1つ1つのパターンは1つの集合の異なる要素と一致させられ; すべての要素が一致しなければならない。

  \item   {\it 集合合併パターン} は集合値のみと適合する。
1つの集合を2つに分けた部分集合に対して、2つのパターンが一致する。
2つの部分集合は、互いに素で、かつ合併すると元の集合になるように選ばれる。
元の集合の要素数が2以上の時、2つの部分集合は空で無いように分割される。
元の集合の要素数が1の時は、1つの部分集合は、空となる。

  \item  {\it 列列挙パターン} は唯一列値にのみ合致する。
 各々のパターンは列値中の対応する要素に対して一致する; 列長とパターン数は等しくなければならない。

  \item  {\it 列連結パターン} は唯一列値とのみ合致する。
 2つのパターンは、共に連結するともとの列値をつくることができる2つの部分列に、一致する。 
2つの部分列は常に空でないように選ばれる。

  \item  {\it 写像列挙パターン} は写像値とのみ合致する。

　 \item  {\it 写パターンリスト} は1つの写像の、それぞれ異なる写（maplet）と一致する; すべての写が一致しなければならない。

 \item  {\it 写像併合パターン} は写像値とのみ合致する。
 1つの写像を2つに分けた部分写像に対して、2つのパターンが一致する。
2つの部分写像は、互いに素となり、かつ併合すると元の写像と一致するように選ばれる。
元の写像の要素数が2以上の時、2つの部分写像は空で無いように分割される。
元の写像の要素数が1の時は、1つの部分写像は、空となる。

  \item  {\it 組パターン} は同じ要素数をもつ組にのみ合致する。
 パターンの各々は、組値の中で対応する要素に対して一致させられる。

  \item  {\it レコードパターン} は同じタグをもつレコード値にのみ適合する。
  パターンの各々は、レコード値の項目に対して一致させられる。
 レコードのすべての項目が一致させられなくてはならない。
  \end{enumerate}

\item[例題:] 以下にパターンの使用例を説明する。

\paragraph{パターン識別子の例}
最も単純なパターンはパターン識別子である。
この例は次に述べるlet式で与えられる:
\begin{alltt}
  \keyw{let} top = GroupA(1)
  \keyw{in} top.sc
\end{alltt}
ここで識別子 \texttt{top} は列\texttt{GroupA}の先頭と結びつき、したがって識別子はlet式の本体で用いられることが許される。

\paragraph{一致値の例}
以下の例では一致値を用いる:
\begin{alltt}
  \keyw{let} a = <France>
  \keyw{in} \keyw{cases} GroupA(1).team:
             <Brazil> -> "Brazil are winners",
             (a)      -> "France are winners",
             \keyw{others}    -> "Neither France nor Brazil are winners"
     \keyw{end;}
\end{alltt}
一致値は唯一それ自身の値と一致させることが可能なので、ここで \texttt{GroupA} の先頭のチームが \texttt{<Brazil>} であるならば最初の節で一致する; もし \texttt{GroupA} の先頭のチームが\texttt{<France>} であるなら2番目の節で一致する。
これら以外は\keyw{others}が一致する。
ここで \texttt{a}を囲んだ括弧の使用が、\texttt{a} を一致値とみなすよう強要していることに留意しよう。

\paragraph{集合列挙パターンの例}
集合列挙は、パターンを1つの集合の要素と一致させる。
たとえば次において
\begin{alltt}
  \keyw{let} \{sc1, sc2, sc3, sc4\} = \keyw{elems} GroupA
  \keyw{in} sc1.points + sc2.points + sc3.points + sc4.points;
\end{alltt}
識別子 \texttt{sc1}, \texttt{sc2}, \texttt{sc3} および\texttt{sc4} は \texttt{GroupA}の4つの要素と結び付けられる。
束縛の選択はゆるいものであることに注目しよう - たとえば\texttt{sc1} は\texttt{\keyw{elems}GroupA} の[どのような] 要素と結び付いてもよい。
この場合、もし \texttt{\keyw{elems} GroupA} がちょうど4つの要素を含んでいるわけではなかったら、この式は良形とはいえない。

\paragraph{集合合併パターンの例}
集合合併パターンは、集合を再帰関数呼出しに分解させるために用いることができる。
この1つの例は集合を (任意の順での)列に変換する関数 \texttt{set2seq}である:
\begin{alltt}
  set2seq[@elem] : \keyw{set of} @elem -> \keyw{seq of} @elem
  set2seq(s) ==
    \keyw{cases} s:
      \{\} -> [],
      \{x\} -> [x],
      s1 \keyw{union} s2 -> (set2seq[@elem](s1))^(set2seq[@elem](s2))
    \keyw{end}
\end{alltt}
caseの3番目の選択肢で、集合合併パターンを使用しているのがわかる。
これは \texttt{s1} と \texttt{s2} を\texttt{s}の任意の部分集合に束縛し、それによって \texttt{s}を区分けする。
 Toolboxインタープリタは常に互いに素の区分けを実現する。

\paragraph{列列挙パターンの例}
列列挙パターンは、1つの列から指定された要素を抽出するために用いることができる。この1つの例として関数 \texttt{promoted}があり、これはスコアの列の最初から2つの要素を抽出し、チームの中の対応する2つを返す:
\begin{alltt}
  promoted : \keyw{seq of} Score -> Team * Team
  promoted([sc1,sc2]^-) == \keyw{mk\_}(sc1.team,sc2.team);
\end{alltt}
ここで \texttt{sc1} は引数列の先頭と結びつき、\texttt{sc2} は列の2番目の要素と結びつく。
もし\texttt{promoted} が要素数が2つない列で呼び出されるなら、ランタイムエラーが起きる。
リストの残りの要素には興味を持たないので、それら残りに対して don't careパターンを用いていることに注目したい。

\paragraph{列連結パターンの例}
前に述べた例でも、列連結パターンの使用を行っている。
もうひとつの例として関数\texttt{quicksort}があるが、これは標準のクイックソートアルゴリズムを実装している:
\begin{alltt}
  quicksort : \keyw{seq of nat} -> \keyw{seq of nat}
  quicksort (l) ==
    \keyw{cases} l:
      [] -> [],
      [x] -> [x],
      [x,y] -> \keyw{if} x < y \keyw{then} [x,y] \keyw{else} [y,x],
      -^[x]^- -> quicksort ([y | y \keyw{in set elems} l & y < x]) ^ 
                 [x] ^ quicksort ([y | y \keyw{in set elems} l & y > x])
    \keyw{end}
\end{alltt}
ここで、 case式の最後のcases式選択肢で、列連結パターンは \texttt{l}をある任意のピボット(かなめ)要素と2つの部分列に分解するのに用いられている。
ピボットはリストをピボットより小さい値と大きい値に区分けるために用いられ、2つの区分けされた部分は再帰的にソートされる。

\paragraph{写像列挙パターンの例}
写像列挙パターンは、パターンを1つの写像と個々の写（maplet）と一致させる。
例えば、次の例では

\begin{alltt}
 \keyw{let} \{1 |-> a, a |-> b, b |-> c\} = \{1 |-> 4, 2 |-> 3, 4 |-> 2\} 
 \keyw{in} \keyw{mk_}(a, b, c)
\end{alltt}
aは、対応する定義域の値が1なので、4と一致する。
aが４なので、定義域の値が4である写の値域の値すなわちbの値は２になる。
同様に、bが２なので、cは3になる。

\paragraph{写像併合パターンの例}
写像併合パターンは、写像の写（maplet）を1つずつ処理する再帰関数に用いることができる。
ここでは、写像を（任意の順番で）写の列に変換する関数map2seqを示す。

\begin{alltt}
map2seq[@T1, @T2] : \keyw{map} @T1 \keyw{to} @T2 -> \keyw{seq of} (\keyw{map} @T1 \keyw{to} @T2)
map2seq(m) ==
  \keyw{cases} m:
    (\{|->\})	-> [],
    \{- |-> -\}	-> [m],
    m1 \keyw{munion} m2 -> map2seq[@T1, @T2] (m1) ^  map2seq[@T1, @T2] (m2)
  \keyw{end};
\end{alltt}

ここで、case式の3番目のcases式選択肢で、写像併合パターンを使用している。
m1とm2を写像mの任意の（互いに素な）部分写像に束縛する。

\paragraph{組パターンの例}
組パターンは、組構成要素を識別子と結びつけるために用いることができる。
たとえば上で定義された関数 \texttt{promoted} は2つを返すので、以下の値定義では \texttt{GroupA}の勝ったチームの方を識別子\texttt{Awinner}に結びつける:
\begin{alltt}
  \keyw{values}

    \keyw{mk\_}(Awinner,-) = promoted(GroupA);
\end{alltt}

\paragraph{レコードパターンの例}
レコードパターンはレコードのいくつかの項目が同じ式で用いられるときに役立つ。
たとえば次の式は、チーム名から点数スコアへの写像を構成する:
\begin{alltt}
  \{ t |-> w * 3 + l | \keyw{mk\_}Score(t,w,l,-,-) \keyw{in set elems} GroupA\}
\end{alltt}
 \pageref{printExprDef}ページの関数 \texttt{print\_Expr} もまた、レコードパターンのいくつかの例を与えてくれる。


\end{description}

\section{束縛}\label{bind}

\begin{description}
\item[構文:]
  \Rule{束縛}{
    \Ruleref{集合束縛} \dsepl \Ruleref{型束縛}
    }

  \Rule{集合束縛}{
    \Ruleref{パターン}, \Lop{in set}, \Ruleref{式}
    }

  \Rule{型束縛}{
    \Ruleref{パターン}, \Lit{:}, \Ruleref{型}
    }

  \Rule{束縛リスト}{
    \Ruleref{多重束縛}, \SeqPt{\Lit{,}, \Ruleref{多重束縛}}
    }

  \Rule{多重束縛}{
    \Ruleref{多重集合束縛} \dsep
    \Ruleref{多重型束縛}
    }

  \Rule{多重集合束縛}{
    \Ruleref{パターンリスト}, \Lop{in set}, \Ruleref{式}
    }

  \Rule{多重型束縛}{
    \Ruleref{パターンリスト}, \Lit{:}, \Ruleref{型}
    }

%\item[意味定義:] {\it 束縛}は、ある値にパターンを一致させる。
\item[意味定義:] {\it 束縛}は、あるパターンをある値に一致させる。
 {\it 集合束縛} において、値は束縛の集合式によって定義された集合から選ばれる。
 {\it 型束縛} において、値は型式で定義された型から選ばれる。
 {\it 多重束縛}は、いくつかのパターンが同じ集合または型に束縛されることを除けば {\it 束縛} と同じである。
型束縛はインタープリタで実行させることは {\bf できない} ことに注意しよう。
これは、インタープリタに自然数というような無限の定義域の検索を要求するということであるからだ。

\item[例題:] 束縛は主に、これらの例にみられるように限量式や内包で用いられる:
  \begin{alltt}
    \keyw{forall} i, j \keyw{in set inds} list \& i < j => list(i) <= list(j)
      
    \{ y | y \keyw{in set} S & y > 2 \}

    \{ y | y: nat & y > 3 \}

    occurs : \keyw{seq1 of char} * \keyw{seq1 of char} -> \keyw{bool}
    occurs (substr,str) ==
      \keyw{exists} i,j \keyw{in set inds} str & substr = str(i,...,j);

  \end{alltt}
\end{description}

\section{値(定数)定義} \label{valuedef}

\vdmslpp{\vdmsl}{\vdmpp}\ では定数値の定義をサポートする。 
値定義については、伝統的プログラム言語における定数定義に相当する。

\begin{description}
\item[構文:]
  \Rule{値定義群}{
    \Lop{value}, 
    \OptPt{\ifthenelse{\boolean{VDMpp}}{\Ruleref{アクセス値定義}}%
                                       {\Ruleref{値定義}}, \lfeed
           \SeqPt{\Lit{;}, 
                  \ifthenelse{\boolean{VDMpp}}{\Ruleref{アクセス値定義}}%
                                              {\Ruleref{値定義}}
                 }, 
           \OptPt{\Lit{;}}
          }
    }

  \ifthenelse{\boolean{VDMpp}}{
    \Ruledef{アクセス値定義}{
       (\OptPt{\Ruleref{アクセス}}, \OptPt{\Lop{static}})  \dsepl\ (\OptPt{\Lop{static}}, \OptPt{\Ruleref{アクセス}}), \lfeed 
         \Ruleref{値定義}
    }}{}


  \Rule{値定義}{
    \Ruleref{パターン}, \OptPt{\Lit{:}, \Ruleref{型}}, \Lit{=}, \Ruleref{式}
    }

\item[意味定義:] 値定義は次の形式をもつ:
  \begin{alltt}
    \keyw{values}
      \ifthenelse{\boolean{VDMpp}}{access}{} pat1 = e1;
      \ldots
      \ifthenelse{\boolean{VDMpp}}{access}{} patn = en
  \end{alltt}

  
グローバル値(値定義で定義された)は、 \vdmslpp{\vdmsl}{\vdmpp} 記述の全水準で参照が可能である。
しかしながら、1つの記述が実行可能であるためには、値定義の列に用いられる前段階でそれらの値は定義されていなければならない。 
この ``使用前の宣言'' 原則は、インタープリタが値定義にのみ使う。
 このことはたとえば、関数などは宣言される前に用いられることが可能なのである。
標準 VDM-SL では、定義の順番における制限はいっさい存在しない。
同様に型制限を提供することが可能であるから、このことでより正確な型情報を得るのに役立てることができる。


\item[例題:] 以下の例は \cite{Fitzgerald&98} からとったものであるが、識別子\texttt{p1} と \texttt{eid2}にトークン値を与え、\texttt{e3} に\texttt{Expert} レコード値を与え、そして \texttt{a1}に \texttt{Alarm} レコード値を与える。
\begin{alltt}
     \keyw{types}

     Period = \keyw{token};
     ExpertId = \keyw{token};
     Expert :: expertid : ExpertId
               quali : \keyw{set of} Qualification
     \keyw{inv} ex == ex.quali <> \{\};
     Qualification = <Elec> | <Mech> | <Bio> | <Chem>;
     Alarm :: alarmtext : \keyw{seq of} char
              quali : Qualification

     \keyw{values}
 
     \PUBLIC p1: Period = mk_token("Monday day");
     \PRIVATE eid2 : ExpertId = mk_token(145);
     \PROTECTED e3 : Expert = mk_Expert(eid2, { <Mech>, <Chem> });
     \mbox{} a1 : Alarm = mk_Alarm("CO2 detected", <Chem>)
\end{alltt}
 この例が示すように、ある値はそれ自身が定義される前に定義された他の値に依存できる。
  トップレベル仕様記述は多くのファイルやモジュールからの仕様記述から成り立つことができる(節~\ref{top-level}参照)。 
  命令が重要であるように、他のモジュール内で定義された値に依存させないことは、良い慣習である。
\end{description}


\section{状態定義}\label{statedef}

グローバル変数が仕様記述で要求されれば、状態定義をすることは可能である。状
態定義のコンポーネントは操作内で参照できるグローバル変数のコレクションと
見なすことが可能である。
モジュールの状態はモジュール内の(その状態を使用している)操作
定義のいずれかがインタープリタによって使用される前に初期化される。

\begin{description}
\item[構文:]
  \Rule{状態定義}{
    \Lop{state}, \Ruleref{識別子}, \Lop{of}, \Ruleref{項目リスト}, \lfeed
    \OptPt{\Ruleref{不変条件}}, \OptPt{\Ruleref{初期化}}, \Lop{end}, \OptPt{\Lit{;}}
    }

  \Rule{不変条件}{
    \Lop{inv}, \Ruleref{不変条件初期関数}
    }

  \Rule{初期化}{
    \Lop{init}, \Ruleref{不変条件初期関数}
    }

  \Rule{不変条件初期関数}{
    \Ruleref{パターン}, \Lit{==}, \Ruleref{式}}

\item[意味定義:] 状態定義は次の形式をもつ:
  \begin{alltt}
    \keyw{state} ident \keyw{of}
      id1 : type1
      \ldots
      idn : typen
    \Keyw{inv}  pat1 == inv
    \Keyw{init} pat2 == init
    \keyw{end}
  \end{alltt}
  状態識別子 {\tt idn}は特定の型 {\tt typen}であると宣言される。不変条件 {\tt inv}はいつも状態 {\tt ident}が保たなければならない特性を意味している論理式である。
  {\tt init}は初めに成立しなければならない状態を指示する。
  インタープリタを使用するためには、(もしも、状態を使用している操作が実行されるならば)初期化述語が必要であることに注意すべきである。
  加えてこの初期化述語の本体は状態全体の名称(その名称はパターン
  として使用されなくてはならない)を等式の左辺値とし、右辺値は正しい
  型のレコード値として評価される二項相当式でなくてはならない。これ
  はインタープリタが {\tt init} 状態を評価すること可能にする。初期化述語の簡単な例を以下に示す:

  \begin{alltt}
  \keyw{state} St \keyw{of}
    x:\keyw{nat}
    y:\keyw{nat}
    l:\keyw{seq1 of nat}
  \keyw{init} s == s = \keyw{mk\_}St(0,0,[1])
  \keyw{end}
  \end{alltt}

  不変条件と初期値の両方の仕様記述では、全体として状態を操作しなければならない。
  また、それを状態名(例を参照)でタグ付けされたレコードとして参照することによって行う。
  状態中の項目がoperationで操作されるとき、状態名が前に付いていない項目名によって、項目は直接参照されなければならない。



\item[例:] 以下の例では、一つの状態変数を作成している:
  \begin{alltt}
  \keyw{types }

  GroupName = <A> | <B> | <C> | <D> | <E> | <F> | <G> | <H>

  \keyw{state} GroupPhase \keyw{of}
    gps : \keyw{map} GroupName \keyw{to set of} Score
  \keyw{inv mk\_}GroupPhase(gps) ==
    \keyw{forall} gp \keyw{in set rng gps} & 
      (\keyw{card} gp = 4 \keyw{and}
       \keyw{forall} sc \keyw{in set} gp & sc.won + sc.lost + sc.drawn <= 3)
  \keyw{init} gp ==
    gp = \keyw{mk\_}GroupPhase ({ <A> |-> 
                                init_sc ({<Brazil>, <Norway>, 
                                    <Morocco>, <Scotland>}),
                         ...})
  \keyw{end}

  \keyw{functions}

  init_sc : \keyw{set of} Team -> \keyw{set of} Score
  init_sc (ts) ==
    \{ \keyw{mk\_}Score (t,0,0,0,0) | t \keyw{in set ts} \}
  \end{alltt}
  不変条件において、各グループには4 つのチームがあり、どのチームも3ゲーム以上行わないことを提示する。
  初めは、どのチームもゲームをしていない。

\end{description}

\section{操作定義} \label{op-def}

操作については第~\ref{algorithm}節にすでに述べてきた。 
一般的な形式は
\ifthenelse{\boolean{VDMsl}}{ここで述べる。}{すぐ次に述べるが、クラスのインスタンス構成に用いられる\emph{構成子} と呼ばれる特別な操作については 第~\ref{constructors}節に記述する。} 

\begin{description}
\item[構文:]
  \Rule{操作定義群}{
    \Lop{operations}, 
    \OptPt{\ifthenelse{\boolean{VDMpp}}{\Ruleref{アクセス操作定義}}%
                                       {\Ruleref{操作定義}}, \lfeed
           \SeqPt{\Lit{;}, 
                  \ifthenelse{\boolean{VDMpp}}{\Ruleref{アクセス操作定義}}%
                                       {\Ruleref{操作定義}}
                 }, 
           \OptPt{\Lit{;}}
          }
    }

  \ifthenelse{\boolean{VDMpp}}{
     \Rule{アクセス操作定義}{(
      \OptPt{\Ruleref{アクセス}}, \OptPt{\Lop{static}})  \dsep\  
     (
      \OptPt{\Lop{static}}, \OptPt{\Ruleref{アクセス}}), \lfeed
      \Ruleref{操作定義}
    }}{}


\Rule{操作定義}{
  \Ruleref{陽操作定義} \dsep
  \Ruleref{陰操作定義} \dsep
  \Ruleref{拡張陽操作定義}
  }

\Rule{陽操作定義}{
  \Ruleref{識別子}, \Lit{:}, \Ruleref{操作型}, \lfeed
  \Ruleref{識別子}, \Ruleref{パラメーター群}, \lfeed
  \Lit{{\tt ==}}, \lfeed  \Ruleref{操作本体}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{式}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{式}}
  }

\Rule{陰操作定義}{
  \Ruleref{識別子}, \Ruleref{パラメーター型}, \lfeed
  \OptPt{\Ruleref{識別子型ペアリスト}}, \lfeed
  \Ruleref{陰操作本体}
  }

\Rule{陰操作本体}{
  \OptPt{\Ruleref{外部節}}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{式}}, \lfeed
  \Lop{post}, \Ruleref{式}, \lfeed
  \OptPt{\Ruleref{例外}}
  }

\Rule{拡張陽操作定義}{
  \Ruleref{識別子}, \lfeed
  \Ruleref{パラメーター型}, \lfeed
  \OptPt{\Ruleref{識別子型ペアリスト}}, \lfeed
  \Lit{==}, \Ruleref{操作本体}, \lfeed
  \OptPt{\Ruleref{外部節}}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{式}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{式}}, \lfeed
  \OptPt{\Ruleref{例外}}
}

\Rule{操作型}{
  \Ruleref{任意の型}, \Lit{{\tt ==>}}, \Ruleref{任意の型}
  }

\Rule{任意の型}{
  \Ruleref{型} \dsepl \Lit{()}
  }

\Rule{パラメーター群}{
  \Lit{(}, \OptPt{\Ruleref{パターンリスト}}, \Lit{)}
  }

\Rule{パターンリスト}{
  \Ruleref{パターン}, \SeqPt{\Lit{,}, \Ruleref{パターン}}
  }

\Rule{操作本体}{
  \Ruleref{文} \dsep 
  \Lop{is not yet specified}\index{\keyw{is not yet specified}!operations}
  }

\Rule{外部節}{
  \Lop{ext}, \Ruleref{var情報}, \SeqPt{\Ruleref{var情報}}
  }

\Rule{var情報}{
  \Ruleref{モード}, \Ruleref{名称リスト}, \OptPt{\Lit{:}, \Ruleref{型}}
  }

\Rule{モード}{
  \Lop{rd} \dsepl \Lop{wr}
  }

\Rule{名称リスト}{
  \Ruleref{識別子}, \SeqPt{\Lit{,}, \Ruleref{識別子}}
  }

\Rule{例外}{
  \Lop{errs}, \Ruleref{エラーリスト}
  }

\Rule{エラーリスト}{
  \Ruleref{エラー}, \SeqPt{\Ruleref{エラー}}
  }

\Rule{エラー}{
  \Ruleref{識別子}, \Lit{:}, \Ruleref{式}, \Lit{->}, \Ruleref{式}
  }

\item[意味定義:]

陽操作の以下の例は、1つのチームがもうひとつを打ち負かす場合に
状態 \texttt{GroupPhase} 
を更新する。
\begin{alltt}\label{winDef}
  Win : Team * Team ==> ()
  Win (wt,lt) ==
    \keyw{let} gp \keyw{in set dom} gps \keyw{be st} 
         \{wt,lt\} \keyw{subset} \{sc.team | sc \keyw{in set} gps(gp)\}
    \keyw{in} gps := gps ++ \{ gp |-> 
                        \{\keyw{if} sc.team = wt
                         \keyw{then mu}(sc, won |-> sc.won + 1,
                                     points |-> sc.points + 3)
                         \keyw{else if} sc.team = lt
                         \keyw{then mu}(sc, lost |-> sc.lost + 1)
                         \keyw{else} sc 
                    | sc \keyw{in set} gps(gp)\}\}
    \Keyw{pre} \keyw{exists} gp \keyw{in set dom} gps & 
          \{wt,lt\} \keyw{subset} \{sc.team | sc \keyw{in set} gps(gp)\};
\end{alltt}
1つの陽操作は1つの文(あるいは1つのブロック文を用いてまとめられたいくつかの文)からなるが、これについては第 \ref{sec:stmt}節で述べられている。 
文は、必要とするどのような
状態
変数に対しても、適当と判断したときに読込みや書出しを行いアクセスすることが許されている。

陰操作は、オプションである事前条件、または必要不可欠な事後条件を用いて指定される。
たとえば、ここに暗黙に陰操作\texttt{Win}を指定できる:
\begin{alltt}
  Win (wt,lt: Team)
  \Keyw{ext wr} gps : \keyw{map} GroupName \keyw{to set of} Score
  \Keyw{pre} \keyw{exists} gp \keyw{in set dom} gps & 
          \{wt,lt\} \keyw{subset} \{sc.team | sc \keyw{in set} gps(gp)\}
  \Keyw{post} \keyw{exists} gp \keyw{in set dom} gps &
         \{wt,lt\} \keyw{subset} \{sc.team | sc \keyw{in set} gps(gp)\}
         \keyw{and} gps = gps~ ++ 
                       \{ gp |-> 
                         \{\keyw{if} sc.team = wt
                          \keyw{then} \keyw{mu}(sc, won |-> sc.won + 1,
                                     points |-> sc.points + 3)
                          \keyw{else if} sc.team = lt
                          \keyw{then mu}(sc, lost |-> sc.lost + 1)
                          \keyw{else} sc 
                     | sc \keyw{in set} gps(gp)\}\};
\end{alltt}

外部節の項目は、操作が扱うはずの
状態
変数をリストする。
予約語である \keyw{rd} の後にリストされた
状態
変数は読み取りのみができるが、その一方 \keyw{wr}の後にリストされた変数は読みとり書きだしの両方行うことができる。
 
これらの事前、事後条件に対して、インタープリタも操作定義の事前、事後条件として新しい関数を作成する。
しかし、仕様記述がグローバルな状態を含んでいるならば、状態は新たに作成された関数の一部である。 
したがって、以下のシグネチャを持つ関数が、事前、事後条件をもった操作に対して作成される
\footnote{しかしながら、これらの事前、事後条件の述語は単にブール関数であることを覚えておくべきである。
また、その状態のコンポーネントは、このような述語を呼び出すことによって変更してはいけない}:
\begin{alltt}
  \keyw{pre\_}Op : InType * State +> \keyw{bool}

  \keyw{post\_}Op : InType * OutType * State * State +> \keyw{bool}
\end{alltt}
以下は例外である:
\begin{itemize}
\item もし、操作が引数を取らないなら、シグネチャの{\tt InType}部分を {\tt \keyw{pre\_}Op} と {\tt \keyw{post\_}Op}
の両方で省略する。

\item もし、操作が値を返さないなら、{\tt OutType}部分を {\tt \keyw{post\_}Op}シグネチャにおいて省略する。

\item もし、仕様記述が状態を定義しないなら、両方のシグネチャの{\tt State}部分は省略する。

\end{itemize}

{\tt \keyw{post\_}Op}シグネチャにおいて、最初の {\tt State}部分は旧状態であるに対して、
2番目の {\tt State}部分は操作呼び出し後の状態である。

例えば、以下の仕様記述を考える:

\begin{quotation}
\begin{minipage}[t]{.4\textwidth}
\begin{alltt}
\keyw{module} A

\keyw{definitions}

\keyw{state} St \keyw{of}
  n : \keyw{nat}
\keyw{end}

\keyw{operations}

Op1 (a : \keyw{nat}) b :\keyw{nat}
\keyw{pre} a > 0
\keyw{post} b = 2 * a;

Op2 () b : \keyw{nat}
\keyw{post} b = 2;

Op3 ()
\keyw{post} \keyw{true}

\keyw{end} A

\end{alltt}
\end{minipage}
\begin{minipage}[t]{.4\textwidth}
\begin{alltt}
\keyw{module} B

\keyw{definitions}

\keyw{operations}

Op1 (a : \keyw{nat}) b : \keyw{nat}
\keyw{pre} a > 0
\keyw{post} b = 2 * a;

Op2 () b : \keyw{nat}
\keyw{post} b = 2;

Op3 ()
\keyw{post} \keyw{true}

\keyw{end} B
\end{alltt}
\end{minipage}
\end{quotation}

\textbf{module A}に対しこの仕様記述で定義されている事前事後条件の引用方法を以下に示す

\begin{tabular}{|>{\ttfamily\selectfont}p{.4\textwidth}p{.4\textwidth}|} \hline
\textrm{引用式} & 説明 \\ \hline
\keyw{pre}\_Op1(1,\keyw{mk}\_St(2))              
  & \texttt{n}を2に、\texttt{a}を1に束縛する \\
\keyw{post}\_Op1(1,2,\keyw{mk}\_St(1), \keyw{mk}\_St(2)) 
  & \texttt{a} を1に、\texttt{b} を2に、
    \texttt{n} の前の状態を1に、
      \texttt{n} の後の状態を2に束縛する \\
\keyw{post}\_Op2(2,\keyw{mk}\_St(1), \keyw{mk}\_St(2))   
  & \texttt{b} を2に、
    \texttt{n} の前の状態を1に、
      \texttt{n} の後の状態を2に束縛する \\
\keyw{post}\_Op3(\keyw{mk}\_St(1), \keyw{mk}\_St(2))     
  & \texttt{n} の前の状態を1に、
    \texttt{n} の後の状態を2に束縛する \\
\hline
\end{tabular}

\textbf{module B}に対しこの仕様記述で定義されている事前事後条件の引用方法を以下に示す

\begin{tabular}{|>{\ttfamily\selectfont}p{.4\textwidth}p{.4\textwidth}|} \hline
\textrm{引用式} & 説明 \\ \hline
\keyw{pre}\_Op1(1)     & \texttt{a} を1に束縛する\\
\keyw{post}\_Op1(1,2)  & \texttt{a} を1に、\texttt{b}を2に束縛する\\
\keyw{post}\_Op2(2)    & \texttt{b}を2に束縛する\\
\keyw{post}\_Op3()     & 何も束縛しない\\
\hline
\end{tabular}

\vspace{2ex}


例外節は、ある操作がエラー状態にどのように対処するかを記述をすることに用いることができる。
理論的根拠を持つための例外節は、正常なケースと例外ケースを切り離す分離することを可能にする。
例外を用いた記述では、どのように例外を起こすかについて言及はしていないが、どのような環境でエラー状態が起こり得るか、また操作を呼
び出した結果どのような影響が起きるかについて示す手段が与えられる。

例外節は次の形式をもつ:
\begin{alltt}
   \keyw{errs} COND1: c1 -> r1
       \ldots
       CONDn: cn -> rn
\end{alltt}
条件名 {\tt COND1}, \ldots, {\tt CONDn} は識別子で、起きる可能性があるエラーの種類を記述する\footnote{これらの名前は単に記憶を助けてくれる値であり、つまり意味定義上は重要でない。}。 
条件式 {\tt c1}, \ldots, {\tt cn} は、異なる種類のエラーに対する事前条件と考えることができる。
このようにこれらの式においては、引数リストから識別子をまた外部節リストからは変数を用いることができる (それらは事前条件と同じスコープをもつ)。
結果の式である {\tt r1},\ldots, {\tt rn} は相対的にみれば、異なる種類のエラーに対する事後条件と同じと考えられる。
これらの式においては、結果の識別子とグローバル変数 (書き込みのできる) の旧値もまた用いることができる。
このように、ここでのスコープは事後条件のスコープに相当する。

表面的には、ここでの例外と事前条件との間にはいくらか重複があるようにみえる。
しかしながらこれらの間には、どちらをいつ用いるべきか指し示す概念的な違いが存在する。 
事前条件は、その操作の呼び出しが正しく行なわれるためにどんなことを保証しなければならないかを指定する; 例外節は、例外条件が満たされたときに記述された操作がエラー処理の責任をとることを示す。
したがって通常は、例外節と事前条件は重複しない。

操作における次の例は、以下の状態定義を使用する:
\begin{alltt}
  \keyw{state} qsys \keyw{of}
    q : Queue
  \keyw{end}
\end{alltt}    
この例では、陰操作の例外がどのように用いられるか示される:
\begin{alltt}
  DEQUEUE() e: [Elem]
  \keyw{ext} \keyw{wr} q : Queue
  \keyw{post} q~ = [e] ^ q
  \keyw{errs} QUEUE_EMPTY: q = [] -> q = q~ \keyw{and} e = \keyw{nil}
\end{alltt}

これはデキュー操作であって、 型{\tt Queue}の グローバル変数 {\tt q}を用いて、キューから型{\tt Elem}の 要素{\tt e}をとりのぞく。 
ここでの例外としては、その中で例外節が操作がどのように行われるかを指定するキューが、空である場合がある。

Toolboxはここで以下の関数を作成することに注意する:
\begin{alltt}
  \keyw{post\_}DEQUEUE: [Elem] * qsys * qsys +> \keyw{bool}
\end{alltt}


\end{description}


\section{文}\label{sec:stmt}

この章では、異なる種類の文を1種類ごとに記述する。 
各々は、次の方法で記述されていく:
\begin{itemize}
\item BNF構文記法。
\item 形式的でない意味定義記述。
\item 使用例を1つ。
\end{itemize}

\subsection{let文}\label{letstmt}

\begin{description}
\item[構文:]
  \Rule{文}{
    \Ruleref{let文} \dsep
    \Ruleref{let be文} \dsep
    \ldots
    }

  \Rule{let文}{
    \Lop{let}, \Ruleref{ローカル定義}, \SeqPt{\Lit{,}, \Ruleref{ローカル定義}}, \lfeed
    \Lop{in}, \Ruleref{文}
    }

  \Rule{let be文}{
    \Lop{let}, \Ruleref{束縛}, \OptPt{\Lop{be}, \Lop{st}, \Ruleref{式}},
    \Lop{in}, \lfeed
    \Ruleref{文}
    }

  \Rule{ローカル定義}{
    \Ruleref{値定義} \dsep \Ruleref{関数定義}
    }

  \Rule{値定義}{ 
    \Ruleref{パターン}, \OptPt{\Lit{:}, \Ruleref{型}}, \Lit{=}, \Ruleref{式}
    }

 ここでの構成要素である ``関数定義'' は第~\ref{functiondef}節に記述されている。

\item[意味定義:]  {\it let文} と {\it let-be-such-that文} は、{\it in}の部分が式であるかわりに文であることを除けば、各々がそれぞれ {\it let} と {\it let-be-such-that式} に対応し似ている。
これは以下のように説明することができる:

  単純な {\it let文} は次の形式をもつ:
  \begin{alltt}
    \keyw{let} p1 = e1, \ldots, pn = en \keyw{in} s
  \end{alltt}
ここで {\tt p1, \ldots, pn} はパターン、{\tt e1, \ldots, en} は対応するパターンである{\tt pi}に一致する式、そして {\tt s}は任意の型の文であるが {\tt  p1, \ldots, pn}というパターン識別子を含む。 
これは、パターン {\tt p1, \ldots, pn} が式{\tt e1, \ldots, en}に対して一致する文脈中での、文 {\tt s} の評価を示す。

ローカル関数定義を用いることで、より高度な let 文をつくることもできる。
これを行う意味定義は単純で、このようなローカルに定義された関数のスコープはlet文の本体に制限される。

  VDM-SLでは、複数の定義が互いに再帰的になるかもしれない。
%  However, this is not supported by the interpreter in IFAD VDM-SL.
  しかしながら、これはVDM-SLでインタプリタによってサポートされていない。
  その上、定義を使用されている前に、すべての構成要素が定義されるように命令しなければならない。

  {\it let-be-such-that文}は次の形式をもつ
  \begin{alltt}
    \keyw{let} b \keyw{be st} e \keyw{in} s
  \end{alltt}
ここで {\tt b} は束縛であって集合値(または型)に対するパターンからなり、 {\tt  e} はブール式、 そして{\tt s} は文であって {\tt b}におけるパターンのパターン識別子を含むものである。 
 {\tt \keyw{be st} e}の部分はオプションである。
この式は、{\tt b}からの集合(または型)の要素に対し{\tt b}からのパターンが一致する文脈中での、文 {\tt s} の評価を示すものである\footnote{集合束縛のみがインタープリタで実行できるということを思い出そう。}。 
 \keyw{be st}式である{\tt e}が存在するとき、唯一このような束縛が、一致させる文脈中で{\tt e} が真と評価される場所で用いられる。
     
\item[例題:] \keyw{let be st} 文の1つの例は、
操作 \texttt{GroupWinner}中にあり、あるグループ内での勝チームを返してくれるものである: 
  \begin{alltt}
  GroupWinner : GroupName ==> Team
  GroupWinner (gp) ==
    \keyw{let} sc \keyw{in set} gps(gp) \keyw{be st}
       \keyw{forall} sc' \keyw{in set} gps(gp) \verb+\+ \{sc\} & 
          (sc.points > sc'.points) \keyw{or}
          (sc.points = sc'.points \keyw{and} sc.won > sc'.won)
    \keyw{in return} sc.team
  \end{alltt}
 仲間の操作である\texttt{GroupRunnerUp} もまた同様に、簡単な let 文の例を与えてくれる:
  \begin{alltt}
  GroupRunnerUp_expl : GroupName ==> Team
  GroupRunnerUp_expl (gp) ==
    \keyw{def} t = GroupWinner(gp)
    \keyw{in let} sct = \keyw{iota} sc \keyw{in set} gps(gp) & sc.team = t
      \keyw{in}
         \keyw{let} sc \keyw{in set} gps(gp) \verb+\+ \{sct\} \keyw{be st}
           \keyw{forall} sc' \keyw{in set} gps(gp) \verb+\+ \{sc,sct\} & 
             (sc.points > sc'.points) \keyw{or}
             (sc.points = sc'.points \keyw{and} sc.won > sc'.won)
         \keyw{in return} sc.team
  \end{alltt}
ここにおける \texttt{def} 文 (第 \ref{defstmt}節参照)の使用に注意; 右辺が操作呼出しであるために \texttt{let} 文ではなくこれを用いるが、したがってこれは式ではない。
\end{description}

\subsection{def文}\label{defstmt}

\begin{description}
\item[構文:]
  \Rule{文}{
    \ldots \dsep
    \Ruleref{def文} \dsep \ldots
    }

  \Rule{def文}{
    \Lop{def}, 
    \Ruleref{相等定義}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{相等定義}},\OptPt{\Lit{;}},
    \Lop{in}, \lfeed
    \Ruleref{文}
    } 

  \Rule{相等定義}{
    \Ruleref{パターン束縛}, \Lit{=},
    \Ruleref{式}}

\item[意味定義:] {\it def文} は次の形式をもつ:
  \begin{alltt}
    \Keyw{def} pb1 = e1;
        \ldots
        pbn = en
    \keyw{in}
      s
  \end{alltt}
  {\it def文} は、 右辺において操作呼出しを用いることが許される点を除けば{\it def式}に相当するものである。 
このような、状態を変化させる操作もここで用いることができ、またもし複数の定義がなされている場合には、出現した順に評価が行われる。 
 このことは、パターン(または束縛){\tt pb1, \ldots, pbn}が対応する式や演算呼出し{\tt e1, \ldots, en}によって返される値と一致する文脈中の文{\tt s} の評価の外延を表す\footnote{束縛が用いられるのであれば第~\ref{patterns}節で説明されるように、パターンと一致し得る値はさらに型や集合式により束縛がなされることを単純に意味する。}。

\item[例題:]  以下の列が与えられている:
  \begin{alltt}
  secondRoundWinners = [<A>,<B>,<C>,<D>,<E>,<F>,<G>,<H>];
  secondRoundRunnersUp = [<B>,<A>,<D>,<C>,<F>,<E>,<H>,<G>]
  \end{alltt}
操作\texttt{SecondRound}%
は組の列を返し、第2ラウンドゲームが\keyw{def}文の例を与えていることを表わす:
  \begin{alltt}
  SecondRound : () ==> \keyw{seq of} (Team * Team)
  SecondRound () ==
  \keyw{def} winners = \{ gp |-> GroupWinner(gp) | gp \keyw{in set dom} gps \};
     runners_up = \{ gp |-> GroupRunnerUp(gp) | gp \keyw{in set dom} gps\}
  \keyw{in return} ([mk_(winners(secondRoundWinners(i)),
                runners_up(secondRoundRunnersUp(i))) 
           | i \keyw{in set} \{1,...,8\}])
  \end{alltt}

\end{description}

\subsection{ブロック文} \label{dcl-stmt}

\begin{description}
\item[構文:]
  \Rule{文}{
    \ldots \dsep
    \Ruleref{ブロック文} \dsep \ldots
    }

  \Rule{ブロック文}{
    \Lit{(}, \SeqPt{\Ruleref{dcl文}}, \lfeed
    \Ruleref{文}, \SeqPt{\Lit{;}, \Ruleref{文}}, \OptPt{\Lit{;}}, \Lit{)}
    }

  \Rule{dcl文}{
    \Lop{dcl}, \Ruleref{代入定義}, \lfeed
    \SeqPt{\Lit{,}, \Ruleref{代入定義}}, \Lit{;}
    }

  \Rule{代入定義}{
    \Ruleref{識別子}, \Lit{:}, \Ruleref{型}, \OptPt{\Lit{:=},
    \Ruleref{式}}}

\item[意味定義:] {\it ブロック文}は、伝統的な高水準プログラム言語におけるブロック文に相当する。
ブロック文を用いることで、(宣言文を使用して)ブロック文の本体内での変更が許されたローカル定義変数の使用が可能となる。
これは単に、個々の文が規定することを順に実行することを示すものである。
文の列において1つの値を返す最初の文により、文の列を終了させるための評価がひき起こされる。
この値はブロック文の値として返される。
ブロック内のどの文も値を返さない場合には、ブロック文の評価はブロック内の最後の文が評価されたときに終了する。
ブロック文が中止された場合には、ローカル変数の値は開放される。
このように、これら変数のスコープは単純にブロック文の内部である。
      
\item[例題:] 次のような
state definition
  \begin{alltt}\label{stdef}
  \keyw{state} St \keyw{of}
    x:\keyw{nat}
    y:\keyw{nat}
    l:\keyw{seq1 of nat}
  \keyw{end}
  \end{alltt}
に関連したものとして
ここに述べる\texttt{Swap} 操作は、変数 \texttt{x} と \texttt{y}の値交換を行うためにブロック文を用いる:
  \begin{alltt}
  Swap : () ==> ()
  Swap () ==
    (\keyw{dcl} temp: \keyw{nat} := x;
     x := y;
     y := temp
    )
  \end{alltt}

\end{description}

\subsection{代入文}

\begin{description}
\item[構文:]
  \Rule{文}{
    \ldots \dsep
%    \ifthenelse{\boolean{VDMpp}}{\Ruleref{一般代入文}}%
%                                {\Ruleref{代入文}} \dsep
    \Ruleref{一般代入文} \dsep
    \ldots
    }

%\ifthenelse{\boolean{VDMpp}}{%
  \Rule{一般代入文}{
  \Ruleref{代入文} \dsep
  \Ruleref{多重代入文}
  }
%}%
%{}

\Rule{代入文}{
  \Ruleref{状態指示子}, \Lit{:=}, 
    \Ruleref{式}
  }

  \Rule{状態指示子}{
    \Ruleref{名称} \dsep
    \Ruleref{項目参照} \dsep
    \Ruleref{写像参照または列参照}
    }

  \Rule{項目参照}{
    \Ruleref{状態指示子}, \Lit{.}, \Ruleref{識別子}
    }

%koizumi change_start
%  \Rule{写像参照}{
%    \Ruleref{状態指示子}, \Lit{(}, \Ruleref{式}, \Lit{)}
%    }

%  \Rule{列参照}{
%    \Ruleref{状態指示子}, \Lit{(}, \Ruleref{式}, \Lit{)}
%    }

  \Rule{写像参照または列参照}{
    \Ruleref{状態指示子}, \Lit{(}, \Ruleref{式}, \Lit{)}
    }
%koizumi change_end
%\ifthenelse{\boolean{VDMpp}}{%
  \Rule{多重代入文}{
    \Lit{atomic}, 
    \Lit{(}
      \Ruleref{代入文}, \Lit{;}, \lfeed
      \Ruleref{代入文},
      \lfeed
%      \OptPt{\SeqPt{\Lit{;},\Ruleref{代入文}}}
      \SeqPt{\Lit{;},\Ruleref{代入文}}
    \Lit{)}
    }
%  }%
%{}

\item[意味定義:]  {\it 代入文} は、伝統的な高水準プログラム言語における代入文を一般化したものに相当する。
これを用いてグローバル状態またはローカル状態の値を変更する。
したがって代入文は、状態を変える副作用を起こす。
しかしながら、単純にある状態の一部を変更することができるように、代入文の左辺を状態指定子とすることができる。
状態指定子とは、単純なグローバル変数の名前、変数項目への参照、変数の写像参照、または変数の列参照、である。
この方法で、ある状態の小さな構成子の値を変更することが可能だ。
たとえば、もし状態構成要素が写像であったならば、写像のひとつの要素を変更することが可能である。

 代入文は次の形式をもつ:
  \begin{alltt}
    sd := ec
  \end{alltt}
 ここで {\tt sd} は状態指定子であり、 {\tt ec}は式または操作呼出しである。
代入文は、(式または操作呼出しの)右辺に記述された既に与えられている状態構成要素への変更を示す。
もし右辺が操作変更の状態であるならば、その操作は代入が行われる前に(それ相当の副作用を伴い)実行される。 


 多重代入もまた可能である。
これは次の形式をもつ：
  \begin{alltt}
    \keyw{atomic} (sd1 := ec1;
\           ...;
\           sdN := ecN
           )
  \end{alltt}
右辺の式または操作呼出しはすべて、実行されるかあるいは評価され、その結果は相当の状態指定子に結び付けられる。
右辺は、不変条件評価に関しては原子的に実行される。

\item[例題:] 前に述べた例(\texttt{Swap})における操作は、通常の代入を表していた。
次の\texttt{Win\_sd}操作は、\pageref{winDef}ページの\texttt{Win}を手直ししたものであり、特定の写像キーに代入をおこなう状態指示子の仕様記述を行っている:
  \begin{alltt}
  Win_sd : Team * Team ==> ()
  Win_sd (wt,lt) ==
    \keyw{let} gp \keyw{in set dom} gps \keyw{be st} 
        \{wt,lt\} \keyw{subset} \{sc.team | sc \keyw{in set} gps(gp)\}
    \keyw{in} gps(gp) := \{ \keyw{if} sc.team = wt
                   \keyw{then mu}(sc, won |-> sc.won + 1,
                               points |-> sc.points + 3)
                   \keyw{else if} sc.team = lt
                   \keyw{then mu}(sc, lost |-> sc.lost + 1)
                   \keyw{else} sc 
                 | sc \keyw{in set} gps(gp)\}
  \Keyw{pre} \keyw{exists} gp \keyw{in set dom} gps & 
                 \{wt,lt\} \keyw{subset} \{sc.team | sc \keyw{in set} gps(gp)\}
  \end{alltt}
\texttt{SelectionSort}操作 は\pageref{selectionSortdef}ページにおける\texttt{selection\_sort}関数の状態使用版である。
これは、~\pageref{stdef}ページに定義された
state \texttt{St}
を用いて、特定の列索引の内容を変更するための状態指示子の使用を述べている。 
  \begin{alltt}
  \keyw{functions}
 
  min_index : \keyw{seq1 of nat} -> \keyw{nat}
  min_index(l) ==
  \keyw{if len} l = 1 \keyw{then} 1
  \keyw{else let} mi = min_index(\keyw{tl} l)
     \keyw{in if} l(mi+1) < \keyw{hd} l
       \keyw{then} mi+1
       \keyw{else} 1

  \keyw{operations}

  SelectionSort : \keyw{nat} ==> ()
  SelectionSort (i) ==
    \keyw{if} i < \keyw{len} l
    \keyw{then} (\keyw{dcl} temp: \keyw{nat};
         \keyw{dcl} mi : \keyw{nat} := min_index(l(i,...,\keyw{len} l)) + i - 1;
         temp := l(mi);
         l(mi) := l(i);
         l(i) := temp;
         SelectionSort(i+1)
        );
  \end{alltt}

\end{description}

\subsection{条件文}\label{condstmt}

\begin{description}
\item[構文:]
  \Rule{文}{
    \ldots \dsep
    \Ruleref{if文} \dsep
    \Ruleref{cases文} \dsep \ldots
    }

  \Rule{if文}{
    \Lop{if}, \Ruleref{式}, \Lop{then}, \Ruleref{文}, \lfeed
    \SeqPt{\Ruleref{elseif文}}, \OptPt{\Lop{else}, \Ruleref{文}}
    }

  \Rule{elseif文}{
    \Lop{elseif}, \Ruleref{式}, \Lop{then}, \Ruleref{文}
    }

  \Rule{cases文}{
    \Lop{cases}, \Ruleref{式}, \Lit{:}, \lfeed
    \Ruleref{cases文選択肢群}, \lfeed
    \OptPt{\Lit{,}, \Ruleref{others文}}, \Lop{end}
    }

  \Rule{cases式選択肢群}{
    \Ruleref{cases文選択肢}, \lfeed
    \SeqPt{\Lit{,}, \Ruleref{cases文選択肢}}
    }

  \Rule{cases文選択肢}{
    \Ruleref{パターンリスト}, \Lit{->}, \Ruleref{文}
    }

  \Rule{others文}{
    \Lop{others}, \Lit{->}, \Ruleref{文}
    }

\item[意味定義:]   {\it if文}の意味定義は、文に代わることを除けば (また \keyw{else} 部分がオプションであることも除けば)、第~\ref{if-exp}節に述べられた {\it if式} に相当する\footnote{ \keyw{else}部分が省略される場合は、意味定義上は \keyw{else skip}を用いるのと同じである。}。 
  
 {\it cases文} に対する意味定義は、文に代わることを除けば、第~\ref{cases-exp}節に述べられた{\it cases式} に相当する。

\item[例題:] 以下のシグネチャをもつ、関数 \texttt{clear\_winner} と \texttt{winner\_by\_more\_wins} そして演算 \texttt{RandomElement} を仮定する:
  \begin{alltt}
    clear_winner : \keyw{set of} Score -> \keyw{bool}
    winner_by_more_wins : \keyw{set of} Score -> \keyw{bool}
    RandomElement : \keyw{set of} Team ==> Team
  \end{alltt}
その後、操作 \texttt{GroupWinner\_if} ではネストしたif文使用の実例が挙げられている(iota式については \pageref{iotaexpr}ページで紹介されている):
  \begin{alltt}
  GroupWinner_if : GroupName ==> Team
  GroupWinner_if (gp) ==
    \keyw{if} clear_winner(gps(gp))
     -- 他のどのスコアより点数が多いgps(gp)の
     -- 唯一のスコアを返す
    \keyw{then return} ((\keyw{iota} sc \keyw{in set} gps(gp) &
                   \keyw{forall} sc' \keyw{in set} gps(gp) \verb+\+ \{sc\} &
                     sc.points > sc'.points).team)
    \keyw{else if} winner_by_more_wins(gps(gp))
     -- 最大の点数であり最大点数の他のスコアより多く勝っている
     -- gps(gp)における唯一のスコアを返す
    \keyw{then return} ((\keyw{iota} sc \keyw{in set} gps(gp) &
              \keyw{forall} sc' \keyw{in set} gps(gp) \verb+f+\ \{sc\} &
                (sc.points > sc'.points) \keyw{or}
                (sc.points = sc'.points \keyw{and} 
                 sc.won > sc'.won)).team)
     -- まったくの勝者はなく、よって最高スコアの中から
     -- 無作為にスコアを選ぶ
    \keyw{else} RandomElement ( \{sc.team | sc \keyw{in set} gps(gp) &
                           \keyw{forall} sc' \keyw{in set} gps(gp) &
                            sc'.points <= sc.points\} );
  \end{alltt}
  代わりとして、この操作に対しては一致値パターンをもつ cases文を用いることができるだろう: 
  \begin{alltt}
  GroupWinner_cases : GroupName ==> Team
  GroupWinner_cases (gp) ==
    \keyw{cases true}:
      (clear_winner(gps(gp))) -> 
           \keyw{return} ((\keyw{iota} sc \keyw{in set} gps(gp) &
                     \keyw{forall} sc' \keyw{in set} gps(gp) \verb+\+ \{sc\} &
                      sc.points > sc'.points).team),

      (winner_by_more_wins(gps(gp))) ->
           \keyw{return} ((\keyw{iota} sc \keyw{in set} gps(gp) &
                     \keyw{forall} sc' \keyw{in set} gps(gp) \verb+\+ \{sc\} &
                       (sc.points > sc'.points) \keyw{or}
                       (sc.points = sc'.points \keyw{and} 
                          sc.won > sc'.won)).team),

      \keyw{others} -> RandomElement ( \{sc.team | sc \keyw{in set} gps(gp) &
                                  \keyw{forall} sc' \keyw{in set} gps(gp) &
                                   sc'.points <= sc.points\} )
    end
  \end{alltt}

\end{description}

\subsection{forループ文}

\begin{description}
\item[構文:]
  \Rule{文}{
    \ldots \dsep
    \Ruleref{列forループ} \dsep
    \Ruleref{集合forループ} \dsep
    \Ruleref{索引forループ} \dsep \ldots
    }

  \Rule{列forループ}{
    \Lop{for}, \Ruleref{パターン束縛}, \Lop{in}, 
    \OptPt{\Lop{reverse}}, \Ruleref{式}, \lfeed
    \Lop{do}, \Ruleref{文}
    }\index{for loop}

  \Rule{集合forループ}{
    \Lop{for}, \Lop{all}, \Ruleref{パターン},
    \Lit{\keyw{in set}}, \Ruleref{式},\lfeed
    \Lop{do}, \Ruleref{文}
    }

  \Rule{索引forループ}{
    \Lop{for}, \Ruleref{識別子}, \Lit{$=$}, \Ruleref{式},
    \Lop{to}, \Ruleref{式}, \lfeed
    \OptPt{\Lop{by}, \Ruleref{式}}, \Lop{do}, \Ruleref{文}
    }

\item[意味定義:] {\it forループ文}には3種類ある。
索引を用いるforループはほとんどの高水準プログラム言語において知られているものである。
さらに、集合や列を用いる2つのforループがある。
これらは特に、集合 (または列)のすべての要素に対するアクセスが1つ1つ必要とされる場合に役立つ。

 {\it 索引forループ文} は次の形式をもつ:
  \begin{alltt}
    \keyw{for} id = e1 \keyw{to} e2 \keyw{by} e3 \keyw{do}
    s
  \end{alltt}
 ここにおいて {\tt id} は識別子、{\tt e1} と {\tt e2} はループの下限と上限を示す整数式、 {\tt e3}はステップ幅を示す整数式、そして {\tt s} は文でここで識別子 {\tt id} を用いることができる。
これは連続する文としての文 {\tt s}の評価を表すが、現文脈は{\tt id}の束縛により拡張されたものである。
このように、最初に {\tt s} が評価されるとき、 {\tt id} は下限{\tt e1}などの評価から戻ってきた値に束縛され、これは上限に達するまでつまり、 \texttt{s} $>$ \texttt{e2}となるまで同様に繰り返される。 
{\tt e1, e2} および {\tt e3} はループに入る前に評価されることに、注意したい。

 {\it 集合forループ文\/} は次の形式をもつ:
  \begin{alltt}
    \keyw{for all} e \keyw{in set} S \keyw{do}
    s
  \end{alltt}
 ここで {\tt S} は集合式である。
文 {\tt s} は、集合{\tt S}からｅの束縛で拡張され部分列の値となった現環境において評価される。

 {\it 列forループ文\/} は次の形式をもつ:
  \begin{alltt}
    \keyw{for} e \keyw{in} l \keyw{do}
    s
  \end{alltt}
ここで {\tt l} は列式である。
文 {\tt s} は、列 {\tt l}からｅの束縛と共に拡張され部分列値となった現環境で、評価される。
キーワード \keyw{reverse}が用いられる場合は、列 {\tt l}の要素は逆順にとられる。

\item[例題:] 操作 \texttt{Remove} は、数の列から与えられた1つの数のすべての出現を削除するための、 \textit{列for}ループの使用について説明している: 
  \begin{alltt}\label{removeDef}
  Remove : (\keyw{seq of nat}) * \keyw{nat} ==> \keyw{seq of nat}
  Remove (k,z) ==
  (\keyw{dcl} nk : \keyw{seq of nat} := [];
   \keyw{for} elem \keyw{in} k \keyw{do}
     \keyw{if} elem <> z
     \keyw{then} nk := nk^[elem];
   \keyw{return} nk
  );
  \end{alltt}
  \textit{集合for}ループは、全グループの勝者集合を戻すように開発されることも可能である:
  \begin{alltt}
  GroupWinners: () ==> \keyw{set of} Team
  GroupWinners () ==
  (\keyw{dcl} winners : \keyw{set of} Team := \{\};
   \keyw{for all} gp \keyw{in set dom} gps \keyw{do}
     (\keyw{dcl} winner: Team := GroupWinner(gp);
      winners := winners \keyw{union} \{winner\}
     );
   \keyw{return} winners
   );
  \end{alltt}
次の \textit{索引for}ループの例は、古典的なバブルソートアルゴリズムである:
  \begin{alltt}
  BubbleSort : \keyw{seq of nat} ==> \keyw{seq of nat}
  BubbleSort (k) ==
    (\keyw{dcl} sorted_list : \keyw{seq of nat} := k;
     \keyw{for} i = \keyw{len} k \keyw{to} 1 \keyw{by} -1 \keyw{do}
       \keyw{for} j = 1 to i-1 \keyw{do}
         \keyw{if} sorted_list(j) > sorted_list(j+1)
         \keyw{then} (\keyw{dcl} temp:\keyw{nat} := sorted_list(j);
               sorted_list(j) := sorted_list(j+1);
               sorted_list(j+1) := temp
              );
     \keyw{return} sorted_list
     )
\end{alltt}
\end{description}

\subsection{whileループ文}

\begin{description}
\item[構文:]
  \Rule{文}{
    \ldots \dsep
    \Ruleref{whileループ} \dsep \ldots
    }
  
  \Rule{whileループ}{
    \Lop{while}, \Ruleref{式}, \Lop{do}, \Ruleref{文}
    }

\item[意味定義:]  {\it while文} に対する意味定義は、伝統的なプログラム言語からもってきた while 文 に対応する。
 {\it whileループ\/} の形式は次のとおり:
  \begin{alltt}
    \keyw{while} e \keyw{do}
      s
  \end{alltt}
ここで、 {\tt e} はブール式、 {\tt s} は文である。
式 {\tt e} が \keyw{true} と評価される限りは、本体文 {\tt    s}が評価される。

\item[例題:] {\it whileループ}については、相対誤差 \texttt{e}内で実数 \texttt{r} の平方根を近似するニュートン法を用いた以下の例により、説明できる。
  \begin{alltt}\label{squarerootDef}
  SquareRoot : \keyw{real} * \keyw{real} ==> \keyw{real}
  SquareRoot (r,e) ==
    (\keyw{dcl} x:\keyw{real} := 1,
        nextx:\keyw{real} := r;
     \keyw{while} \keyw{abs} (x - nextx) >= e * x \keyw{do}
       ( x := nextx;
         nextx := ((r / x) + x) / 2;
       );
     \keyw{return} nextx
    );
  \end{alltt}
\end{description}

\subsection{非決定文}

\begin{description}
\item[構文:]
  \Rule{文}{
    \ldots \dsep
    \Ruleref{非決定文} \dsep \ldots
    }
  
  \Rule{非決定文}{
    \Lit{||}, \Lit{(}, \Ruleref{文},\lfeed
    \SeqPt{\Lit{,}, \Ruleref{文}}, \Lit{)}
    }

\item[意味定義:]  {\it 非決定文} は次の形式をもつ:
  \begin{alltt}
    || (stmt1, stmt2, \ldots, stmtn)
  \end{alltt}
またこれは文構成要素 {\tt  stmti} の任意の(非決定)順の実行を表すものである。
しかしながら、文構成要素は同時に実行されるものではないことに注意するべきであろう。
インタープリタは、このような構成要素が非決定文と呼ばれるにも関わらず、非公開の決定的順序\footnote{インタープリタの使用者がこれらの文要素が実行される順は知らないとしても、 「プロジェクトオプション」の「乱数発生初期値」が用いられない限りは常に同じ順で実行される。}を適用するであろうことには注意すること。

\item[例題:] 次の
状態定義
  \begin{alltt}
  \keyw{state} St \keyw{of}
    x:\keyw{nat}
    y:\keyw{nat}
    l:\keyw{seq1 of nat}
  \keyw{end}
  \end{alltt}
を用いてバブルソートを行うために非決定文が使用できる:

  \begin{alltt}\label{sortDef}
  Sort: () ==> ()
  Sort () ==
    \keyw{while} x < y \keyw{do}
      ||(BubbleMin(), BubbleMax());
  \end{alltt}
ここで\texttt{BubbleMin}は、部分列 \texttt{l(x,...,y)}内の最小値を ``bubbles''した後に列の先頭にもってくる、また\texttt{BubbleMax}は、部分列 \texttt{l(x,...,y)}内の最大値を``bubbles''した後に列の最終索引におく。
\texttt{BubbleMin}は最小値の索引を見つけるために、最初に部分列を通して行う繰り返しにおいて働く。
この索引の内容はその後、列\texttt{l(x)}の先頭の内容と交換される。
  \begin{alltt}
  BubbleMin : () ==> ()
  BubbleMin () ==
    (\keyw{dcl} z:\keyw{nat} := x;
     \keyw{dcl} m:\keyw{nat} := l(z);
     -- find min val in l(x..y)
     \keyw{for} i = x \keyw{to} y \keyw{do}
       \keyw{if} l(i) < m
       \keyw{then} ( m := l(i);
              z := i);
     -- move min val to index x
     (\keyw{dcl} temp:\keyw{nat};
      temp := l(x);
      l(x) := l(z);
      l(z) := temp;
      x := x+1));
\end{alltt}
\texttt{BubbleMax}もまた同様に操作する。
こちらは最大値の索引を見つけるために、部分列を通して反復を行い、その後この索引の内容を部分列の最後の要素の内容と交換する。
\begin{alltt}
  BubbleMax : () ==> ()
  BubbleMax () ==
    (\keyw{dcl} z:\keyw{nat} := x;
     \keyw{dcl} m:\keyw{nat} := l(z);
     -- find max val in l(x..y)
     \keyw{for} i = x \keyw{to} y \keyw{do}
       \keyw{if} l(i) > m
       \keyw{then} ( m := l(i);
              z := i);
     -- move max val to index y
     (\keyw{dcl} temp:\keyw{nat};
      temp := l(y);
      l(y) := l(z);
      l(z) := temp;
      y := y-1));
  \end{alltt}
\end{description}

\subsection{call文}
\label{call-stmt}

\begin{description}
\item[構文:]
  \Rule{文}{
    \ldots \dsep
    \Ruleref{call文} \dsep \ldots
    }
  \Rule{call文}{
    \Ruleref{名称}, \Lit{(}, \OptPt{\Ruleref{式リスト}}, \Lit{)}
    }

\item[意味定義:]  {\it call文}は次の形式をもつ:
  \begin{alltt}
    opname(param1, param2, \ldots, paramn)
  \end{alltt}


 {\it call文} は操作 {\tt opname}を呼び、 %
その操作を評価した結果を返す。
操作はグローバル変数を扱うことができるので、 {\it call文} は関数呼出しがそうするように必ずしも値を戻す必要はない。


\item[例題:] \mbox{} 
  以下の{\tt ResetStack}操作は変数を持たず、戻り値がない。一方、{\tt PopStack}操作はトップのスタック要素を返す。
  \begin{alltt}
    ResetStack();
    ...
    top := PopStack();
  \end{alltt}
  この{\tt PopStack}は以下のように定義することが出来る:
  \begin{alltt}
    PopStack: () ==> Elem
    PopStack() ==
      def res = hd stack in
       (stack := tl stack;
        return res)
    pre stack <> []
    post stack~ = [RESULT] ^ stack
  \end{alltt}
  この{\tt stack}はグローバル変数である。

\end{description}

\subsection{return文}

\begin{description}
\item[構文:]
  \Rule{文}{
    \ldots \dsep
    \Ruleref{return文} \dsep \ldots
    }

  \Rule{return文}{
    \Lop{return}, \OptPt{\Ruleref{式}}
    }

\item[意味定義:]  {\it return文} は操作内の式の値を戻す。
値は与えられた文脈中で評価される。
もし操作が値を返さないならば、式は省かれなければならない。
 {\it return文\/}は次の形式をもつ:
  \begin{alltt}
    return e
  \end{alltt}
または
  \begin{alltt}
    return
  \end{alltt}
 ここで式{\tt e} は操作の戻り値である。

\item[例題:]  {\tt FunCall} が関数呼出しであるの対し、以下に述べる例題 {\tt OpCall} は操作呼出しである。
 {\it if文\/}が2つに枝分かれした文だけを受け入れるため、 {\tt FunCall}は  {\it return文}を用いることで文に``変換されて''いる。
  \begin{alltt}
    \keyw{if} test
    \Keyw{then} OpCall()
    \Keyw{else} \keyw{return} FunCall()
  \end{alltt}

\end{description}

\subsection{例外処理文}

\begin{description}
\item[構文:]
  \Rule{文}{
    \ldots \dsep
    \Ruleref{always文} \dsep
    \Ruleref{trap文} \dsep
    \Ruleref{再帰trap文} \dsep
    \Ruleref{exit文} \dsep \ldots
    }

  \Rule{always文}{
    \Lop{always}, \Ruleref{文}, \Lop{in}, \Ruleref{文}
    }

  \Rule{trap文}{
    \Lop{trap}, \Ruleref{パターン束縛}, \Lop{with},
    \Ruleref{文}, \Lop{in}, \lfeed
    \Ruleref{文}
    }

  \Rule{再帰trap文}{
    \Lop{tixe}, \Ruleref{trap群}, \Lop{in}, \Ruleref{文}
    }

  \Rule{trap群}{
    \Lit{\{}, \Ruleref{パターン束縛}, \Lit{|->}, \Ruleref{文}, \lfeed
    \SeqPt{ \Lit{,}, \Ruleref{パターン束縛}, \Lit{|->}, \Ruleref{文} },
    \Lit{\}}
    }

  \Rule{exit文}{
    \Lop{exit}, \OptPt{\Ruleref{式}}
    }

\item[意味定義:] 例外処理文は、仕様記述のなかで例外エラーを制御するために用いられる。
このことは、仕様記述内で例外信号を送ることができなければならないことを意味する。これは {\it exit文}を用いて行うことができ、次の形式をもつ:
  \begin{alltt}
    \keyw{exit} e
  \end{alltt}
または
  \begin{alltt}
    \keyw{exit}
  \end{alltt}
 ここにおいて{\tt e} はオプションの式である。
式 {\tt e}はどのような種類の例外が起きたのかを知らせるために用いられる。

  {\it always文\/} は次の形式をもつ:
  \begin{alltt}
    \keyw{always} s1 \keyw{in}
    s2
  \end{alltt}
ここで {\tt s1} と {\tt s2} は文である。
最初に文 {\tt s2} が評価され、さらに例外が起きたかどうかにかかわらず文 {\tt s1} も評価される。
 {\it always文\/}全体の結果値は、文 {\tt s1}の評価により決定される: もしここで例外を起こせばこの値が戻される、それ以外は文 {\tt s2} の評価の結果が返される。

 {\it trap文\/} は、ある一定の条件が満たされたときに、処理文{\tt s1}を評価する唯一のものである。
これは次の形式をもつ:
\begin{alltt} 
    \keyw{trap} pat \keyw{with} s1 \keyw{in} s2 
\end{alltt}
ここで {\tt pat} はある一定の例外を選択するために用いられるパターンまたは束縛であり、 {\tt s1} と {\tt s2} は文である。
最初に文 {\tt s2}を評価するが、もし例外が発生しなければ{\tt s2}の評価結果が、 {\it trap文\/}全体の結果値となる。
例外が起きた場合には、 {\tt s2} の値はパターン {\tt pat}と一致するか調べる。
そこで一致するものがない場合、例外が{\it trap文}全体の結果値として戻され、そうでない場合は文 {\tt s1}が評価され、この評価の結果がまた {\it trap文}全体の結果値となる。

  {\it 再帰trap文\/} は次の形式をもつ:
  \begin{alltt}
    \keyw{tixe} \{
      pat1 |-> s1,
      ...
      patn |-> sn
    \} \keyw{in} s
  \end{alltt}
ここで {\tt pat1, \ldots, patn} はパターンまたは束縛であり、{\tt s, s1, \ldots,
    sn} は文である。 
最初に文 {\tt s} が評価され、もし例外が起きなければ、その結果が完全な {\it 再帰trap文}の結果として戻される。
そうでない場合、値はパターン {\tt pati}の各々に順に一致させられる。 
一致するものが見つからなかった場合、 {\it 再帰trap文}の結果として例外が戻される。
一致するものが見つかれば、対応する文 {\tt    si} が評価される。
これが例外を起こさない場合には、 {\tt si} の評価の結果値は {\it 再帰trap文}の結果として戻される。
それ以外の場合は、今度は新しい例外値( {\tt si}の評価の結果)をもとに、マッチングを再び始める。

\item[例題:] 多くのプログラムにおいて、1つの操作にはメモリーを割り当てる必要がある。
操作が完了した後には、このメモリーはそれ以上必要でなくなる。
このことは {\it always文}と共に実行される:
  \begin{alltt}
    ( \keyw{dcl} mem : Memory;
      \keyw{always} Free(mem) \keyw{in}
      ( mem := Allocate();
        Command(mem, \ldots)
      )
    )
  \end{alltt}
上記の例では、 {\it always文}の本体文中で起きる可能性のある例外上では、何かを行うことはできない。
 {\it trap文\/} を用いることで、これらの例外を捉えることができる:
  \begin{alltt}
    \keyw{trap} pat \keyw{with} ErrorAction(pat) \keyw{in}
    ( \keyw{dcl} mem : Memory;
      \keyw{always} Free(mem) \keyw{in}
      ( mem := Allocate();
        Command(mem, \ldots)
      )
    )
  \end{alltt}
 ここに{\it always文\/} 中で起きるすべての例外は、 {\it trap文}によって捉えられる。
数個の例外値を区別したい場合には、ネストされた {\it trap文\/} かまたは{\it 再帰trap文}を用いることができる:
  \begin{alltt}
    DoCommand : () ==> int
    DoCommand () ==
    ( \keyw{dcl} mem : Memory;
      \keyw{always} Free(mem) \keyw{in}
      ( mem := Allocate();
        Command(mem, \ldots)
      )
    );

    Example : () ==> int
    Example () ==
    \keyw{tixe}
    \{ <NOMEM> |-> \keyw{return} -1,
      <BUSY>  |-> DoCommand(),
      err     |-> \keyw{return} -2 \}
    \keyw{in}
      DoCommand()
  \end{alltt}
操作{\tt DoCommand}では、メモリー割り当て中に {\it always文\/}を用いるし、また操作{\tt Example}では、起きた例外はすべて {\it   再帰trap文\/} によって捉えられる。
値 {\tt <NOMEM>} をもつ例外は、結果として {\tt -1} の戻り値となり例外は起きない。
例外値が {\tt <BUSY>} であるならば、再び操作{\tt DoCommand}の実行を試みる。
これが例外を起こす場合には、 {\it 再帰trap文}によってまた処理が行われる。
他の例外はすべて、値 {\tt -2}を戻す結果となる。
\end{description}

\subsection{error文}

\begin{description}
\item[構文:]
  \Rule{文}{
    \ldots \dsep
    \Ruleref{error文} \dsep
    \ldots
    }

  \Rule{error文}{
    \Lop{error}
    }

\item[意味定義:]  {\it error文} は定義されていない式に相等する。
文の結果は定義されないしこのことによりエラーが起きる、ということを明示的に述べるために用いられる。
{\it error文} が評価されるときは、インタープリタは仕様記述の実行を停止し {\it error文} が評価されたことを報告する。

エラー文の実用的な使用となると、未定義式を用いた場合なので、事前条件の場合とは異なる:  事前条件の使用とは、操作が呼ばれたときは事前条件が満たされていると保証することは呼ぶ側の責任であることを意味する；error文の使用では、エラー処理を取り扱うのは呼ばれた操作側の責任である。


\item[例題:] \pageref{squarerootDef} ページ上の操作 \texttt{SquareRoot} は、平方する数は負かもしれないという可能性を排除するものでない。
これについては操作 \texttt{SquareRootErr}で修正を行う:
  \begin{alltt}
  SquareRootErr : \keyw{real} * \keyw{real} ==> \keyw{real}
  SquareRootErr (r,e) ==
    \keyw{if} r < 0
    \keyw{then error}
    \keyw{else}
      (\keyw{dcl} x:\keyw{real} := 1;
       \keyw{dcl} nextx\keyw:{real} := r;
       \keyw{while abs} (x - nextx) >= e * x \keyw{do}
         ( x := nextx;
           nextx := ((r / x) + x) / 2;
         );
       \keyw{return} nextx
      )
  \end{alltt}
\end{description}

\subsection{恒等文}

\begin{description}
\item[構文:]
  \Rule{文}{
    \ldots \dsep
    \Ruleref{恒等文}
    }

  \Rule{恒等文}{
    \Lop{skip}
    }

\item[意味定義:]  {\it 恒等文\/} は何の評価も行われないという信号を送るために用いられる、

\item[例題:] 第\ref{removeDef}節の操作\texttt{Remove} において、\texttt{elem=z} が明示的に述べられていない場合の \textsf{for} ループ内における操作の動き。
以下の{Remove2} がこれを示す。
  \begin{alltt}
  Remove2 : (\keyw{seq of nat}) * \keyw{nat} ==> \keyw{seq of nat}
  Remove2 (k,z) ==
    (\keyw{dcl} nk : \keyw{seq of nat} := [];
     \keyw{for} elem \keyw{in} k \keyw{do}
       \keyw{if} elem <> z \keyw{then} nk := nk^[elem]
       \keyw{else skip};
     \keyw{return} nk
    );
  \end{alltt}
ここで {\it 恒等文}を説明するために \keyw{else}選択枝 を明示的に含めたが、ほとんどの場合\keyw{else}選択枝は含まれないため {\it 恒等文\/} は暗黙に仮定されているのである。

\end{description}


\subsection{仕様記述文} \label{se:specification}

\begin{description}
\item[構文:] 
  \Rule{文}{
    \ldots \dsep
    \Ruleref{仕様記述文}
    }
  \Rule{仕様記述文}{
    \Lit{[}, \Ruleref{陰操作本体}, \Lit{]}
  }

\item[意味定義:] 

仕様記述文は、事前条件や事後条件で表した文で期待効果を記述するために用いることができる。
このように、操作定義に強要されることなく抽象的(暗黙の)仕様記述を許すことで、1つの文の概略を捉える。
仕様記述文は、暗黙に定義された陰操作 (第~\ref{op-def}節参照)の本体と同等である。したがって、仕様記述文を実行することはできない。

\item[例題:]  仕様記述文をバブルソートのバブル最大部を指定するために用いることができる:
  \begin{alltt}
  Sort2 : () ==> ()
  Sort2 () ==
    \keyw{while} x < y \keyw{do}
      || (BubbleMin(),
          [\keyw{ext wr} l : \keyw{seq1 of nat}
              \keyw{wr} y : \keyw{nat}
              \keyw{rd} x : \keyw{nat}
           \keyw{pre} x < y
           \keyw{post} y < y~ \keyw{and}
                permutation (l~(x,...,y~),l(x,...,y~)) \keyw{and}
                \keyw{forall} i \keyw{in set} \{x,...,y\} & l(i) < l(y~)]
         )
  \end{alltt}
 (\texttt{permutation} は、もし1つの列が他方の並び替えであるならば真を返すような、2つの列から結果をとる補助関数である。)


\end{description}


\newpage
\section{トップレベル仕様記述}
\label{top-level}\label{modules}

前節で、型・式・文・関数、そして操作、という全てのVDM-SLの構成要
素を述べてきた。
これらのたくさんの構成要素は、トップレベルのVDM-SL仕様記述の構成要素となることができる。
トップレベル仕様記述は2つの方法により作り出される:
\begin{enumerate}
\item 仕様記述は、別々に指定される多くのモジュールに分けられるが、互いに依存することができる。
\item 仕様記述はフラットな方法で記述される。 すなわち、どのモジュールも使用されていない。
\end{enumerate}
したがって、完全な仕様記述、または文書には、以下の構文がある。

\begin{description}
\item[構文:]
\Rule{文書}{
  \Ruleref{任意のモジュール}, \SeqPt{\Ruleref{任意のモジュール}} \dsep
   \Ruleref{定義ブロック}, \SeqPt{\Ruleref{定義ブロック}}
  }

\Rule{任意のモジュール}{
  \Ruleref{モジュール} \dsep
  \Ruleref{動的リンクモジュール}
  }
\end{description}

\subsection{フラット仕様記述}\label{flat}

前に述べたように、フラット仕様記述はモジュールを使用しない。
これは、すべての構成要素が仕様記述中で使用することができることを意味する。 
フラットな場合では、文書は以下の構文を持っている:

\Rule{文書}{\ldots \dsep
  \Ruleref{定義ブロック}, \SeqPt{\Ruleref{定義ブロック}}
  }

\Rule{定義ブロック}{
  \Ruleref{型定義群} \dsep
  \Ruleref{状態定義} \dsep
  \Ruleref{値定義群} \dsep
  \Ruleref{関数定義群} \dsep
  \Ruleref{操作定義群}
  }

したがって、フラットな仕様記述はいくつかの定義ブロックで作られる。しかしなが
ら、1つの状態定義のみ許されている。
以下はフラットトップレベル仕様記述に関する例である:

\begin{alltt}
  \keyw{values}

    st1 = \keyw{mk\_}St([3,2,-9,11,5,3])

  \keyw{state} St \keyw{of}
    l:\keyw{seq1 of nat}
  \keyw{end}

  \keyw{functions}

  min_index : \keyw{seq1 of nat} -> \keyw{nat}
  min_index(l) ==
    \keyw{if} \keyw{len} l = 1
    \keyw{then} 1
    \keyw{else} \keyw{let} mi = min_index(\keyw{tl} l)
        \keyw{in} \keyw{if} l(mi+1) < \keyw{hd} l
          \keyw{then} mi+1
          \keyw{else} 1

  \keyw{operations}

  SelectionSort : \keyw{nat} ==> ()
  SelectionSort (i) ==
    if i < len l
    then (\keyw{dcl} temp: \keyw{nat};
          \keyw{dcl} mi : \keyw{nat} := min_index(l(i,...,\keyw{len} l)) + i - 1;
         
          temp := l(mi);
          l(mi) := l(i);
          l(i) := temp;
          SelectionSort(i+1)
         )
\end{alltt}






\subsection{構造仕様記述}

標準のVDM-SL言語への拡張として、モジュールを使用しているVDM-SL仕様記述を構造化することは可能である。
この節で、トップレベル仕様記述を作成するためのモジュール使用方法を説明する。
VDM-SLで提供されている構造化機能で以下が可能になる:
\begin{itemize}
\item モジュールから構成要素を輸出する
\item モジュールから構成要素を輸入する
\item 輸入時に構成要素名を変更する
\item モジュールの状態を定義する
\end{itemize}

これらの普通のモジュールに加えて、いわゆる「ダイナミックリンクモジュール」 (第~\ref{sec:DLmodules}節参照)
を使用することが可能である

\subsubsection{モジュールのレイアウト}
実際の機能を説明する前に、一般的なモジュールのレイアウトを説明する。モ
ジュールは3 つの要素から成る: モジュール宣言、インタフェース節、および
定義節である。モジュール仕様記述の初期段階で定義部分を省略することは可能である。

モジュール宣言の中で、モジュールには名前が付けられる。その名前は完全な仕様
記述の中では一意なモジュール名でなければならない。2つ目(インタフェー
ス節) は、他のモジュールのモジュール関係を定義し、多くの節から成る。
これらの節は以下の通りである:

\begin{itemize}
\item {\it 輸入節} 輸入節では、他のモジュールから使用されるすべての構成要
素が述べられる。もしも、構成要素の名前を変更するなら、輸入節で行う。

\item {\it 輸出節} ここで、他のモジュールで使用されるすべての構成要素が定義
される。1つも輸出節が存在していないなら、そのモジュールは他のモジュールから使用することができない。

\end{itemize}
モジュール宣言の3つ目(定義節)には全てのモジュール定義を含む。したがって、
一般にはモジュールの構文は以下の通りである:

\begin{description}
\item[構文:]
\Rule{モジュール}{
  \Lop{module}, \Ruleref{識別子}, \Ruleref{インタフェース}, \lfeed
  \OptPt{\Ruleref{モジュール本体}}, \Lop{end}, \Ruleref{識別子}
  }

  \Rule{モジュール本体}{
    \Lop{definitions}, \Ruleref{定義ブロック}, \SeqPt{定義ブロック}
  }
\end{description}

モジュールの使用を解説するために、フラットトップレベル仕様記述の例はやや手直しして記述する。
フラット仕様記述の重要でない部分は分かりやすくするため省略する。

\subsubsection{輸出節}

\begin{description}
\item[構文:]
  \Rule{インタフェース}{
    \OptPt{\Ruleref{輸入定義リスト}}, \lfeed
    \Ruleref{輸出定義}
    }

  \Rule{輸出定義}{
    \Lop{exports}, \Ruleref{輸出モジュールシグネチャ}
    }

  \Rule{輸出モジュールシグネチャ}{
    \Lop{all} \dsep
    \Ruleref{輸出シグネチャ}, \lfeed
    \SeqPt{\Ruleref{輸出シグネチャ}}
    }
  
  \Rule{輸出シグネチャ}{
    \Ruleref{輸出型シグネチャ} \dsep
    \Ruleref{値群シグネチャ} \dsep
    \Ruleref{輸出関数シグネチャ} \dsep
    \Ruleref{操作群シグネチャ}
%    \dsep
%    state signature
    }
  
  \Rule{輸出型シグネチャ}{
    \Lop{types}, \Ruleref{型輸出}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{型輸出}}, \OptPt{\Lit{;}}
    }
  
  \Rule{型輸出}{
    \OptPt{\Lop{struct}}, \Ruleref{名称}
    }
  
  \Rule{値群シグネチャ}{
    \Lop{values}, \Ruleref{値シグネチャ}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{値シグネチャ}}, \OptPt{\Lit{;}}
    }
  
  \Rule{値シグネチャ}{
    \Ruleref{名称リスト}, \Lit{:}, \Ruleref{型}
    }
  
  \Rule{輸出関数シグネチャ}{
    \Lop{functions} \Ruleref{関数輸出}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{関数輸出}}, \OptPt{\Lit{;}}
    }

  \Rule{関数輸出}{
    \Ruleref{名称リスト}, \OptPt{\Ruleref{型変数リスト}}, \Lit{:}, \lfeed
    \Ruleref{関数型}
    }
  
  \Rule{関数群シグネチャ}{
    \Lop{functions} \Ruleref{関数シグネチャ}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{関数シグネチャ}}, \OptPt{\Lit{;}}
    }
  
  \Rule{関数シグネチャ}{
    \Ruleref{名称リスト}, \Lit{:}, \Ruleref{関数型}
    }
  
  \Rule{操作群シグネチャ}{
    \Lop{operations} \Ruleref{操作シグネチャ}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{操作シグネチャ}}, \OptPt{\Lit{;}}
    }
  
  \Rule{操作シグネチャ}{
    \Ruleref{名称リスト}, \Lit{:}, \Ruleref{関数型}
    }
  
%  \Rule{状態シグネチャ}{
%    \Lop{状態}, 名称, \SeqPt{\Lit{,}, 名称}
%    }

\item[意味定義:] 輸出節は構成要素を他のモジュールから見えるよう公開するために使用する。
モジュールで定義された構成要素のいくつか、またはすべてを輸出することが出来る。 
後者の場合では、キーワード\keyw{all}が使用される。しかしながら、
輸入された構成要素はモジュールから輸出されない。構成要素の一部だけを輸出するなら、
対応する適切なシグネチャの構造が公開される。

  通常、構成要素が他のモジュールから見えるなら、その構造は、モジュール内で定義されていると見ることができる。
 しかしながら、型と操作にはいくつかの例外がある:

  \begin{description}
  \item[型:] 型{\tt T}がモジュール{\tt A}で定義され、この型がモジュール{\tt B}で使用されるなら、モジュール{\tt A}からの型は輸出しなければならない
    これは、以下の2つの方法でできる:
    \begin{enumerate}
    \item その型の名前は輸出される
    \item その型の構造は輸出される
    \end{enumerate}
    型の名前だけを輸出するなら、もう一方のモジュールは型{\tt T}の値を作成することができない。
	これは、輸出しているモジュール({\tt A})は{\tt T}の表現に関する構成要素を用いて型{\tt T}の値を直接生成し
	操作するために関数と(または)操作を与えなければならない。

	私たちが\keyw{struct}というキーワードを使用することによって型の構造を輸出するなら、もう片方のモジュールは
	型{\tt T}の値(もしもレコード型であるなら、この型に対して\keyw{mk\_}キーワードと\keyw{is\_}キーワードも使用できる)を生成し操作することができる。

    型が不変条件も定義する場合、型の構造を輸出する場合にだけ、不変な述語関数を輸出する。

  \item[操作:] モジュール内では、モジュールにとってグローバルな状態は定義することができる。 
  モジュール内のすべての操作がその状態を操作することができる。モジュールから操作を輸出するなら、
  輸出しているモジュール(すなわち、それらが定義されるモジュールによる状態)で状態を操る。
  \end{description}

 輸出された関数、または操作が事前条件と(または)事後条件を定義するなら、
 対応する述語関数(第~\ref{functiondef}節参照)も輸出する。


\item[例:] 銀行口座のモデルを考える。口座は所有者の名前、口座番号、銀行のキャッシュカードで残高、
暗証番号を管理している口座の銀行支店によって特徴付けられている。
以下のようにこれをモデル化する:
\begin{alltt}
\keyw{module} BankAccount

  \keyw{exports} \keyw{types} digit; account
          \keyw{functions} digval: digit -> \keyw{nat};
                  withdrawal: account * \keyw{real} -> account;
                  isPin: account * \keyw{nat} -> \keyw{bool};
                  requestWithdrawal: account * \keyw{nat} -> \keyw{bool}
  \keyw{definitions}

  \keyw{types}

  digit = \keyw{nat}
  \keyw{inv} d == d < 10;
  
  account::  holder : \keyw{seq1 of char}
             number : \keyw{seq1 of digit}
             branchcode : \keyw{seq1 of digit}
             balance: \keyw{real}
             epin: \keyw{nat}
  \keyw{inv mk\_}account(holder, number, branchcode,-,-) ==
    \keyw{len} number = 8 and \keyw{len} branchcode = 6

  \keyw{functions}

    digval : digit -> \keyw{nat}
    digval(d) == d;

    deposit: account * \keyw{real} -> account
    deposit(acc,r) == 
      \keyw{mu}(acc,balance |-> acc.balance + r);

    withdrawal : account * \keyw{real} -> account
    withdrawal (acc,r) == 
      \keyw{mu}(acc,balance |-> acc.balance - r);

    isPin : account * \keyw{nat} -> \keyw{bool}
    isPin(acc,ep) ==
      ep = acc.epin;

    requestWithdrawal : account * \keyw{nat} -> \keyw{bool}
    requestWithdrawal (acc,amt) ==
      acc.balance > amt

\keyw{end} BankAccount
\end{alltt}
このモジュール内で、2つの型と5つの関数を輸出する。
エンティティを列挙してから、輸出していることに注意する。
しかし、\keyw{struct}というキーワードで使用されている\texttt{digit}や \texttt{account}は輸出されていない。
つまり、 \texttt{account}値の内部は他のモジュールによってアクセスされないかもしれない。
また、\texttt{digit}の不変条件もアクセスされないかもしれない。
このようなアクセスが必要であるならば、その型は\keyw{struct}というキーワードで輸出されるべきであり、
また、モジュール内の全ての構成要素は\keyw{exports all}節を使用して輸出されるべきである。

以下に与えられたモジュール \texttt{keypad}はATMのキーパッドインタフェースをモデル化する。 
その状態変数はユーザーによってキーパッドにタイプされたデータのバッファを維持する。


\begin{alltt}
\keyw{module} Keypad

  \keyw{imports}
    \keyw{from} BankAccount \keyw{types} digit

  \keyw{exports all}

  \keyw{definitions}

  \keyw{state} buffer \keyw{of}
    data : \keyw{seq of} BankAccount`digit
  \keyw{end}

  \keyw{operations}

    DataAvailable : () ==> \keyw{bool}
    DataAvailable () ==
      \keyw{return}(data <> []);

    ReadData : () ==> \keyw{seq of} BankAccount`digit
    ReadData () ==
      \keyw{return}(data);

    WriteData : \keyw{seq of} BankAccount`digit ==> ()
    WriteData (d) ==
      data := data^d

\keyw{end} Keypad
\end{alltt}
このモジュールで、すべての構成要素を輸出する。定義された唯一のエンティティが、状態と操作であるので、
これは、操作のすべてが輸入しているモジュールでアクセスされるかもしれないこと意味する。
その状態は、輸入しているモジュールを利用しやすくないが、このモジュールはprivateのままである。
しかしながら、状態のコンストラクタである\texttt{\keyw{mk\_}Keypad`buffer}はアクセスできる。

\end{description}

\subsubsection{輸入節}

\begin{description}
\item[構文:]
  \Rule{インタフェース}{
    \OptPt{\Ruleref{輸入定義リスト}}, \lfeed
    \Ruleref{輸出定義}
    }

  \Rule{輸入定義リスト}{
    \Lop{Import}, \Ruleref{輸入定義}, \lfeed
    \SeqPt{\Lit{,}, \Ruleref{輸入定義}}
    }

  \Rule{輸入定義}{
    \Lop{from}, \Ruleref{識別子}, \Ruleref{輸入モジュールシグネチャ}
    }

  \Rule{輸入モジュールシグネチャ}{
    \Lop{all} \dsep
    \Ruleref{輸入シグネチャ}, \lfeed
    \SeqPt{\Ruleref{輸入シグネチャ}}
    }

  \Rule{輸入シグネチャ}{
    \Ruleref{輸入型シグネチャ} \dsep
    \Ruleref{輸入値シグネチャ} \dsep
    \Ruleref{輸入関数シグネチャ} \dsep
    \Ruleref{輸入操作シグネチャ}
%    \dsep
%    state signature
    }

  \Rule{輸入型シグネチャ}{
    \Lop{types}, \Ruleref{型輸入}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{型輸入}}, \OptPt{\Lit{;}}
    }

  \Rule{型輸入}{
    \Ruleref{名称}, \OptPt{\Lop{renamed}, \Ruleref{名称}} \dsep
    \Ruleref{型輸入}, \OptPt{\Lop{renamed}, \Ruleref{名称}}
    }

  \Rule{輸入値シグネチャ}{
    \Lop{values}, \Ruleref{値輸入}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{値輸入}}, \OptPt{\Lit{;}}
    }

  \Rule{値輸入}{
    \Ruleref{名称}, \OptPt{\Lit{:}, \Ruleref{型}}, \OptPt{\Lop{renamed}, \Ruleref{名称}}
    }

  \Rule{輸入関数シグネチャ}{
    \Lop{functions}, \Ruleref{関数輸入}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{関数輸入}}, \OptPt{\Lit{;}}
    }

  \Rule{関数輸入}{
    \Ruleref{名称}, \OptPt{\OptPt{\Ruleref{型変数リスト}},  \lfeed
    \Lit{:}, \Ruleref{関数型}},
    \OptPt{\Lop{renamed}, \Ruleref{名称}}
    }

  \Rule{輸入操作シグネチャ}{
    \Lop{operations}, \Ruleref{操作輸入}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{操作輸入}}, \OptPt{\Lit{;}}
    }

  \Rule{操作輸入}{
    \Ruleref{名称}, \OptPt{\Lit{:}, \Ruleref{操作型}}, \lfeed
    \OptPt{\Lop{renamed}, \Ruleref{名称}}
    }

\item[意味定義:] 輸入節はどの構成要素が目に見える構成要素のみ輸入することが出来るという制限を
  持った他のモジュールから使われるのかを述べるために使われる。
  モジュールからの全ての目に見える構成要素が利用されるならば、キーワードの\keyw{all}が使われる。
  但し、1つ以上の構成要素がrenameされない場合は除く。
  rename時には、輸入された構成要素は輸出しているモジュール名だけ先行した
  元の名前の代わりに利用することができる新しい名前が与えられる。
  一般に、これは形式がある:
  \begin{alltt}
    name \keyw{renamed} new_name
  \end{alltt}
  上記の{\tt name} は輸入された構成要素の名前であり、また、{\tt new\_name}は構成要素の新しい名前である。
  このように、より意味のある名前が構成要素に与えられる。
  輸入しているモジュール内では、これ以上{\tt DefModule`name}({\tt DefModule}は定義モジュールの名前である)を言及することは不可能である。
  しかし、{\tt newname}は可能である。

  輸入節では、型情報を含むことが可能である。
  この情報は、完全なモジュールの静的意味定義チェックによってのみ使用される。
  型情報が与えられなかったら、静的意味定義も輸出しているモジュール内のこの情報を見つけることができる。
  (第~\ref{static}節参照)
  
  型の輸入内で輸出しているモジュールから型定義が繰り返されるならば、
  \keyw{struct}キーワードで輸出している型が輸入される時には、この構成要素を使用するかもしれない。
  このような型の場合は、合成型であり、renameもされる。これは、さらにタグがrenameされる因果関係を持つ。
  
\item[例:] 私たちはカード番号と有効期限日から成り立つ銀行のキャッシュカードをモデル化すること
ができる。 これは\texttt{BankAccount}というモジュールで定義された \texttt{digit}型が必要である。
また、それは同じモジュールから\texttt{digval}という関数を使用する。
\begin{alltt}
\keyw{module} ATMCard

  \keyw{imports}
    \keyw{from} BankAccount \keyw{types} digit 
                     \keyw{functions} digval \keyw{renamed} atmc_digval

  \keyw{exports all}

  \keyw{definitions}

  \keyw{types}

    digit = BankAccount`digit;

    atmc:: cardnumber : \keyw{seq1 of} digit
           expiry : digit * digit * digit * digit
    \keyw{inv mk\_}atmc(cardnumber, \keyw{mk\_}(m1,m2,-,-)) ==
        atmc_digval(m1) * 10 + atmc_digval(m2) <= 12 \keyw{and}
        \keyw{len} cardnumber >= 8

  \keyw{functions}

    getCardnumber : atmc -> \keyw{seq1 of} digit
    getCardnumber (atmc) ==
      atmc.cardnumber

\keyw{end} ATMCard
\end{alltt}
ここでは、\texttt{atmc}型上の不変条件は、有効期限が有効日を表さなければならない。
また、カードナンバーは少なくとも8桁以上でなければならないということである。 
\texttt{degit}が\texttt{BankAccount}モジュールからstructキーワードが輸出されていないので、
\texttt{ATMCard}モジュール内の\texttt{digit}に対する不変条件にアクセスできない。
しかしながら、これにもかかわらず、\texttt{ATMCard}内で操作された\texttt{digit}型のすべての値が不変条件を満たさなければならない。

\end{description}


\section{動的リンクモジュール}\label{sec:DLmodules}

動的リンクモジュールはVDM-SLで完全に仕様を定められたモジュールとC++のコードとしてのみ利用可能なシステム全体
の一部分との間のインタフェースを記述するために使用された。
仕様記述がインタープリタ、またはデバッグしている間、この機能は存在しているC++ライブラリをユーザが使用することを
可能にする。この機能の使用法は\cite{DLMan-SCSK}で詳細に説明する。
動的リンクモジュールの一般的なレイアウトは普通のVDM-SLモジュールと似ている。
それは3つの部分から成る:それは\emph{モジュール宣言}、\emph{インタフェース節}、\emph{任意のライブラリ参照}である。

\begin{description}
\item[構文:]

動的リンクモジュールのモジュール宣言は、単にモジュール名の後のキーワード、\keyw{dlmodule}である。
動的リンクモジュールのインタフェース節は普通のモジュールのインタフェース節より単純である。
動的リンクモジュールに輸入することができる唯一の構成要素の種類は型である。
このように輸入された型は、モジュールから輸出された値、関数や操作のシグネチャとして使用することが出来る。
最終的にライブラリ参照(\Lop{uselib} キーワードで特定される)は、このようなインタープリタが行われるライブラリからコードを利用する仕様記述の場合、
インタープリタによって使われなければならない動的リンクC++ライブラリを特定するのに使われる。

動的リンクモジュールの構文は以下の通りである:
 
\Rule{動的リンクモジュール}{
  \Lop{dlmodule}, \Ruleref{識別子}, \lfeed
  \Ruleref{動的リンクインタフェース},\lfeed
  \OptPt{\Ruleref{useシグネチャ}},\lfeed
  \Lop{end}, \Ruleref{識別子}
  }

\Rule{動的リンクインタフェース}{
  \OptPt{\Ruleref{動的リンク輸入定義リスト}}, \lfeed
  \Ruleref{動的リンク輸出定義}
  }

\Rule{useシグネチャ}{
   \Lop{uselib}, \Ruleref{テキストリテラル}
   }

\Rule{動的リンク輸入定義リスト}{
  \Lop{imports}, \lfeed
  \Ruleref{動的リンク輸入定義}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{動的リンク輸入定義}}
  }

\Rule{動的リンク輸入定義}{
  \Lop{from}, \Ruleref{識別子}, \lfeed
  \Ruleref{動的リンク輸入型シグネチャ群}
  }

\Rule{動的リンク輸入型シグネチャ群}{
  \Lop{types}, \Ruleref{名称}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{名称}}, \OptPt{\Lit{;}}
  }
  
\Rule{動的リンク輸出定義}{
  \Lop{exports}, \lfeed
  \Ruleref{動的リンク輸出シグネチャ}, \lfeed
  \SeqPt{\Ruleref{動的リンク輸出シグネチャ}}
  }

\Rule{動的リンク輸出シグネチャ}{
  \Ruleref{値群シグネチャ} \dsep
  \Ruleref{関数群シグネチャ} \dsep
  \Ruleref{操作群シグネチャ}
  }
  
\item[意味定義:] インタフェース構成要素の意味定義は、普通のモジュールに対する意味定義と同じである。
     useシグネチャの意味定義は動的リンクC++ライブラリを作成するために使われたC++コンパイラによって与えられた。
	 したがって、useシグネチャの中を参照するC++のコードはVDM-SL水準において、直接意味定義を供給しない。

\item[例:] ここで紹介されている例は、\cite{DLMan-SCSK}で利用されている。
最初のモジュールは、{\tt MATH}モジュールと{\tt CYLIO}モジュールからの構成要素を輸入する。 
これら他のモジュールの両方がその後提示され、それらの両方が動的リンクモジュールである。
\begin{alltt}
\keyw{module} CYLINDER
  \keyw{imports}
    \keyw{from} MATH
        \keyw{functions}
          ExtSin : \keyw{real} -> \keyw{real}
        \keyw{values} 
          ExtPI : \keyw{real},

    \keyw{from} CYLIO
        \keyw{functions}
          ExtGetCylinder : () -> CircCyl
   
        \keyw{operations}
          ExtShowCircCylVol : CircCyl * \keyw{real} ==> ()

   \keyw{exports}
     \keyw{types}  
         CircCyl  

  \keyw{definitions}
    \keyw{types}
        CircCyl :: rad    : \keyw{real}
                   height : \keyw{real}
                   slope  : \keyw{real}
	
    \keyw{functions}
        CircCylVol : CircCyl -> \keyw{real}
        CircCylVol(cyl) ==
          MATH`ExtPI * cyl.rad * cyl.rad * cyl.height * 
          MATH`ExtSin(cyl.slope)

    \keyw{operations}
        CircCyl : () ==> ()
        CircCyl() == ( \keyw{let} cyl = CYLIO`ExtGetCylinder() \keyw{in} 
                         \keyw{let} vol = CircCylVol(cyl) \keyw{in}
                            CYLIO`ExtShowCircCylVol(cyl, vol))
\keyw{end} CYLINDER
\end{alltt}

The {\tt MATH} モジュールは次のように定義される:

\begin{alltt}
\keyw{dlmodule} MATH
  \keyw{exports}
    \keyw{functions}
      ExtCos : \keyw{real} -> \keyw{real};
      ExtSin : \keyw{real} -> \keyw{real}  
      
   \keyw{values}   
      ExtPI : \keyw{real}
  
   \keyw{uselib}
      "libmath.so" 

\keyw{end} MATH
\end{alltt}

The {\tt CYLIO} module is defined as:

\begin{alltt}
\keyw{dlmodule} CYLIO
  \keyw{imports}
    \keyw{from} CYLINDER
      \keyw{types}
        CircCyl

   \keyw{exports}
     \keyw{functions}
       ExtGetCylinder : () -> CircCyl
   
     \keyw{operations}
       ExtShowCircCylVol : CircCyl * \keyw{real} ==> ()
  88 

   \keyw{uselib}
      "libcylio.so"

\keyw{end} CYLIO
\end{alltt}

VDM-SLインタープリタでこのようなモジュールを使用する方法は\cite{DLMan-SCSK}中に述べられる。
\end{description}

%\section{Differences between IFAD VDM-SL
%         and\\      ISO/VDM-SL}\label{diff}
\section{VDM-SLと ISO /VDM-SL の相違点}\label{diff}

  \vdmslpp{\vdmsl}{\vdmpp} のこの版は ISO/VDM-SL 標準を基本とするが、少しだけ異なる点がある。
これらの相違は構文上および意味定義上の両面にあり、主に言語の拡張に起因するもので\vdmslpp{\vdmsl}{\vdmpp}構成要素を実行可能なものにしようとする要求に原因がある\footnote{ここでの意味定義とはインタープリタの意味定義のことである。}。

%The major difference between IFAD {\vdmsl} and
%ISO/VDM-SL is the availability of a structuring in IFAD VDM-SL. This
%causes some syntactical differences.
{\vdmsl}とISO/VDM-SLの主要な違いはVDM-SLの構造化の利用である。これは構文の違いが原因である。

%For the flat part of IFAD VDM-SL, the following differences with ISO/VDM-SL exist:
VDM-SLのフラット部分に対して、ISO/VDM-SLは以下の違いが存在している:


\begin{description}
\item[構文上の相違:]\mbox{}\\
  \begin{itemize}
  
  \item 標準では部分列構成要素間 (たとえば関数定義間) の分離符としてセミコロン (``;'') が使われる。
  \vdmslpp{\vdmsl}{\vdmpp} ではこの規則に、このような構成要素の列の最後尾に随意でセミコロンをつけることができることを付け加える。
この変更は以下に述べる構文上の定義に対しても適用される (付録 \ref{app-a}を参照)
: \vdmslpp{{\em 状態定義},}{} {\em 型定義}, {\em 値定義},
    {\em 関数定義}, {\em 操作定義}, {\em def式
    }, {\em def文}, {\em ブロック文}。

  \item 陽関数定義および操作定義においては、 \vdmslpp{VDM-SL}{\vdmpp} におけるオプションの事後条件を指定することが可能である(第~\ref{functiondef} 節と第~\ref{op-def}節、または第~\ref{functiondef2}節か~\ref{op-def2}節を参照)。

  \item 陽関数定義および操作定義の本体は \vdmslpp{節}{節
    \keyw{is subclass responsibility}と}\keyw{is not yet specified}を用いて仮の方法で指定することができる。

    
  \item 陽関数定義および操作定義に対する拡張形式が組み入れられてきた。
拡張は、陰仕様定義に用いられたのと同様の見出しの使用を、関数と操作の定義で可能にするものである。
これはまず最初に陰仕様定義を書くことをより容易にし、そしてアルゴリズム部分を後に続けて加えることを容易にする。 
加えて、結果識別子の型ペアは2つ以上の識別子とともに働くために生成されたものである。

  フラット仕様記述では、\keyw{definitions}というキーワードは使用されない。このように、いくつかの
ファイルの上にフラット仕様記述を分配することができる。
しかしながら、モジュール内では、定義部は \keyw{definitions}というキーワードで始まらなければならない。
(第~\ref{flat}節参照)

%  \item IFAD \vdmsl\ has been extended with the {\em specification statement}.
  \vdmsl\ は {\em specification statement} (仕様記述文)で拡張された。

  \item  {\it if文\/} の中で ``else'' 部はオプションである (第~\ref{condstmt}節または第~\ref{condstmt2}節参照)
        
  \item 空集合と空列は直接にパターンとして用いることができる (第~\ref{patterns}節か~\ref{patterns2}節参照)
  \item ``制限する写像定義域'' と ``制限される写像定義域'' は適切にグループ化される (第~\ref{grouping}節参照)
  \item 写像型構成子に対する演算子優先順位は標準と異なる (第~\ref{preceedence}章参照)
  \item \vdmpp\ においては、組選択、型判断、事前条件式が加わる
  \item \vdmpp\ においては、原子代入文が加わる


  \end{itemize}
  
\item[意味定義上の相違 (wrt.\ インタープリタ):]\mbox{}\\[-3mm] 
  \begin{itemize}
  
  \item  \vdmslpp{\vdmsl}{\vdmpp} は条件論理によってのみ動作する (第~\ref{bool}節参照)。
    
  \item グローバル状態の初期化を、特別に構造的な方法で書かなければならない。
    少なくとも、モジュールからある操作が行われたら、モジュールの状態は初期化のみされることに注意する。
    (第~\ref{statedef}節参照)。

  \item  \vdmslpp{\vdmsl}{\vdmpp}においては、相互に再帰する{\it 値定義\/}は実行不可能であり、またそれらは用いられる前に定義されているように順序付けられなければならない (第~\ref{valuedef}節参照)。
    
  \item  {\it let文\/}と{\it  let式\/}におけるローカル定義は再帰的に定義されることは許されない。
さらにそれらは用いられる前に定義されているように順序付けられなければならない(第~\ref{let-exp}節と第~\ref{letstmt}節参照)。 
    
  \item \vdmslpp{\vdmsl}{\vdmpp}における数値型 \keyw{rat} は型 \keyw{real}と同じ型を表す (第~\ref{numeric}節参照)。   
      
  \item   ISO/VDM-SL において用いられるインタープリタ実行の自由度の2つの形式 は `劣決定系' と `非決定系である。 
 ISO/VDM-SL の操作における自由度では、関数に対して劣決定系である場合はすべて非決定系となる。
 \vdmslpp{\vdmsl}{\vdmpp}においては、操作と関数の両方における自由度は劣決定系である。
これはしかしながら、標準と一致するものでもある、なぜならインタープリタは単に仕様記述に対する可能な様式のひとつに相応するからである。

  \end{itemize}
\end{description}

\section{静的意味}\label{static}

構文規則に従った構文的に正しいVDM 仕様記述でも、必ずしも言語の型やスコープの規則に従ってはいない。
VDM仕様記述が良形であるかについては、 {\em 静的意味チェッカー}によって検査することができる。
Toolbox にはこのような静的意味チェッカー(プログラム言語では通常は型検査と呼ばれる)が存在する。

一般的に、与えられた VDM仕様記述が良形か否かは、静的に決定可能であるとはいえない。
\vdmslpp{\vdmsl}{\vdmpp}\ の静的意味は他の言語の静的意味とは異なる。他の言語は絶対的に良形だとはいえない仕様記述のみを拒絶し、また絶対的に良形で
ある仕様記述のみを受け入れる。 
\vdmslpp{\vdmsl}{\vdmpp}\ の静的意味は、VDM 仕様記述に対する {\em 良形である度合} があるものと考える。
このような良形である度合は、仕様記述が絶対的に良形であるか、絶対的に良形でないか、恐らく良形か、を示すものである。

このことは Toolbox において、静的意味チェッカーが、恐らくの正しさかあるいは絶対的な正しさかどちらかをチェックできることを意味する。
しかしながら、ただのほんとに単純な仕様記述のみが、絶対的良形であることのチェックにパスすることができるのだ、ということを記しておくべきであろう。
したがって、実際的な使用においては``恐らく良形''がもっとも役に立つ。

恐らく良形のチェックと絶対的良形のチェックの間の相違は、以下に続く VDM 仕様記述の断片によって実例をもって示すことができる:
\begin{alltt}
   \keyw{if} a = \keyw{true} 
   \keyw{then} a + 1 
   \keyw{else} \keyw{not} a
\end{alltt}
ここで {\tt a} は型 {\tt \keyw{nat} | \keyw{bool}} (\keyw{nat} と\keyw{bool}の合併型)をもっている。 
もし {\tt a}が \keyw{true} と等しいならば、そのとき{\tt a}に1を加えることは不可能となるであろうから、この式は悪形であると読者は簡単に理解することができる。
しかしながら、このような式は恣意的に複雑になり得るので、一般的にはこれが静的にチェックされる可能性はない。
この特別な例において、絶対的な良形であることは \keyw{false} となる一方で、恐らく良形であることは\keyw{true}となるであろう。



\newpage

%\bibliographystyle{newalpha}
\bibliographystyle{jalpha}
%\bibliographystyle{iptes}
\bibliography{ifad}

\newpage
\appendix

% Do not delete next line:
% Start Of Rules

%\section{The IFAD VDM-SL Syntax} \label{app-a} This appendix specifies the complete syntax for IFAD VDM-SL.
\section{VDM-SL構文} \label{app-a} この付録はVDM-SLの完全な構文を明確にするものである。
\subsection{文書}

\Ruledef{文書}{
  \Ruleref{任意のモジュール}, \SeqPt{\Ruleref{任意のモジュール}} \dsep
   \Ruleref{定義ブロック}, \SeqPt{\Ruleref{定義ブロック}}
  }

\Ruledef{任意のモジュール}{
  \Ruleref{モジュール} \dsep
  \Ruleref{動的リンクモジュール}
  }

\subsection{モジュール}

この全体の小区分はVDM-SL標準の最新版で存在しない。\marginpar{\hspace*{-3mm}\fbox{{\footnotesize 標準ではない}}}

\Ruledef{モジュール}{
  \Lop{module}, \Ruleref{識別子}, \Ruleref{インタフェース}, \lfeed
  \OptPt{\Ruleref{モジュール本体}}, \Lop{end}, \Ruleref{識別子}
  }

\Ruledef{インタフェース}{
  \OptPt{\Ruleref{輸入定義リスト}}, \lfeed
  \Ruleref{輸出定義}
  }

\Ruledef{輸入定義リスト}{
  \Lop{imports}, \Ruleref{輸入定義}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{輸入定義}}
  }

\Ruledef{輸入定義}{
  \Lop{from}, \Ruleref{識別子}, \Ruleref{輸入モジュールシグネチャ}
  }

\Ruledef{輸入モジュールシグネチャ}{
  \Lop{all} \dsep
  \Ruleref{輸入シグネチャ}, \SeqPt{\Ruleref{輸入シグネチャ}}
  }

\Ruledef{輸入シグネチャ}{
  \Ruleref{輸入型シグネチャ} \dsep
  \Ruleref{輸入値シグネチャ} \dsep
  \Ruleref{輸入関数シグネチャ} \dsep
  \Ruleref{輸入操作シグネチャ}
%  \dsep
%  \Ruleref{state signature}
  }

\Ruledef{輸入型シグネチャ}{
  \Lop{types}, \Ruleref{型輸入}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{型輸入}}, \OptPt{\Lit{;}}
  }

\Ruledef{型輸入}{
  \Ruleref{名称}, \OptPt{\Lop{renamed}, \Ruleref{名称}} \dsep
  \Ruleref{型定義}, \OptPt{\Lop{renamed}, \Ruleref{名称}}
  }

\Ruledef{輸入値シグネチャ}{
  \Lop{values}, \Ruleref{値輸入}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{値輸入}}, \OptPt{\Lit{;}}
  }

\Ruledef{値輸入}{
  \Ruleref{名称}, \OptPt{\Lit{:}, \Ruleref{型}}, \OptPt{\Lop{renamed}, \Ruleref{名称}}
  }

\Ruledef{輸入関数シグネチャ}{
  \Lop{functions}, \Ruleref{関数輸入}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{関数輸入}}, \OptPt{\Lit{;}}
  }

\Ruledef{関数輸入}{
  \Ruleref{名称}, \OptPt{\OptPt{型変数リスト}, 
  \Lit{:}, \Ruleref{関数型}}, \lfeed
  \OptPt{\Lop{renamed}, \Ruleref{名称}}
  }

\Ruledef{輸入操作シグネチャ}{
  \Lop{operations}, \Ruleref{操作輸入}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{操作輸入}}, \OptPt{\Lit{;}}
  }

\Ruledef{操作輸入}{
  \Ruleref{名称}, \OptPt{\Lit{:}, \Ruleref{操作型}}, \OptPt{\Lop{renamed}, \Ruleref{名称}}
  }

\Ruledef{輸出定義}{
  \Lop{exports}, \Ruleref{輸出モジュールシグネチャ}
  }

\Ruledef{輸出モジュールシグネチャ}{
  \Lop{all} \dsep
  \Ruleref{輸出シグネチャ}, \lfeed
  \SeqPt{\Ruleref{輸出シグネチャ}}
  }

\Ruledef{輸出シグネチャ}{
  \Ruleref{輸出型シグネチャ} \dsep
  \Ruleref{値群シグネチャ} \dsep
  \Ruleref{輸出関数シグネチャ} \dsep
  \Ruleref{操作群シグネチャ}
%  \dsep
%  \Ruleref{状態シグネチャ}
  }

\Ruledef{輸出型シグネチャ}{
  \Lop{types}, \Ruleref{型輸出}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{型輸出}}, \OptPt{\Lit{;}}
  }

\Ruledef{型輸出}{
  \OptPt{\Lop{struct}}, \Ruleref{名称}
  }

\Ruledef{値群シグネチャ}{
  \Lop{values}, \Ruleref{値シグネチャ}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{値シグネチャ}}, \OptPt{\Lit{;}}
  }

\Ruledef{値シグネチャ}{
  \Ruleref{名称リスト}, \Lit{:}, \Ruleref{型}
  }

\Ruledef{輸出関数シグネチャ}{
  \Lop{functions} \Ruleref{関数輸出}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{関数輸出}}, \OptPt{\Lit{;}}
  }

\Ruledef{関数輸出}{
  \Ruleref{名称リスト}, \OptPt{\Ruleref{型変数リスト}}, \Lit{:}, \lfeed
  \Ruleref{関数型}
  }
  
\Ruledef{関数群シグネチャ}{
  \Lop{functions} \Ruleref{関数シグネチャ}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{関数シグネチャ}}, \OptPt{\Lit{;}}
  }

\Ruledef{関数シグネチャ}{
    \Ruleref{名称リスト}, \Lit{:}, \Ruleref{関数型}
  }

\Ruledef{操作群シグネチャ}{
  \Lop{operations} \Ruleref{操作シグネチャ}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{操作シグネチャ}}, \OptPt{\Lit{;}}
  }

\Ruledef{操作シグネチャ}{
  \Ruleref{名称リスト}, \Lit{:}, \Ruleref{操作型}
  }
  
%\Ruledef{状態シグネチャ}{
%  \Lop{state}, \Ruleref{名称}, \SeqPt{\Lit{,}, \Ruleref{名称}}
%  }
 
\Ruledef{動的リンクモジュール}{
  \Lop{dlmodule}, \Ruleref{識別子}, \lfeed
  \Ruleref{動的リンクインタフェース},\lfeed
  \OptPt{\Ruleref{useシグネチャ}},\lfeed
  \Lop{end}, \Ruleref{識別子}
  }

\Ruledef{動的リンクインタフェース}{
  \OptPt{\Ruleref{動的リンク輸入定義リスト}}, \lfeed
  \Ruleref{動的リンク輸出定義}
  }

\Ruledef{useシグネチャ}{
   \Lop{uselib}, \Ruleref{テキストリテラル}
   }

\Ruledef{動的リンク輸入定義リスト}{
  \Lop{imports}, \lfeed
  \Ruleref{動的リンク輸入定義}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{動的リンク輸入定義}}
  }

\Ruledef{動的リンク輸入定義}{
  \Lop{from}, \Ruleref{識別子}, \lfeed
  \Ruleref{動的リンク輸入型シグネチャ群}
  }

\Ruledef{動的リンク輸入型シグネチャ群}{
  \Lop{types}, \Ruleref{名称}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{名称}}, \OptPt{\Lit{;}}
  }

\Ruledef{動的リンク輸出定義}{
  \Lop{exports}, \lfeed
  \Ruleref{動的リンク輸出シグネチャ}, \lfeed
  \SeqPt{\Ruleref{動的リンク輸出シグネチャ}}
  }

\Ruledef{動的リンク輸出シグネチャ}{
  \Ruleref{値群シグネチャ} \dsep
  \Ruleref{関数群シグネチャ} \dsep
  \Ruleref{操作群シグネチャ}
  }
\subsection{定義}


\Ruledef{モジュール本体}{
  \Lop{definitions}, \Ruleref{定義ブロック}, \SeqPt{\Ruleref{定義ブロック}}
  }

\Ruledef{定義ブロック}
{
  \Ruleref{型定義群} \dsep
  \Ruleref{状態定義群} \dsep
  \Ruleref{値定義群} \dsep
  \Ruleref{関数定義群} \dsep
  \Ruleref{操作定義群}
  }

\subsubsection{型定義}
\label{mathCSTypeDefs}

\Ruledef{型定義群}{
  \Lop{types}, 
  \OptPt{\ifthenelse{\boolean{VDMpp}}{\Ruleref{アクセス型定義}}%
                                     {\Ruleref{型定義}}
         , \lfeed
         \SeqPt{\Lit{;}, 
               \ifthenelse{\boolean{VDMpp}}{\Ruleref{アクセス型定義}}%
                                           {\Ruleref{型定義}}}, 
         \OptPt{\Lit{;}}
        }
  }%
  \nonstandard{1}

\ifthenelse{\boolean{VDMpp}}{
  \Ruledef{アクセス型定義}{
     (\OptPt{\Ruleref{アクセス}}, \OptPt{\Lop{static}})  \dsepl\ (\OptPt{\Lop{static}}, \OptPt{\Ruleref{アクセス}}), \lfeed 
     \Ruleref{型定義}
    }
  }{}

\ifthenelse{\boolean{VDMpp}}{
  \Ruledef{アクセス}{
    \Lop{public} \dsep \Lop{private} \dsep \Lop{protected}
  }
}{}

\Ruledef{型定義}{
  \Ruleref{識別子}, \Lit{=}, \Ruleref{型}, \OptPt{\Ruleref{不変条件}} \dsep
  \Ruleref{識別子}, \Lit{::}, \Ruleref{項目リスト}, \OptPt{\Ruleref{不変条件}}
  }

\Ruledef{型}{
  \Ruleref{括弧型} \dsep
  \Ruleref{基本型} \dsep
  \Ruleref{引用型} \dsep
  \Ruleref{レコード型} \dsep
  \Ruleref{合併型} \dsep
  \Ruleref{組型} \dsep
  \Ruleref{選択型} \dsep
  \Ruleref{集合型} \dsep
  \Ruleref{列型} \dsep
  \Ruleref{写像型} \dsep
  \Ruleref{部分関数型} \dsep
  \Ruleref{型名称} \dsep
  \Ruleref{型変数}
  }

\Ruledef{括弧型}{
  \Lit{(}, \Ruleref{型}, \Lit{)}
  }

\Ruledef{基本型}{
  \Lop{bool} \dsepl
  \Lop{nat} \dsepl
  \Lop{nat1} \dsepl
  \Lop{int} \dsepl
  \Lop{rat} \dsep
  \Lop{real} \dsepl
  \Lop{char} \dsepl
  \Lop{token} 
  }

\Ruledef{引用型}{
   \Lit{<}, \Ruleref{引用リテラル}, \Lit{>}
  }

\Ruledef{レコード型}{
  \Lop{compose}, \Ruleref{識別子}, \Lop{of}, \Ruleref{項目リスト}, \Lop{end}
  }

\Ruledef{項目リスト}{
  \SeqPt{\Ruleref{項目}}
  }

\Ruledef{項目}{
  \OptPt{\Ruleref{識別子}, \Lit{:}}, \Ruleref{型} \dsep
  \OptPt{\Ruleref{識別子}, \Lit{:-}}, \Ruleref{型}
  }

\Ruledef{合併型}{
  \Ruleref{型}, \Lit{|}, \Ruleref{型}, \SeqPt{\Lit{|}, \Ruleref{型}}
  }

\Ruledef{組型}{
  \Ruleref{型}, \Lit{*}, \Ruleref{型}, \SeqPt{\Lit{*}, \Ruleref{型}}
  }

\Ruledef{選択型}{
  \Lit{[}, \Ruleref{型}, \Lit{]}
  }

\Ruledef{集合型}{
  \Lop{set of}, \Ruleref{型}
  }

\Ruledef{列型}{
  \Ruleref{空列を含む列型} \dsep
  \Ruleref{空列を含まない列型}
  }

\Ruledef{空列を含む列型}{
  \Lop{seq of}, \Ruleref{型}
  }

\Ruledef{空列を含まない列型}{
  \Lop{seq1 of}, \Ruleref{型}
  }

\Ruledef{写像型}{
  \Ruleref{一般写像型} \dsep
  \Ruleref{1対1写像型}
  }

\Ruledef{一般写像型}{
  \Lop{map}, \Ruleref{型}, \Lop{to}, \Ruleref{型}
  }

\Ruledef{1対1写像型}{
  \Lop{inmap}, \Ruleref{型}, \Lop{to}, \Ruleref{型}
  }

\Ruledef{関数型}{
  \Ruleref{部分関数型} \dsep
  \Ruleref{全関数型}
  }

\Ruledef{部分関数型}{
  \Ruleref{任意の型}, \Lit{->}, \Ruleref{型}
  }

\Ruledef{全関数型}{
  \Ruleref{任意の型}, \Lit{+>}, \Ruleref{型}
  }

\Ruledef{任意の型}{
  \Ruleref{型} \dsep
  \Lit{(}, \Lit{)}
  }

\Ruledef{型名称}{
  \Ruleref{名称}
  }

\Ruledef{型変数}{
  \Ruleref{型変数識別子}
  }


\subsubsection{状態定義}

\Ruledef{状態定義}{
  \Lop{state}, \Ruleref{識別子}, \Lop{of}, \Ruleref{項目リスト}, \lfeed
  \OptPt{\Ruleref{不変条件}}, \OptPt{\Ruleref{初期化}}, \Lop{end}, \OptPt{\Lit{;}}
  }\nonstandard{1}
\Ruledef{不変条件}{
  \Lop{inv}, \Ruleref{不変条件初期関数}
  }

\Ruledef{初期化}{
  \Lop{init}, \Ruleref{不変条件初期関数}
  }

\Ruledef{不変条件初期関数}{
  \Ruleref{パターン}, \Lit{==}, \Ruleref{式}
  }

\subsubsection{値定義}

\Ruledef{値定義群}{
  \Lop{values}, 
  \OptPt{\ifthenelse{\boolean{VDMpp}}{\Ruleref{アクセス値定義}}%
                                     {\Ruleref{値定義}}, \lfeed
         \SeqPt{\Lit{;}, 
                \ifthenelse{\boolean{VDMpp}}{\Ruleref{アクセス値定義}}%
                                            {\Ruleref{値定義}}
               }, 
         \OptPt{\Lit{;}}
        }
  }
  \nonstandard{1}

  \ifthenelse{\boolean{VDMpp}}{
    \Rule{アクセス値定義}{
       (\OptPt{\Ruleref{アクセス}}, \OptPt{\Lop{static}})  \dsepl\ (\OptPt{\Lop{static}}, \OptPt{\Ruleref{アクセス}}), \lfeed 
         \Ruleref{値定義}
    }}{}

\Ruledef{値定義}{ 
  \Ruleref{パターン}, \OptPt{\Lit{:}, \Ruleref{型}}, \Lit{=}, \Ruleref{式}
  }
  \nonstandard{1}

\subsubsection{関数定義}\label{functiondef2}

\Ruledef{関数定義群}{
  \Lop{functions}, 
  \OptPt{\ifthenelse{\boolean{VDMpp}}{\Ruleref{アクセス関数定義}}%
                                     {\Ruleref{関数定義}}, \lfeed
         \SeqPt{\Lit{;}, 
                \ifthenelse{\boolean{VDMpp}}{\Ruleref{アクセス関数定義}}%
                                     {\Ruleref{関数定義}}}, 
         \OptPt{\Lit{;}}
        }
  }
  \nonstandard{1}

\ifthenelse{\boolean{VDMpp}}{
  \Ruledef{アクセス関数定義}{
    (\OptPt{\Ruleref{アクセス}}, \OptPt{\Lop{static}})  \dsepl\  (\OptPt{\Lop{static}}, \OptPt{\Ruleref{アクセス}}), \lfeed
      \Ruleref{関数定義}
  }}{}

\Ruledef{関数定義}{
  \Ruleref{陽関数定義} \dsep
  \Ruleref{陰関数定義} \dsep
  \Ruleref{拡張陽関数定義}
  }
  \nonstandard{1}

\Ruledef{陽関数定義}{
  \Ruleref{識別子},
  \OptPt{\Ruleref{型変数リスト}},
  \Lit{:}, \lfeed
  \Ruleref{関数型}, \lfeed
  \Ruleref{識別子}, \Ruleref{パラメーターリスト}, \lfeed
  \Lit{==}, \Ruleref{関数本体}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{式}}
    , \lfeed \OptPt{\Lop{post}, \Ruleref{式}}, \lfeed

  \OptPt{\Lop{measure}, \Ruleref{名称}}
  }
  \nonstandard{1}

\Ruledef{陰関数定義}{
  \Ruleref{識別子}, \OptPt{\Ruleref{型変数リスト}}, \lfeed 
  \Ruleref{パラメーター型}, \lfeed
  \Ruleref{識別子型ペアリスト}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{式}}, \lfeed
  \Lop{post}, \Ruleref{式}
  }

%This should be removed and exchanged with a more general solution.
\setlength{\nonstandlen}{-2\baselineskip}\addtolength{\nonstandlen}{-.8ex}

\vspace{\nonstandlen}\mbox{}\marginpar{\hspace*{-3mm}\raisebox{\nonstandlen}[0pt][0pt]{{\fbox{{\footnotesize Non standard}}}}}
\Ruledef{拡張陽関数定義}{
  \Ruleref{識別子}, \OptPt{\Ruleref{型変数リスト}}, \lfeed
  \Ruleref{パラメーター型}, \lfeed
  \Ruleref{識別子型ペアリスト}, \lfeed
  \Lit{==}, \Ruleref{関数本体}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{式}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{式}}
}

\Ruledef{型変数リスト}{
  \Lit{[}, \Ruleref{型変数識別子}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{型変数識別子}}, \Lit{]}
  }             

\Ruledef{識別子型ペア}{
  \Ruleref{識別子}, \Lit{:}, \Ruleref{型}
  }

\Ruledef{パラメーター型}{
  \Lit{(}, \OptPt{\Ruleref{パターン型ペアリスト}}, \Lit{)}
  }

\Ruledef{識別子型ペアリスト}{
  \Ruleref{識別子}, \Lit{:}, \Ruleref{型}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{識別子}, \Lit{:}, \Ruleref{型}}
}

\Ruledef{パターン型ペアリスト}{
  \Ruleref{パターンリスト}, \Lit{:}, \Ruleref{型}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{パターンリスト},\Lit{:}, \Ruleref{型}}
  }

\Ruledef{パラメーターリスト}{
  \Ruleref{パラメーター群}, \SeqPt{\Ruleref{パラメーター群}}
  }

\Ruledef{パラメーター群}{
  \Lit{(}, \OptPt{\Ruleref{パターンリスト}}, \Lit{)}
  }

\Ruledef{関数本体}{
  \Ruleref{式} \dsep
  \Lop{is not yet specified} 
  } \nonstandard{1}

\subsubsection{操作定義}\label{op-def2}

\Ruledef{操作定義群}{
  \Lop{operations}, 
  \OptPt{\ifthenelse{\boolean{VDMpp}}{\Ruleref{アクセス操作定義}}%
                                     {\Ruleref{操作定義}}, \lfeed
         \SeqPt{\Lit{;}, 
                \ifthenelse{\boolean{VDMpp}}{\Ruleref{アクセス操作定義}}%
                                     {\Ruleref{操作定義}}
               }, 
         \OptPt{\Lit{;}}
        }
  }\nonstandard{1}

  \ifthenelse{\boolean{VDMpp}}{
    \Ruledef{アクセス操作定義}{(
      \OptPt{\Ruleref{アクセス}}, \OptPt{\Lop{static}})  \dsep\  
     (
      \OptPt{\Lop{static}}, \OptPt{\Ruleref{アクセス}}), \lfeed
      \Ruleref{操作定義}
    }}{}

\Ruledef{操作定義}{
  \Ruleref{陽操作定義} \dsep
  \Ruleref{陰操作定義} \dsep
  \Ruleref{拡張陽操作定義}
  }\nonstandard{1}

\Ruledef{陽操作定義}{
  \Ruleref{識別子}, \Lit{:}, \Ruleref{操作型}, \lfeed
  \Ruleref{識別子}, \Ruleref{パラメーター群}, \lfeed
  \Lit{{\tt ==}}, \Ruleref{操作本体}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{式}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{式}}
  }\nobreak\nonstandard{1}

\Ruledef{陰操作定義}{
  \Ruleref{識別子}, \Ruleref{パラメーター型}, \lfeed
  \OptPt{\Ruleref{識別子型ペアリスト}}, \lfeed
  \Ruleref{陰操作本体}
  }

\Ruledef{陰操作本体}{
  \OptPt{\Ruleref{外部節}}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{式}}, \lfeed
  \Lop{post}, \Ruleref{式}, \lfeed
  \OptPt{\Ruleref{例外}}
  }

\Ruledef{拡張陽操作定義}{
  \Ruleref{識別子}, \Ruleref{パラメーター型}, \lfeed
  \OptPt{\Ruleref{識別子型ペアリスト}}, \lfeed
  \Lit{==}, \Ruleref{操作本体}, \lfeed
  \OptPt{\Ruleref{外部節}}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{式}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{式}}, \lfeed
  \OptPt{\Ruleref{例外}}
}\nonstandard{7}

\Ruledef{操作型}{
  \Ruleref{任意の型}, \Lit{==>}, \Ruleref{任意の型}
  }

\Ruledef{操作本体}{
  \Ruleref{文} \dsep 
  \Lop{is not yet specified}
  } \nonstandard{1}

\Ruledef{外部節}{
  \Lop{ext}, \Ruleref{var情報}, \SeqPt{\Ruleref{var情報}}
  }

\Ruledef{var情報}{
  \Ruleref{モード}, \Ruleref{名称リスト}, \OptPt{\Lit{:}, \Ruleref{型}}
  }

\Ruledef{モード}{
  \Lop{rd} \dsepl \Lop{wr}
  }

\Ruledef{例外}{
  \Lop{errs}, \Ruleref{エラーリスト}
  }

\Ruledef{エラーリスト}{
  \Ruleref{エラー}, \SeqPt{エラー}
  }

\Ruledef{エラー}{
  \Ruleref{識別子}, \Lit{:}, \Ruleref{式}, \Lit{->}, \Ruleref{式}
  }


\subsection{式}

\Ruledef{式リスト}{
  \Ruleref{式}, \SeqPt{\Lit{,}, \Ruleref{式}}
  }

\Ruledef{式}{
  \Ruleref{括弧式} \dsep
  \Ruleref{let式} \dsep
  \Ruleref{let be式} \dsep
  \Ruleref{def式} \dsep
  \Ruleref{if式} \dsep
  \Ruleref{cases式} \dsep
  \Ruleref{単項式} \dsep
  \Ruleref{2項式} \dsep
  \Ruleref{限量式} \dsep
  \Ruleref{iota式} \dsep
  \Ruleref{集合列挙} \dsep
  \Ruleref{集合内包} \dsep
  \Ruleref{集合範囲式} \dsep
  \Ruleref{列列挙} \dsep
  \Ruleref{列内包} \dsep
  \Ruleref{部分列} \dsep
  \Ruleref{写像列挙} \dsep
  \Ruleref{写像内包} \dsep
%  \Ruleref{tuple constructor} \dsep
  \Ruleref{組構成子} \dsep
%  \Ruleref{record constructor} \dsep 
  \Ruleref{レコード構成子} \dsep 
  \Ruleref{レコード修正子}  \dsep
  \Ruleref{適用} \dsep
  \Ruleref{項目選択} \dsep
  \Ruleref{組選択} \dsep
  \Ruleref{関数型インスタンス化} \dsep
  \Ruleref{ラムダ式} \dsep
  \Ruleref{一般is式} \dsep
  \Ruleref{未定義式} \dsep
  \Ruleref{事前条件式} \dsep
  \Ruleref{名称} \dsep
  \Ruleref{旧名称}  \dsep
  \Ruleref{記号リテラル}
}
\nonstandard{4}

\subsubsection{括弧式}

\Ruledef{括弧式}{
  \Lit{(}, \Ruleref{式}, \Lit{)}
  }

\subsubsection{ローカル束縛式}
 
\Ruledef{let式}{
  \Lop{let}, \Ruleref{ローカル定義},
   \SeqPt{\Lit{,}, \Ruleref{ローカル定義}}, \lfeed
  \Lop{in}, \Ruleref{式}
  }

\Ruledef{let be式}{
  \Lop{let}, \Ruleref{束縛},
  \OptPt{\Lop{be}, \Lop{st}, \Ruleref{式}}, \Lop{in}, \lfeed
  \Ruleref{式}
  }

\Ruledef{def式}{
  \Lop{def}, 
  \Ruleref{パターン束縛}, \Lit{=}, \Ruleref{式}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{パターン束縛}, \Lit{=}, \Ruleref{式}}, \OptPt{\Lit{;}},
  \lfeed
  \Lop{in}, \Ruleref{式}
  }
  \nonstandard{2}

\subsubsection{条件式}

\Ruledef{if式}{
  \Lop{if}, \Ruleref{式}, \Lop{then}, \Ruleref{式},\lfeed
  \SeqPt{\Ruleref{elseif式}}, \lfeed
  \Lop{else}, \Ruleref{式}
  }

\Ruledef{elseif式}{
  \Lop{elseif}, \Ruleref{式}, \Lop{then}, \Ruleref{式}
  }

\Ruledef{cases式}{
  \Lop{cases}, \Ruleref{式}, \Lit{:},\lfeed 
  \Ruleref{cases式選択肢群}, \lfeed
  \OptPt{\Lit{,}, \Ruleref{others式}}, \Lop{end}
  }

\Ruledef{cases式選択肢群}{
  \Ruleref{cases式選択肢}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{cases式選択肢}}
  }

\Ruledef{cases式選択肢}{
  \Ruleref{パターンリスト}, \Lit{->}, \Ruleref{式}
  }

\Ruledef{others式}{
  \Lop{others}, \Lit{->}, \Ruleref{式}
  }

\subsubsection{単項式}

\Ruledef{単項式}{
  \Ruleref{接頭辞式} \dsep
  \Ruleref{逆写像}
  }

\Ruledef{接頭辞式}{
  \Ruleref{単項演算子}, \Ruleref{式}
  }

\Ruledef{単項演算子}{
  \Ruleref{正符号} \dsep
  \Ruleref{負符号} \dsep
  \Ruleref{算術絶対値} \dsep
  \Ruleref{底値} \dsep
  \Ruleref{否定} \dsep
  \Ruleref{集合濃度} \dsep
  \Ruleref{有限べき集合} \dsep
  \Ruleref{分配的集合合併} \dsep
  \Ruleref{分配的集合共通部分} \dsep
  \Ruleref{列先頭} \dsep
  \Ruleref{列尾部} \dsep
  \Ruleref{列長} \dsep
  \Ruleref{列要素} \dsep
  \Ruleref{列索引} \dsep
  \Ruleref{分配的列連結} \dsep
  \Ruleref{写像定義域} \dsep
  \Ruleref{写像値域} \dsep
  \Ruleref{分配的写像併合}
  }

\Ruledef{正符号}{
  \Lit{+}
  }

\Ruledef{負符号}{
  \Lit{-}
  }

\Ruledef{算術絶対値}{
  \Lop{abs}
  }

\Ruledef{底値}{
  \Lop{floor}
  }

\Ruledef{否定}{
  \Lop{not}
  }

\Ruledef{集合濃度}{
  \Lop{card}
  }

\Ruledef{有限べき集合}{
  \Lop{power}
  }

\Ruledef{分配的集合合併}{
  \Lop{dunion}
  }

\Ruledef{分配的集合共通部分}{
  \Lop{dinter}
  }

\Ruledef{列先頭}{
  \Lop{hd}
  }

\Ruledef{列尾部}{
  \Lop{tl}
  }

\Ruledef{列長}{
  \Lop{len}
  }

\Ruledef{列要素}{
  \Lop{elems}
  }

\Ruledef{列索引}{
  \Lop{inds}
  }

\Ruledef{分配的列連結}{
  \Lop{conc}
  }

\Ruledef{写像定義域}{
  \Lop{dom}
  }

\Ruledef{写像値域}{
  \Lop{rng}
  }

\Ruledef{分配的写像併合}{
  \Lop{merge}
  }

\Ruledef{逆写像}{
  \Lop{inverse}, \Ruleref{式}
  }

\subsubsection{2項式}

\Ruledef{2項式}{
  \Ruleref{式}, \Ruleref{2項演算子}, \Ruleref{式}
  }

\Ruledef{2項演算子}{
  \Ruleref{加算} \dsep
  \Ruleref{減算} \dsep
  \Ruleref{乗算} \dsep
  \Ruleref{除算} \dsep
  \Ruleref{整数除算} \dsep
  \Ruleref{剰余算} \dsep
  \Ruleref{法算} \dsep
  \Ruleref{より小さい} \dsep
  \Ruleref{より小さいか等しい} \dsep
  \Ruleref{より大きい} \dsep
  \Ruleref{より大きいか等しい} \dsep
  \Ruleref{相等} \dsep
  \Ruleref{不等} \dsep
  \Ruleref{論理積} \dsep
  \Ruleref{論理和} \dsep
  \Ruleref{含意} \dsep
  \Ruleref{同値} \dsep
  \Ruleref{帰属} \dsep
  \Ruleref{非帰属} \dsep
  \Ruleref{包含} \dsep
  \Ruleref{真包含} \dsep
  \Ruleref{集合合併} \dsep
  \Ruleref{集合差} \dsep
  \Ruleref{集合共通部分} \dsep
  \Ruleref{列連結} \dsep
  \Ruleref{写像修正または列修正} \dsep
  \Ruleref{写像併合} \dsep
  \Ruleref{写像定義域限定} \dsep
  \Ruleref{写像定義域削減} \dsep
  \Ruleref{写像値域限定} \dsep
  \Ruleref{写像値域削減} \dsep
  \Ruleref{合成} \dsep
  \Ruleref{反復} 
}

\Ruledef{加算}{
  \Lit{+}
  }

\Ruledef{減算}{
  \Lit{-}
  }

\Ruledef{乗算}{
  \Lit{*}
  }

\Ruledef{除算}{
  \Lit{/}
  }

\Ruledef{整数除算}{
  \Lop{div}
  }

\Ruledef{剰余算}{
  \Lop{rem}
  }

\Ruledef{法算}{
  \Lop{mod}
  }

\Ruledef{より小さい}{
  \Lit{<}
  }

\Ruledef{より小さいか等しい}{
  \Lit{<=}
  }

\Ruledef{より大きい}{
  \Lit{>}
  }

\Ruledef{より大きいか等しい}{
  \Lit{>=}
  }

\Ruledef{相等}{
  \Lit{=}
  }

\Ruledef{不等}{
  \Lit{<>}
  }

%#ifdef VDMPP
%\Ruledef{約}{
%  \Lop{\~{}=}
%}
%#endif VDMPP
\Ruledef{論理和}{
  \Lop{or}
  }

\Ruledef{論理積}{
  \Lop{and}
  }

\Ruledef{含意}{
  \Lit{=>}
  }

\Ruledef{同値}{
  \Lit{<=>}
  }

\Ruledef{帰属}{
  \Lop{in set}
  }

\Ruledef{非帰属}{
  \Lop{not in set}
  }

\Ruledef{包含}{
  \Lop{subset}
  }

\Ruledef{真包含}{
  \Lop{psubset}
  }

\Ruledef{集合合併}{
  \Lop{union}
  }

\Ruledef{集合差}{
  \Lit{\char'134}
  }

\Ruledef{集合共通部分}{
  \Lop{inter}
  }

\Ruledef{列連結}{
  \Lit{\char'136}
  }

\Ruledef{写像修正または列修正}{
  \Lit{++}
  }

\Ruledef{写像併合}{
  \Lop{munion}
  }

\Ruledef{写像定義域限定}{
  \Lit{<:}
  }

\Ruledef{写像定義域削減}{
  \Lit{<-:}
  }

\Ruledef{写像値域限定}{
  \Lit{:>}
  }

\Ruledef{写像値域削減}{
  \Lit{:->}
  }

\Ruledef{合成}{
  \Lop{comp}
  }

\Ruledef{反復}{
  \Lit{**}
  }

\subsubsection{限量式}

\Ruledef{限量式}{
  \Ruleref{全称限量式} \dsep
  \Ruleref{存在限量式} \dsep
  \Ruleref{1存在限量式}
  }

\Ruledef{全称限量式}{
  \Lop{forall}, \Ruleref{束縛リスト}, \Lit{\&}, \Ruleref{式}
  }

\Ruledef{存在限量式}{
  \Lop{exists}, \Ruleref{束縛リスト}, \Lit{\&}, \Ruleref{式}
  }

\Ruledef{1存在限量式}{
  \Lop{exists1}, \Ruleref{束縛}, \Lit{\&}, \Ruleref{式}
  }

\subsubsection{iota式}

\Ruledef{iota式}{
  \Lop{iota}, \Ruleref{束縛}, \Lit{\&}, \Ruleref{式}
  }

\subsubsection{集合式}

\Ruledef{集合列挙}{
  \Lit{\{}, \OptPt{\Ruleref{式リスト}}, \Lit{\}}
  }

\Ruledef{集合内包}{
  \Lit{\{}, \Ruleref{式}, \Lit{|}, \Ruleref{束縛リスト}, \lfeed
  \OptPt{\Lit{\&}, \Ruleref{式}},
  \Lit{\}}
  }

\Ruledef{集合範囲式}{
  \Lit{\{}, \Ruleref{式}, \Lit{,}, \Lit{\Range}, \Lit{,},
  \lfeed
  \Ruleref{式},
  \Lit{\}}
  }

\subsubsection{列式}

\Ruledef{列列挙}{
  \Lit{[}, \OptPt{\Ruleref{式リスト}}, \Lit{]}
  }

\Ruledef{列内包}{
  \Lit{[}, \Ruleref{式}, \Lit{|}, \Ruleref{集合束縛}, \lfeed
  \OptPt{\Lit{\&}, \Ruleref{式}},
  \Lit{]}
  }

\Ruledef{部分列}{
  \Ruleref{式}, \Lit{(}, \Ruleref{式}, \Lit{,},
  \Lit{\Range}, \Lit{,}, \lfeed
  \Ruleref{式}, \Lit{)} 
  }

\subsubsection{写像式}

\Ruledef{写像列挙}{
  \Lit{\{}, \Ruleref{写}, \SeqPt{\Lit{,}, \Ruleref{写}}, \Lit{\}} \dsep
  \Lit{\{}, \Lit{|->}, \Lit{\}}
  }

\Ruledef{写}{
  \Ruleref{式}, \Lit{|->}, \Ruleref{式}
  }

\Ruledef{写像内包}{
  \Lit{\{}, \Ruleref{写}, \Lit{|}, \Ruleref{束縛リスト}, \lfeed
  \OptPt{\Lit{\&}, \Ruleref{式}},
  \Lit{\}}
  }

\subsubsection{組構成子式}

\Ruledef{組構成子}{
  \Lit{mk\_}, \Lit{(}, \Ruleref{式}, \Lit{,}, \Ruleref{式リスト}, \Lit{)}
  }

\subsubsection{レコード式}

\Ruledef{レコード構成子}{
  \Lop{mk\_},\nmk \Ruleref{名称}, \Lit{(}, \OptPt{\Ruleref{式リスト}}, \Lit{)}
  }
\ntext{境界文字は許されない}

\Ruledef{レコード修正子}{
  \Lit{mu}, \Lit{(}, \Ruleref{式}, \Lit{,}, \lfeed
  \Ruleref{レコード修正}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{レコード修正}}, \Lit{)}
  }

\Ruledef{レコード修正}{
  \Ruleref{識別子}, \Lit{|->}, \Ruleref{式}
  }

\subsubsection{適用式}

\Ruledef{適用}{
  \Ruleref{式}, \Lit{(}, \OptPt{\Ruleref{式リスト}}, \Lit{)}
  }

\Ruledef{項目選択}{
  \Ruleref{式}, \Lit{.}, \Ruleref{識別子}
  }

\Ruledef{組選択}{
  \Ruleref{式}, \Lit{.\#}, \Ruleref{数字}
  }

\Ruledef{関数型インスタンス化}{
  \Ruleref{名称}, \Lit{[}, \Ruleref{型}, \SeqPt{\Lit{,}, \Ruleref{型}}, \Lit{]}
  }
  
\subsubsection{ラムダ式}

\Ruledef{ラムダ式}{
  \Lop{lambda}, \Ruleref{型束縛リスト}, \Lit{\&}, \Ruleref{式}
  }

\subsubsection{narrow式}

  \Ruledef{narrow式}{
    \Lit{\keyw{narrow}\_}, \Lit{(}, \Ruleref{式}, \Lit{,}, \Ruleref{型}, \Lit{)}
  }


\subsubsection{is式}

\Ruledef{一般is式}{
  \Ruleref{is式} \dsep
  \Ruleref{型判定}
  }

\Ruledef{is式}{
  \Lit{\keyw{is}\_},\nmk \Ruleref{名称}, \Lit{(}, \Ruleref{式}, \Lit{)} \dsep
  \Ruleref{is基本型}, \Lit{(}, \Ruleref{式}, \Lit{)}
  }
\ntext{境界文字は許されない}

\Ruledef{型判定}{
  \Lit{\keyw{is}\_}, \Lit{(}, \Ruleref{式}, \Lit{,}, \Ruleref{型}, \Lit{)}
  }

\subsubsection{未定義式}

\Ruledef{未定義式}{
  \Lop{undefined}
  }
  \nonstandard{1}

\subsubsection{事前条件式}

\Ruledef{事前条件式}{
  \Lop{pre\_}, \Lit{(}, \Ruleref{式}, \lfeed
                        \OptPt{\SeqPt{\Lit{,}, \Ruleref{式}}},
               \Lit{)}
  }



\subsubsection{名称}

\Ruledef{名称}{
  \Ruleref{識別子}, \OptPt{\Lit{`}, \Ruleref{識別子}}
  }

\Ruledef{名称リスト}{
  \Ruleref{名称}, \SeqPt{\Lit{,}, \Ruleref{名称}}
  }

\Ruledef{旧名称}{
  \Ruleref{識別子}, \Lit{\char'176}
  }

\subsection{状態指示子}

\Ruledef{状態指示子}{
  \Ruleref{名称} \dsep
  \Ruleref{項目参照} \dsep
  \Ruleref{写像参照または列参照}
  }

\Ruledef{項目参照}{
  \Ruleref{状態指示子}, \Lit{.}, \Ruleref{識別子}
  }

\Ruledef{写像参照または列参照}{
  \Ruleref{状態指示子}, \Lit{(}, \Ruleref{式}, \Lit{)}
  }

\subsection{文}

\Ruledef{文}{
  \Ruleref{let文} \dsep
  \Ruleref{let be文} \dsep
  \Ruleref{def文} \dsep
  \Ruleref{ブロック文} \dsep
  \ifthenelse{\boolean{VDMpp}}{\Ruleref{一般代入文}}%
                              {\Ruleref{代入文}} \dsep
  \Ruleref{if文} \dsep
  \Ruleref{cases文} \dsep
  \Ruleref{列forループ} \dsep
  \Ruleref{集合forループ} \dsep
  \Ruleref{索引forループ} \dsep
  \Ruleref{whileループ} \dsep
  \Ruleref{非決定文} \dsep 
  \Ruleref{call文} \dsep
  \Ruleref{仕様記述文} \dsep
  \Ruleref{return文} \dsep
  \Ruleref{always文} \dsep
  \Ruleref{trap文} \dsep
  \Ruleref{再帰trap文} \dsep
  \Ruleref{exit文} \dsep
  \Ruleref{error文} \dsep
  \Ruleref{恒等文} 
  }
  \nonstandard{2}

\subsubsection{ローカル束縛文}

\Ruledef{let文}{
  \Lop{let}, \Ruleref{ローカル定義}, \SeqPt{\Lit{,}, \Ruleref{ローカル定義}}, \lfeed
  \Lop{in}, \Ruleref{文}
  }

\Ruledef{ローカル定義}{
  \Ruleref{値定義} \dsep 
  \Ruleref{関数定義}
  }

\Ruledef{let be文}{
  \Lop{let}, \Ruleref{束縛}, \OptPt{\Lop{be}, \Lop{st},
  \Ruleref{式}}, \Lop{in}, \lfeed
  \Ruleref{文}
  }

\Ruledef{def文}{
  \Lop{def}, \Ruleref{相等定義}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{相等定義}}, \OptPt{\Lit{;}},
  \lfeed
  \Lop{in}, \Ruleref{文}
  }
  \nonstandard{1}

\Ruledef{相等定義}{
  \Ruleref{パターン束縛}, \Lit{=},
   \Ruleref{式}}

\subsubsection{ブロック文と代入文}

\Ruledef{ブロック文}{
  \Lit{(}, \SeqPt{\Ruleref{dcl文}}, \lfeed
  \Ruleref{文}, \SeqPt{\Lit{;},  \Ruleref{文}}, \OptPt{\Lit{;}}, 
  \Lit{)}
  }\nonstandard{1}

\Ruledef{dcl文}{
  \Lop{dcl}, \Ruleref{代入定義}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{代入定義}}, \Lit{;}
  }

\Ruledef{代入定義}{
  \Ruleref{識別子}, \Lit{:}, \Ruleref{型}, \OptPt{\Lit{:=}, 
    \Ruleref{式} }
  }

%\ifthenelse{\boolean{VDMpp}}{%
  \Ruledef{一般代入文}{
  \Ruleref{代入文} \dsep
  \Ruleref{多重代入文}
  }
%}%
%{}

\Ruledef{代入文}{
  \Ruleref{状態指示子}, \Lit{:=}, 
    \Ruleref{式}
  }

%\ifthenelse{\boolean{VDMpp}}{%
  \Ruledef{多重代入文}{
    \Lit{atomic}, 
    \Lit{(}
      \Ruleref{代入文}, \Lit{;}, \lfeed
      \Ruleref{代入文},
      \lfeed
      \SeqPt{\Lit{;},\Ruleref{代入文}}
    \Lit{)}
    }
%  }%
%{}


\subsubsection{条件文}\label{condstmt2}

\Ruledef{if文}{
  \Lop{if}, \Ruleref{式}, \Lop{then}, \Ruleref{文}, \lfeed
  \SeqPt{\Ruleref{elseif文}}, \lfeed
  \OptPt{\Lop{else}, \Ruleref{文}}
  }

\Ruledef{elseif文}{
  \Lop{elseif}, \Ruleref{式}, \Lop{then}, \Ruleref{文}
  }

\Ruledef{cases文}{
  \Lop{cases}, \Ruleref{式}, \Lit{:}, \lfeed
  \Ruleref{cases文選択肢群}, \lfeed 
  \OptPt{\Lit{,}, \Ruleref{others文}}, \Lop{end}
  }

\Ruledef{cases文選択肢群}{
  \Ruleref{cases文選択肢}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{cases文選択肢}}
  }

\Ruledef{cases文選択肢}{
  \Ruleref{パターンリスト}, \Lit{->}, \Ruleref{文}
  }

\Ruledef{others文}{
  \Lop{others}, \Lit{->}, \Ruleref{文}
  }

\subsubsection{ループ文}

\Ruledef{列forループ}{
  \Lop{for}, \Ruleref{パターン束縛}, \Lop{in},
  \OptPt{\Lop{reverse}}, \lfeed
  \Ruleref{式}, \Lop{do}, \Ruleref{文}
  }

\Ruledef{集合forループ}{
  \Lop{for}, \Lop{all}, \Ruleref{パターン}, \Lop{in set},
  \Ruleref{式},\lfeed
  \Lop{do}, \Ruleref{文}
  }

\Ruledef{索引forループ}{
  \Lop{for}, \Ruleref{識別子}, \Lit{=}, \Ruleref{式},
  \Lop{to}, \Ruleref{式}, \lfeed
  \OptPt{\Lop{by}, \Ruleref{式}}, \lfeed
  \Lop{do}, \Ruleref{式}
  }

\Ruledef{whileループ}{
  \Lop{while}, \Ruleref{式}, \Lop{do}, \Ruleref{式}
  }
\subsubsection{非決定文}

\Ruledef{非決定文}{
  \Lit{||}, \Lit{(}, \Ruleref{文}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{文}}, \Lit{)}
  }

\subsubsection{call文とreturn文}

\Ruledef{call文}{
  \Ruleref{名称}, \Lit{(}, \lfeed
  \OptPt{\Ruleref{式リスト}}, \Lit{)}
}

\Ruledef{return文}{
  \Lop{return}, \OptPt{\Ruleref{式}}
  }

\subsubsection{仕様記述文}

\Ruledef{仕様記述文}{
  \Lit{[}, \Ruleref{陰操作本体}, \Lit{]}
  }\nonstandard{1}



\subsubsection{例外処理文}

\Ruledef{always文}{
  \Lop{always}, \Ruleref{文}, \Lop{in}, \Ruleref{文}
  }

\Ruledef{trap文}{
  \Lop{trap}, \Ruleref{パターン束縛}, \Lop{with}, \Ruleref{文},
  \lfeed
  \Lop{in}, \Ruleref{文}
  }

\Ruledef{再帰trap文}{
  \Lop{tixe}, \Ruleref{trap群}, \Lop{in}, \Ruleref{文}
  }

\Ruledef{trap群}{
  \Lit{\{}, \Ruleref{パターン束縛}, \Lit{|->}, \Ruleref{文}, \lfeed  \SeqPt{\Lit{,}, \Ruleref{パターン束縛}, \Lit{|->}, \Ruleref{文}},
  \Lit{\}}
  }

\Ruledef{exit文}{
  \Lop{exit}, \OptPt{\Ruleref{式}}
  }

\subsubsection{error文}

  \Ruledef{error文}{
    \Lop{error}
    }\nonstandard{1}

\subsubsection{恒等文}

\Ruledef{恒等文}{
  \Lop{skip}
  }

\subsection{パターンと束縛}

\subsubsection{パターン}\label{patterns2}

\Ruledef{パターン}{
  \Ruleref{パターン識別子} \dsep
  \Ruleref{一致値} \dsep
  \Ruleref{集合列挙パターン} \dsep
  \Ruleref{集合合併パターン} \dsep
  \Ruleref{列列挙パターン} \dsep
  \Ruleref{列連結パターン} \dsep
   \Ruleref{写像列挙パターン} \dsep
   \Ruleref{写像併合パターン} \dsep
  \Ruleref{組パターン} \dsep
  \Ruleref{レコードパターン}
  }

\Ruledef{パターン識別子}{
  \Ruleref{識別子} \dsepl \Lit{-}
  }

\Ruledef{一致値}{
  \Lit{(}, \Ruleref{式}, \Lit{)} \dsep
  \Ruleref{記号リテラル}
  }

\Ruledef{集合列挙パターン}{
  \Lit{\{}, \OptPt{\Ruleref{パターンリスト}}, \Lit{\}}
  }\nonstandard{1}

\Ruledef{集合合併パターン}{
  \Ruleref{パターン}, \Lit{union}, \Ruleref{パターン}
  }

\Ruledef{列列挙パターン}{
  \Lit{[}, \OptPt{\Ruleref{パターンリスト}}, \Lit{]}
  }\nonstandard{1}

\Ruledef{列連結パターン}{
  \Ruleref{パターン}, \Lit{\char'136}, \Ruleref{パターン}
  }

  \Ruledef{写像列挙パターン}{
    \Lit{\{}, [\Ruleref{写パターンリスト}], \Lit{\}}
    }
    
  \Ruledef{写パターンリスト}{
    \Ruleref{写パターン}, \SeqPt{\Lit{,}, \Ruleref{写パターン}}
    }
    
  \Ruledef{写パターン}{
    \Ruleref{パターン}, \Lit{|->}, \Ruleref{パターン}
  }

   \Ruledef{写像併合パターン}{
    \Ruleref{パターン}, \Lit{\keyw{munion}}, \Ruleref{パターン}
    }

\Ruledef{組パターン}{
  \Lit{mk\_}, \Lit{(}, \Ruleref{パターン}, \Lit{,}, \Ruleref{パターンリスト}, \Lit{)}
  } 

\Ruledef{レコードパターン}{
  \Lit{mk\_},\nmk \Ruleref{名称}, \Lit{(}, \OptPt{\Ruleref{パターンリスト}}, \Lit{)}
  }
\ntext{境界文字は許されない}

\Ruledef{パターンリスト}{
  \Ruleref{パターン}, \SeqPt{\Lit{,}, \Ruleref{パターン}}
  }

\subsubsection{束縛}

\Ruledef{パターン束縛}{
  \Ruleref{パターン} \dsepl \Ruleref{束縛}
  }

\Ruledef{束縛}{
  \Ruleref{集合束縛} \dsepl \Ruleref{型束縛}
  }

  \Ruledef{集合束縛}{
    \Ruleref{パターン}, \Lop{in set}, \Ruleref{式}
    }

  \Ruledef{型束縛}{
    \Ruleref{パターン}, \Lit{:}, \Ruleref{型}
    }

  \Ruledef{束縛リスト}{
    \Ruleref{多重束縛}, \SeqPt{\Lit{,}, \Ruleref{多重束縛}}
    }

  \Ruledef{多重束縛}{
    \Ruleref{多重集合束縛} \dsep
    \Ruleref{多重型束縛}
    }

  \Ruledef{多重集合束縛}{
    \Ruleref{パターンリスト}, \Lop{in set}, \Ruleref{式}
    }

  \Ruledef{多重型束縛}{
    \Ruleref{パターンリスト}, \Lit{:}, \Ruleref{型}
    }

\Ruledef{型束縛リスト}{
  \Ruleref{型束縛}, \SeqPt{\Lit{,}, \Ruleref{型束縛}}
  }

\section{語彙}\label{app-b}\label{ap:lexis}

\subsection{文字}

文字集合は、この文書で用いられた文字形式と共に、~\ref{charSetTable}表に示される。
%この文字集合はちょうど ASCII (or ISO 646) 構文に相当するものであることには注意したい。
 \vdmsl\ 標準において文字は次のとおりに定義される:

\Ruledef{文字}{
  \hyperlink{charSetTable}{通常文字} \dsep
  \hyperlink{charSetTable}{キーワード文字} \dsep
  \hyperlink{charSetTable}{識別文字} \dsep
  ギリシャ文字 \dsep
  \hyperlink{charSetTable}{アラビア数字} \dsep
  \hyperlink{charSetTable}{境界文字} \dsep
  \hyperlink{charSetTable}{その他の文字} \dsep
  \Ruleref{分離符}
  }

通常文字とキーワード文字は ~\ref{charSetTable}表 に表示されている (この文書ではキーワード文字は単に相当するアルファベット小文字を用いている)。 
識別文字は相当するアルファベットの大文字と小文字を用いるが引用リテラルは``{\tt <}''で始め ``{\tt >}''で閉じる (引用文字にはアンダーバーや数字も用いることができることに注目)。 
ギリシャ文字も数値記号``{\tt \#}''の後に相当する文字を続けることで使用できる(この情報は \LaTeX\ pretty printer で用いられ、ギリシャ文字が提示できるようになっている)。 
全境界文字(標準 ASCII 版のもの)は表~\ref{charSetTable} に記述されている。
標準では境界文字とそれらの組み合わせには違いをもたせている。
ここではこれを違いとして扱わない。
数学構文中のいくつかの境界文字が、ここで用いられているASCII構文中ではキーワードとなることにも気づいてもらいたい。

\begin{table}[ht]
\setlength{\tabcolsep}{3.5mm}
\setlength{\arraycolsep}{3.5mm}

\rule{\textwidth}{.5mm}
    {\sf
    \begin{tabular}{*{13}{l}} 
        % that's 13 italic columns
        \multicolumn{13}{l}{\rm 文字:} \\
        a & b & c & d & e & f & g & h & i & j & k & l & m \\
        n & o & p & q & r & s & t & u & v & w & x & y & z \\
        A & B & C & D & E & F & G & H & I & J & K & L & M \\
        N & O & P & Q & R & S & T & U & V & W & X & Y & Z \\
        \multicolumn{3}{l}{漢字} & \multicolumn{10}{l}{ハングル文字}
    \end{tabular}
    }

\blankline
    {\sf  
    \begin{tabular}{*{13}{l}}
        % that's 13 keyword columns
        \multicolumn{13}{l}{\rm キーワード文字:} \\
        a & b & c & d & e & f & g & h & i & j & k & l & m \\
        n & o & p & q & r & s & t & u & v & w & x & y & z
    \end{tabular}
    }

\blankline
{\tt
    \begin{tabular}{*{10}{l}}
        % that's 10 math columns
        \multicolumn{10}{l}{\mbox{{\rm 境界文字:}}} \\
          ,         & :         & ;         & =         & (         &
          )         & |         & -         & [         & ]         \\
          \{        & \}        & +         & /         & <         &
          >         & <=        & >=        & <>        &  .        \\
          \verb+*+  & ->        & +>        & ==>       & ||        &
          =>        &   <=>     & |->       & <:        & :>        \\
          <-:       & :->       & \&        & ==        & **        & 
          \verb+^+  & ++        &           &           &           \\
    \end{tabular}
}

\blankline
    \begin{tabular}{*{10}{l}}
        \multicolumn{10}{l}{アラビア数字:} \\
        {\tt 0}
        & {\tt 1} 
        & {\tt 2} 
        & {\tt 3} 
        & {\tt 4} 
        & {\tt 5}
        & {\tt 6} 
        & {\tt 7} 
        & {\tt 8} 
        & {\tt 9} 
     \end{tabular}

\blankline
    \begin{tabular}{*{10}{l}}
        \multicolumn{10}{l}{16進数字:} \\
        {\tt 0} & {\tt 1} & {\tt 2} & {\tt 3} & {\tt 4} & {\tt 5} & {\tt 6} & {\tt 7} & {\tt 8} & {\tt 9} \\
        {\tt A} & {\tt B} & {\tt C} & {\tt D} & {\tt E} & {\tt F} \\
        {\tt a} & {\tt b} & {\tt c} & {\tt d} & {\tt e} & {\tt f} 
     \end{tabular}

\blankline
    \begin{tabular}{*{8}{l}}
        \multicolumn{8}{l}{8進数字:} \\
        {\tt 0}
        & {\tt 1} 
        & {\tt 2} 
        & {\tt 3} 
        & {\tt 4} 
        & {\tt 5}
        & {\tt 6} 
        & {\tt 7} 
     \end{tabular}

\blankline
    \begin{tabular}{*{6}{l}}
        \multicolumn{6}{l}{その他の文字:} \\
        {\tt \_} 
        & {\tt \char'140} % `
        & {\tt \char'047} % '
        & {\tt \char'042} % ''
        & {\tt \char'100} % @
        & {\tt \~{}}
    \end{tabular}

\blankline
    \begin{tabular}{p{14cm}}   %{p{\textwidth}}
        改行: \\
        \\
        空白: \\
        \\
        これらはグラフィックな形態をもたないが、空白と行替えを組み合わせる。
ここに2つの分離符がある: 行替えしない(空白) と行替えを行う (改行)である。
    \end{tabular}

\rule{\textwidth}{.5mm}
\hypertarget{charSetTable}{\caption{文字集合}}
\label{charSetTable}

\end{table}

\clearpage % to force table to appear *here*


\subsection{記号}\label{Symbols}

以下のような種類の記号が存在する: キーワード、境界文字、
% simple names -- these do not seem to exist anymore DJA
記号リテラル、そしてコメント。  
文字から記号への変換も以下の規則のもとに与えられている; これらは構文定義と同じ表記を用いるが、意味においては続く終了符との間に分離符がないという点で異なる。
それ例外の曖昧さが生ずる場所では、2つの連続する記号は分離符によって分離されていなければならない。

\newcommand{\Lks}[1]{\Lop{#1}\dsepl}
\newcommand{\Lksb}[1]{\Lop{#1}\dsep}
\Ruledef{キーワード}{
  \Lks{abs}
  \Lks{all}
  \Lks{always}
  \Lks{and}
  \Lks{as}
  \Lks{atomic}
  \Lks{be}
  \Lks{bool}
  \Lksb{by}
  \Lks{card}
  \Lks{cases}
  \Lks{char}
  \Lks{comp}
  \Lks{compose} 
  \Lksb{conc}
  \Lks{dcl}
  \Lks{def}
  \Lks{definitions}
  \Lks{dinter} 
  \Lks{div}
  \Lksb{dlmodule}
  \Lks{do}
  \Lks{dom}
  \Lks{dunion}
  \Lks{elems}
  \Lks{else}
  \Lks{elseif}
  \Lksb{end}
  \Lks{error}
  \Lks{errs}
  \Lks{exists}
  \Lks{exists1}
  \Lks{exit} 
  \Lks{exports}
  \Lksb{ext} 
  \Lks{false} 
  \Lks{floor}
  \Lks{for} 
  \Lks{forall}
  \Lks{from}
  \Lksb{functions}
  \Lks{hd} 
  \Lks{if}
  \Lks{imports}
  \Lks{in} 
  \Lks{inds}
  \Lks{init}
  \Lksb{inmap}
  \Lks{int}
  \Lks{inter}
  \Lks{inv}
  \Lks{inverse}
  \Lks{iota}
  \Lksb{is\_}
  \Lks{lambda}
  \Lks{len} 
  \Lks{let}
  \Lks{make\_}
  \Lks{map}
  \Lks{narrow\_}
  \Lksb{measure}
  \Lks{merge} 
  \Lks{mod} 
  \Lksb{module}
  \Lks{mu\_}
  \Lks{munion}
  \Lks{nat}
  \Lks{nat1}
  \Lks{nil} 
  \Lks{not}
  \Lksb{of}
  \Lks{operations}
  \Lks{or}
  \Lks{others}
  \Lksb{post}
  \Lks{power} 
  \Lks{pre}
  \Lks{psubset}
  \Lks{rat}
  \Lks{rd}
  \Lks{real} 
  \Lksb{rem}
  \Lks{renamed}
  \Lks{return}
  \Lks{reverse}
  \Lks{rng}
  \Lks{seq}
  \Lksb{seq1}
  \Lks{set}
  \Lks{skip}
  \Lks{specified}
  \Lks{st}
  \Lks{state}
  \Lksb{struct}
  \Lks{subset}
  \Lks{then}
  \Lks{tixe}
  \Lks{tl}
  \Lks{to}
  \Lks{token}
  \Lksb{trap} 
  \Lks{true}
  \Lks{types}
  \Lks{undefined}
  \Lks{union}
  \Lksb{uselib}
  \Lks{values} 
  \Lks{while} 
  \Lks{with}
  \Lks{wr}
  \Lksb{yet}
  \Lop{RESULT} 
  }

\Ruledef{分離符}{
  \hyperlink{charSetTable}{改行} \dsepl 
  \hyperlink{charSetTable}{空白}
  }

\Ruledef{識別子}{
  \Brack{\hyperlink{charSetTable}{文字} \dsepl ギリシャ文字}, \lfeed
  \SeqPt{\Brack{\hyperlink{charSetTable}{文字} \dsepl ギリシャ文字} \dsepl % \Ruleref{IS THIS RIGHT}??
    \hyperlink{charSetTable}{アラビア数字}      \dsepl
    \Lit{'}  \dsepl
    \Lit{\_}
    }
  }

\medskip


% ueki 2010/3/4
\noindent %識別子において用いられることが可能なハイフンは下線(アンダースコア ``\_''ともいわれる)として書かれることに注意しよう、数学構文では``-''と翻訳されるものであっても。
次の予約前置詞の1つと共に始まるすべての識別子は予約されている: 
 \keyw{init\_}, \keyw{inv\_}, \keyw{is\_}, \keyw{mk\_},
\keyw{post\_} そして \keyw{pre\_}。

\Ruledef{型変数識別子}{
  \Lit{@}, \Ruleref{識別子}
  }

\Ruledef{is基本型}{
  \Lop{is\_}, 
  \Brack{%
    \Lop{bool} \dsepl
    \Lop{nat} \dsepl 
    \Lop{nat1} \dsepl 
    \Lop{int} \dsepl 
    \Lop{rat} \dsep 
    \Lop{real} \dsepl
    \Lop{char} \dsepl
    \Lop{token}
    }
  }

\Ruledef{記号リテラル}{
  \Ruleref{数値リテラル} \dsepl
  \Ruleref{ブールリテラル} \dsep
  \Ruleref{nilリテラル} \dsepl
  \Ruleref{文字リテラル} \dsepl
  \Ruleref{テキストリテラル} \dsep
  \Ruleref{引用リテラル}
  }

\Ruledef{数字}{
  \hyperlink{charSetTable}{アラビア数字}, \SeqPt{\hyperlink{charSetTable}{アラビア数字}}
  }

\Ruledef{数値リテラル}{
  \hyperlink{charSetTable}{10進数値リテラル} \dsepl \hyperlink{charSetTable}{16進数値リテラル}
}

\Ruledef{指数}{
  \Brack{\Lit{E} \dsepl \Lit{e}},
  \OptPt{\Lit{+} \dsepl \Lit{-}},
  \Ruleref{数字}
  }

\Ruledef{10進数値リテラル}{
  \Ruleref{数字},
  \OptPt{\Lit{.}, \hyperlink{charSetTable}{アラビア数字}, \SeqPt{\hyperlink{charSetTable}{アラビア数字}}},
  \OptPt{\Ruleref{指数}}
}

\Ruledef{16進数値リテラル}{
  \Brack{\Lit{0x} \dsepl \Lit{0X}}, \hyperlink{charSetTable}{16進数字}, \SeqPt{\hyperlink{charSetTable}{16進数字}}
}

\Ruledef{ブールリテラル}{
  \Lop{true} \dsepl \Lop{false}
  }

\Ruledef{nilリテラル}{
  \Lop{nil}
  }

\Ruledef{文字リテラル}{
  \Lit{\mbox{\,}'\mbox{\,}}, \Ruleref{文字} \dsepl 
  \Ruleref{エスケープ列} \dsep 
  \Ruleref{多文字}, 
  \Lit{\mbox{\,}'\mbox{\,}}
  }%\nonstandard{1}

\Ruledef{エスケープ列}{
  \Lit{\char'134\char'134} \dsepl \Lit{{\char'134}r} \dsepl
  \Lit{{\char'134}n} \dsepl \Lit{{\char'134}t} \dsepl
  \Lit{{\char'134}f} \dsepl \Lit{{\char'134}e} \dsepl \Lit{{\char'134}a} \dsep
  \Lit{{\char'134}x} \hyperlink{charSetTable}{16進数字},\hyperlink{charSetTable}{16進数字} \dsepl
  \Lit{{\char'134}c} \Ruleref{文字} \dsep
  \Lit{{\char'134}} \hyperlink{charSetTable}{8進数字}, \hyperlink{charSetTable}{8進数字}, \hyperlink{charSetTable}{8進数字} \dsep
  \Lit{{\char'134}"} \dsepl
  \Lit{{\char'134}'} \dsepl
  }

\Ruledef{多文字}{ギリシャ文字 \dsep
   \Lit{<=} \dsepl \Lit{>=} \dsepl \Lit{<>} \dsepl \Lit{->} \dsepl
   \Lit{+>} \dsepl \Lit{==>} \dsepl \Lit{||} \dsep \Lit{=>} \dsepl
   \Lit{<=>} \dsepl \Lit{|->} \dsepl \Lit{<:} \dsepl \Lit{:>} \dsepl
   \Lit{<-:} \dsep \Lit{:->} \dsepl \Lit{==} \dsepl \Lit{**} \dsepl
   \Lit{++}}  

\Ruledef{テキストリテラル}{
  \Lit{\mbox{\,}"\mbox{\,}},
  \SeqPt{%
%    \Lit{\mbox{\,}"\mbox{\,}"\mbox{\,}}\dsepl%  was , - changed by br!
%    character -- \Brack{\Lit{\mbox{\,}"\mbox{\,}}\dsepl newline}
     \Lit{\mbox{\,}"\mbox{\,}"\mbox{\,}}\dsepl
     \Ruleref{文字} \dsepl \Ruleref{エスケープ列}
    },
  \Lit{\mbox{\,}"\mbox{\,}}
  }

\Ruledef{引用リテラル}{
  \hyperlink{charSetTable}{識別文字}, \lfeed
  \SeqPt{\Lit{\_} \dsepl \hyperlink{charSetTable}{識別文字}
   \dsepl \hyperlink{charSetTable}{アラビア数字}}% \Ruleref{M30} (\Ruleref{hyphen allowed})
  }

\Ruledef{一行コメント}{
  \Lit{--}, \SeqPt{\Ruleref{文字} -- \hyperlink{charSetTable}{改行}}, \hyperlink{charSetTable}{改行}
  }


上記のエスケープ列は次のように翻訳される:

\begin{center}
\begin{tabular}{ll}\hline
列 & 翻訳\\ \hline
  \Lit{\char'134\char'134} & バックスラッシュ文字\\
  \Lit{{\char'134}r}       & リターン文字\\
  \Lit{{\char'134}n}       & 改行文字\\
  \Lit{{\char'134}t}       & タブ文字\\
  \Lit{{\char'134}f}       & 用紙送り文字\\
  \Lit{{\char'134}e}       & エスケープ文字\\
  \Lit{{\char'134}a}       & アラーム (ベル)\\
  \Lit{{\char'134}x} 16進数字,16進数字 
                           & 文字の16進表示\\
                           & (たとえば \texttt{{\char'134}x41} は `A')\\
  \Lit{{\char'134}c} 文字 
                           & 制御文字\\
                           & (たとえば \texttt{{\char'134}c A} $\equiv$ 
                                    \texttt{{\char'134}x01})\\
  \Lit{{\char'134}} 8進数字, 8進数字, 8進数字 
                           & 文字の8進表示\\
  \Lit{{\char'134}{\char'042}}       &  \texttt{{\char'042}} 文字\\
  \Lit{{\char'134}'}       &  \verb+'+ 文字 \\
\end{tabular}
\end{center}

\newpage
\section{演算子優先順位}\label{app-c}

具象構文における演算子の優先順位は2段階で定義される: 演算子はファミリーに区分けされて、上位の優先順位 $>$ がそれらのファミリーに対し与えられるが、その結果
ファミリーである $F\sb{1}$ と $F\sb{2}$ が次を満足させるとする

\begin{quote}
$F\sb{1} > F\sb{2}$
\end{quote}

\noindent するとファミリー $F\sb{1}$ のすべての演算子はファミリー $F\sb{2}$ のすべての演算子より高位の優先順をもつ。

ファミリー内での相対的な演算子の優先順は、型情報を考慮して決定され、これが曖昧さの解決に役立つ。 
型構成子は別に扱われ、他の演算子とともに優先順に並べられることはない。

演算子には6つのファミリーすなわち、結合子、適用子、評価子、関係子、連結子、構成子がある:

\begin{description}%{Connectivesxx}
\item[結合子:] 関数値、写像値の結合および、関数値、写像値、数値の反復を許す操作。
\item[適用子:] 関数適用、項目選択、列索引、その他、
\item[評価子:] 非述語である演算子。
\item[関係子:] 関係の演算子。
\item[連結子:] 論理連結子。
\item[構成子:] 式の構成において、陰に陽に用いられる演算子; たとえば  \keyw{if-then-elseif-else}, `{\tt
    |->}', `\ldots', その他。
\end{description}

\noindent ファミリー上の優先順は次の通り:

\begin{quote}
$\mbox{\small 結合子} >
\mbox{\small 適用子} >
\mbox{\small 評価子}  >
\mbox{\small 関係子}   >
\mbox{\small 連結子} >
\mbox{\small 構成子}$
\end{quote}

\subsection{結合子のファミリー}

これらの結合子は最高位の優先順位をもつ。

\Ruledef{結合子}{
  \Ruleref{反復} \dsepl \Ruleref{合成}
  }

\Ruledef{反復}{
  \Lit{**}
  }

\Ruledef{合成}{
  \Lop{comp}
  }

\blankline
\begin{center}
  \begin{tabular}{cc}
    \hline
    優先順位 & 結合子 \\
    \hline
    1       & \keyw{comp}     \\
    2       & \keyw{iterate}  \\
    \hline
  \end{tabular}
\end{center}

\subsection{適用子のファミリー}

すべての適用子は等しい優先順位をもつ。

\Ruledef{適用子}{
  \Ruleref{部分列}
% \dsep \Ruleref{tuple constructor}
% \dsep \Ruleref{組構成子}
  \dsep \Ruleref{適用}
  \dsep \Ruleref{関数型インスタンス化}
  \dsep \Ruleref{項目選択}
  }

\Rule{部分列}{
  \Ruleref{式}, \Lit{(}, \Ruleref{式}, \Lit{,}, \Lit{\Range},
  \Lit{,}, \lfeed
  \Ruleref{式}, \Lit{)}
  }

\Rule{適用}{
  \Ruleref{式}, \Lit{(}, \OptPt{\Ruleref{式リスト}}, \Lit{)}
  }

\Rule{関数型インスタンス化}{
  \Ruleref{式}, \Lit{[}, \Ruleref{型}, \SeqPt{\Lit{,}, \Ruleref{型}}, \Lit{]}
  }

\Rule{項目選択}{
  \Ruleref{式}, \Lit{.}, \Ruleref{識別子} 
  }

\subsection{評価子のファミリー}

評価子のファミリーは、それらが用いられている式の型に従い、9つのグループに区分けされる。

\Ruledef{評価子}{
  \Ruleref{算術前置演算子} \dsep
  \Ruleref{集合前置演算子} \dsep
  \Ruleref{列前置演算子} \dsep
  \Ruleref{写像前置演算子} \dsep
  \Ruleref{逆写像} \dsep
  \Ruleref{算術中置演算子} \dsep
  \Ruleref{集合中置演算子} \dsep
  \Ruleref{列中置演算子} \dsep
  \Ruleref{写像中置演算子}
  }

\Ruledef{算術前置演算子}{
  \Lit{+} \dsepl
  \Lit{-} \dsepl
  \Lop{abs} \dsepl
  \Lop{floor}
  }

\Ruledef{集合前置演算子}{
  \Lop{card} \dsepl
  \Lop{power} \dsepl
  \Lop{dunion} \dsepl
  \Lop{dinter}
  }

\Ruledef{列前置演算子}{
  \Lop{hd} \dsepl
  \Lop{tl} \dsepl
  \Lop{len} \dsep
  \Lop{inds} \dsepl
  \Lop{elems} \dsepl
  \Lop{conc}
  }

\Ruledef{写像前置演算子}{
  \Lop{dom} \dsepl
  \Lop{rng} \dsepl
  \Lop{merge} \dsepl
  \Lop{inverse}
  }

\Ruledef{算術中置演算子}{
  \Lit{+} \dsepl
  \Lit{-} \dsepl
  \Lit{*} \dsepl
  \Lit{/} \dsepl
  \Lop{rem} \dsepl
  \Lop{mod} \dsepl
  \Lop{div}
  }

\Ruledef{集合中置演算子}{
  \Lop{union} \dsepl
  \Lop{inter} \dsepl
  \Lit{\char'134}
  }

\Ruledef{列中置演算子}{
  \Lit{\char'136}
  }

\Ruledef{写像中置演算子}{
  \Lop{munion} \dsepl
  \Lit{++} \dsepl
  \Lit{<:} \dsepl
  \Lit{<-:} \dsepl
  \Lit{:>} \dsepl
  \Lit{:->}
  }

\noindent 優先順位はアナログの演算子のパターンを追いかける。以下の表においてファミリーは定義されている。

\blankline
\begin{center}
  \begin{tabular}{ccccc}
    \hline
    優先順位 & 算術       & 集合           & 写像                & 列 \\
    1                & {\tt + -}        & \keyw{union} \verb+\+ & \keyw{munion} {\tt ++} & \verb+^+ \\
    2                & \verb+*+ {\tt /} & \keyw{inter}          &                        & \\
                     & \keyw{rem}       &                       &                        & \\
                     & \keyw{mod}       &                       &                        & \\
                     & \keyw{div}       &                       &                        & \\
    3                &                  &                       & \keyw{inverse}         & \\
    4                &                  &                       & {\tt <: <-:}           & \\
    5                &                  &                       & {\tt :> :->}           & \\
    6                & (単項) {\tt +}  & \keyw{card}           & \keyw{dom}             & \keyw{len}         \\
                     & (単項) {\tt -}  & \keyw{power}          & \keyw{rng}             & \keyw{elems}       \\
                     & \keyw{abs}       & \keyw{dinter}         & \keyw{merge}           & \keyw{hd} \keyw{tl} \\
                     & \keyw{floor}     & \keyw{dunion}         &                        & \keyw{conc}        \\
                     &                  &                       &                        & \keyw{inds}        \\
    \hline
  \end{tabular}
\end{center}

\subsection{関係子のファミリー}

このファミリーは、結果値が\keyw{bool}型であるすべての関係演算子を含む。

\Ruledef{関係子}{
  \Ruleref{関係中置演算子} \dsepl \Ruleref{集合関係演算子}
  }

\Ruledef{関係中置演算子}{
  \Lit{=} \dsepl
  \Lit{<>} \dsepl
  \Lit{<} \dsepl
  \Lit{<=} \dsepl
  \Lit{>} \dsepl
  \Lit{>=}
  }

\Ruledef{集合関係演算子}{
  \Lop{subset} \dsepl
  \Lop{psubset} \dsepl
  \Lop{in set} \dsepl
  \Lop{not in set}
  }

\blankline
\begin{center}
  \begin{tabular}{ccc}
    \hline
    優先順位 & 関係子 \\
    \hline
    1       & {\tt <=}        & {\tt <}         \\
            & {\tt >=}        & {\tt >}         \\
            & {\tt =}         & {\tt <>}        \\
            & \keyw{subset}   & \keyw{psubset}  \\
            & \keyw{in set}   & \keyw{not in set}\\
    \hline \\
  \end{tabular}
\end{center}

\noindent 関係子ファミリーのすべての演算子は等しい優先順位をもつ。タイプしていくということが、これらを隣り合わせに用いるとき意味をもたせる方法のないことを語るものである。

\subsection{連結子のファミリー}

このファミリーは、結果が\keyw{bool}型であるすべての論理演算子を含む。

\Ruledef{連結子}{
  \Ruleref{論理前置演算子} \dsepl \Ruleref{論理中置演算子}
  }

\Ruledef{論理前置演算子}{
  \Lop{not}
  }

\Ruledef{論理中置演算子}{
  \Lop{and} \dsepl
  \Lop{or} \dsepl
  \Lit{=>} \dsepl
  \Lit{<=>}
  }

\blankline
\begin{center}
  \begin{tabular}{cc}
    \hline
    優先順位 & 連結子 \\ \hline
    1                & {\tt <=>}      \\
    2                & {\tt =>}  \\
    3                & \keyw{or}       \\
    4                & \keyw{and}     \\
    5                & \keyw{not}      \\
    \hline
  \end{tabular}
\end{center}

\subsection{構成子のファミリー}

このファミリーは値を構成するために用いられるすべての演算子を含む。 
これらの優先順は、演算子の暗黙部である括弧によってかまたは構文によって与えられる。

\subsection{グループ化}\label{grouping}

2項演算子の演算対象のグループ化は以下の通り:

\begin{list}{\bf no label!}{%
    \def\mylabel#1{\hspace\labelsep #1\hfill}
    \let\makelabel\mylabel
    \settowidth{\labelwidth}{Constructors: }
    \setlength{\leftmargin}{\labelwidth}
    \addtolength{\leftmargin}{2\labelsep}
    }
\item[結合子:] 右グループ化
\item[適用子:] 左グループ化
\item[連結子:]  `{\tt =>}' 演算子は右グループ化 \\ 他の演算子は組み合わされるもののため、グループ化の左右は同等である
\item[評価子:] 左グループ化\footnote{ 右グループ化を行う ``写像定義域限定'' および ``写像定義域削減'' 演算子を除く（これは標準ではない）}.
\item[関係子:] グループ化は行わない、意味をなさないからである
\item[構成子:] グループ化は行わない、意味をなさないからである
\end{list}

\subsection{型演算子}\label{preceedence}

型演算子は独自の優先順位をもち、以下の通り:
\begin{enumerate}
\item 関数型: {\tt ->, +>} (右グループ化).
\item 合併型: {\tt |} (左グループ化).
\item 他の2項型演算子: \verb+*+ (グループ化なし).
\item 写像型: \keyw{map} \ldots \keyw{to} \ldots および \keyw{inmap} \ldots
  \keyw{to} \ldots\ (右グループ化).%\nonstandard{0}
\item 単項型演算子: \keyw{seq of}, \keyw{seq1 of}, \keyw{set of}.
\end{enumerate}

\section{2つの具象構文間の相違}\label{sec:diff}

以下は数学構文とASCII構文との間で異なる記号のリストである:\\
%\samepage
%\begin{center}
\begin{longtable}{|l|l|}\hline
 \ldots$\Gmap$\ldots & {\tt map ... to ...} \kill
 数学構文 & ASCII構文  \\ \hline\hline
\endhead
\hline
\endfoot
 $\Dot$            & {\tt\char'046} \\
 $\Mult$              & {\tt *}        \\
 $\Le$            & {\tt <=}        \\
 $\Ge$            & {\tt >=}        \\
 $\Neq$            & {\tt <>}       \\
 $\Oto$            & {\tt ==>}      \\
 $\To$             & {\tt ->}       \\
 $\Implies$     & {\tt =>}          \\
 $\Equiv$ & {\tt <=>}               \\
 $\Mapsto$         & {\tt |->}       \\
 $\Fdef$           & {\tt ==}        \\
 $\Iterate$        & {\tt **}        \\
 $\Override$       & {\tt ++}        \\
 $\Mapmerge$         & {\tt munion} \\
 $\Dto$            & {\tt <:}                           \\
 $\Rto$            & {\tt :>}                          \\
 $\Dby$            & {\tt <-:}                          \\
 $\Rby$            & {\tt :->}                         \\
 $\Psubset$         & {\tt psubset}                     \\
 $\Subset$       & {\tt subset}                         \\
 $\Sconc$          & {\tt\char'136}                     \\
 $\Dinter$          & {\tt dinter}                      \\
 $\Dunion$          & {\tt dunion}                      \\
 $\Power$          & {\tt power}                        \\
 \ldots$\Set$            & {\tt set of ...}                    \\
 \ldots$\Seq*$              & {\tt seq of ...}                 \\
 \ldots$\Seq+$              & {\tt seq1 of ...}                 \\
 \ldots$\Gmap$\ldots           & {\tt map ... to ...}                 \\
 \ldots$\Bmap$\ldots           & {\tt inmap ... to ...}                 \\
 $\Muop$           & {\tt mu}                           \\
 $\Bool$           & {\tt bool}                         \\
 $\Nat$            & {\tt nat}                          \\
 $\Int$            & {\tt int}                          \\
 $\Real$           & {\tt real}                         \\
 $\Not$            & {\tt not}                          \\
 $\Inter$          & {\tt inter}                        \\
 $\Union$          & {\tt union}                        \\
 $\In$             & {\tt in set}                       \\
 $\Notin$          & {\tt not in set}                   \\
 $\And$            & {\tt and}                          \\
 $\Or$             & {\tt or}                           \\
 $\All$            & {\tt forall}                       \\
 $\Exists$         & {\tt exists}                       \\
 $\Exists!$        & {\tt exists1}                      \\
 $\Lambdaop$       & {\tt lambda} \\
 $\Iotaop$         & {\tt iota} \\
 $\ldots\Inverse$  & {\tt inverse ...} \\
%#ifdef VDMPP
% $\kWeave$         & {\tt w\_} \\
% $\kTraceset$      & {\tt t\_} \\
% $\kAlphabet$      & {\tt a\_} \\
%#endif VDMPP
\hline
\end{longtable}
% \end{center}

\newpage

\section{標準ライブラリ}\label{stdlib}\index{Standard libraries}\index{library}\index{Math}\index{IO}

\subsection{数学ライブラリ}
%When more than just the Math is available name should be given to each library by \subsubsection*

数学ライブラリは \ifthenelse{\boolean{VDMsl}}{{\tt math.vdm}}{{\tt math.vpp}} ファイルに定義されている。
以下の数学関数を提供する:

\begin{center}
\begin{tabular}{|l|l|p{6cm}|}\hline
\multicolumn{2}{|l|}{\bf 関数} & \bf 事前条件\\ \hline
\verb/sin: real +> real/ & Sine &  \index{Sine} \\ \hline
\verb/cos: real +> real/ & Cosine &  \index{Cosine} \\ \hline
\verb/tan: real -> real/ & Tangent & 引数は $^\pi\!/\!_2$ の整数倍でない\index{Tangent} \\ \hline 
\verb/cot: real -> real/ & Cotangent & 引数は $\pi$ の整数倍でない\index{Cotangent} \\ \hline
\verb/asin: real -> real/ & Inverse sine & 引数は-1から1の間(両端を含む)にない
                                           \index{Inverse sine}\\ \hline
\verb/acos: real -> real/ & Inverse cosine & 引数は-1から1の間(両端を含む)にない
                                      \index{Inverse cosine}\\ \hline
\verb/atan:real +> real/ & Inverse tangent & \index{Inverse tangent}\\ \hline
\verb/acot:real +> real/ & Inverse cotangent & 引数は0でない
					\index{Inverse cotangent}\\ \hline
\verb/sqrt: real -> real/ & 平方根 & 引数は負でない
                                          \index{平方根}\\ \hline
\verb/exp: real +> real/ & eを底とする指数関数 & 
                                          \index{指数関数}\\ \hline
\verb/ln: real +> real/ & 自然対数& 引数は正
                                          \index{自然対数}\\ \hline
\verb/log: real +> real/ & 対数 & 引数は正
                                          \index{対数}\\ \hline
\verb/srand: int ==> ()/ & 乱数の種(seed)初期化 & 引数は-1以上
                                          \index{乱数の種(seed)初期化}\\ \hline
\verb/rand: int ==> int/ & 擬似乱数生成 & 引数は0より大きい乱数最大値
                                          \index{擬似乱数生成}\\ \hline

\end{tabular}
\end{center}

また次の値が与えられる:

\begin{quote}
\texttt{pi} = 3.14159265358979323846\index{pi}
\end{quote}

関数が、ありうる事前条件を満たさないような引数とともに適用される場合に、適当な\vdmslpp{\vdmsl}{\vdmpp} 値、{\tt Inf} (無限値、たとえば\ {\tt  tan(pi/2)}) および {\tt NaN} (数でない値、たとえば\ {\tt sqrt (-1)})、でない値を返すであろう。


% \subsubsection{Using the Math Standard Library with Flat Specifications}%
% \index{Math!use with flat specifications}
% 
% To use the standard library in a flat specification, the library file 
% \begin{quote}
% \verb+$TOOLBOXHOME/stdlib/mathflat.vdm+
% \end{quote}
% should be added to the
% current project. Functions from the standard library may then be
% accessed directly as the example below demonstrates:
% \begin{alltt}
% \keyw{types}
% 
% coord :: x : \keyw{real}
%          y : \keyw{real}
% 
% \keyw{functions}
% 
% -- euclidean metric between two points
% dist : coord * coord -> \keyw{real}
% dist (c1,c2) ==
%   sqrt((c1.x - c2.x) * (c1.x - c2.x) +
%        (c1.y - c2.y) * (c1.y - c2.y));
% 
% 
% -- outputs angle of line joining coord with origin
% -- from horizontal, in degrees
% angle : coord -> \keyw{real}
% angle (c) ==
%   atan (c.y / c.x) * 360 / ( 2 * pi)
% \end{alltt}
% 
% \subsubsection{Using the Math Standard Library with Modular Specifications}%
% \index{Math!use with modular specifications}
% 
モジュールの仕様記述内で標準ライブラリを使用する場合、以下のライブラリファイルを
\begin{quote}
\verb+$TOOLBOXHOME/stdlib/math.vdm+
\end{quote}
現在のプロジェクトに追加すべきである。
これは \texttt{MATH}モジュールから成り立つ。
このライブラリからの関数は、
必要に応じてそれらをモジュールに輸入することによって、このライブラリからの関数はいつもの通りにアクセス可能になるだろう。
以下の例で紹介する:

\begin{alltt}
\keyw{module} UseLib

  \keyw{imports}
    \keyw{from} MATH \keyw{all}

  \keyw{definitions}

  \keyw{types}

  coord :: x : \keyw{real}
           y : \keyw{real}

  \keyw{functions}

  -- euclidean metric between two points
  dist : coord * coord -> \keyw{real}
  dist (c1,c2) ==
    MATH`sqrt((c1.x - c2.x) * (c1.x - c2.x) +
              (c1.y - c2.y) * (c1.y - c2.y));

  -- outputs angle of line joining coord with origin
  -- from horizontal, in degrees
  angle : coord -> \keyw{real}
  angle (c) ==
    MATH`atan (c.y / c.x) * 360 / ( 2 * MATH`pi)

\keyw{end} UseLib
\end{alltt}


\subsection{IOライブラリ}\index{IO}

 IO ライブラリは\ifthenelse{\boolean{VDMsl}}{{\tt io.vdm}}{{\tt io.vpp}} ファイルで定義され、 \verb+$TOOLBOXHOME/stdlib/+ ディレクトリに置かれている。
以下にリストされたIO 関数と操作が提供される。
各々の read/write 関数と操作は、 相当するIO行為の成功(\keyw{true}) または失敗(\keyw{false})を表すブール値 (またはブール構成要素をもつ組) を返す。

\begin{description}
\item[\texttt{writeval[@p]:[@p] +> bool}] \mbox{}\\
  この関数はASCII形式でのVDM値を標準出力に書き出す。
 事前条件はない。
\item[\texttt{fwriteval[@p]:seq1 of char * @p * filedirective +>
    bool}] \mbox{}\\
 この関数はASCII形式での VDM値 (第2引数)を、第1引数に文字列で指定された名称のファイルに書き出す。 
第3パラメーターは以下のように定義された型 \texttt{filedirective} をもつ:
  \begin{verbatim}
    filedirective = <start>|<append> 
  \end{verbatim}
  \texttt{<start>} が用いられた場合、存在するファイルは (あった場合には) 上書される; \texttt{<append>} が用いられた場合、出力は存在するファイルの最後に付け足されすでに存在しているものがなければ新しいファイルが生成される。 
事前条件はない。
\item[\texttt{freadval[@p]:seq1 of char +> bool * [@p]}] \mbox{}\\
この関数はASCII形式の VDM値を、最初の引数の文字列で指定されたファイルから読み取る。
事前条件はない。
関数は2つを返し、第1構成要素は読取の成功を示し、第2構成要素は読取が成功した場合の読み取られた値を示す。
\item[\texttt{echo: seq of char ==> bool}] \mbox{}\\
  この操作は与えられたテキストを標準出力に書き出す。
囲みのダブルクォートは取り除かれ、バックスラッシュ文字が \hypertarget{rule:escape sequence}{escape sequences}として翻訳される。
事前条件はない。
\item[\texttt{fecho: seq of char * seq of char * [filedirective] ==> bool}]
  \mbox{}\\
 この操作は \texttt{echo} に似ているが、標準出力ではなくファイルに書き出す。 
 \texttt{filedirective} パラメーターは \texttt{fwriteval} に対するものとして翻訳されるべきである。 
この操作に対する事前条件は、ファイル名称として空列が与えられた場合、テキストは標準出力に書かれるので \texttt{[filedirective]}引数は\keyw{nil}であるべきということである。 
\item[\texttt{ferror:()  ==> seq of char}]
  read/write関数と操作は、エラーが起きた場合にfalse を返す。
この場合は内部エラー列がセットされる。 
この操作はこの文字列を返しそれを\texttt{""}にセットする。
\end{description}

IO ライブラリの使用例として、ページヒットのログを保守するwebサーバーを考えよう:

\begin{alltt}
  module LoggingWebServer

    \keyw{imports}
      \keyw{from} IO \keyw{all}

    \keyw{exports} \keyw{all}

    \keyw{definitions}

    \keyw{values}
      logfilename : seq1 of char = "serverlog"

    \keyw{functions}
      URLtoString : URL -> \keyw{seq} \keyw{of} \keyw{char}
      URLtoString = ...

    \keyw{operations}
      RetrieveURL : URL ==> File
      RetrieveURL(url) ==
        (\keyw{def} - = IO`fecho(logfilename, URLtoString(url)^\verb+"\n"+, <append>);
         ... 
        );

      ResetLog : () ==> \keyw{bool}
      ResetLog() ==
        IO`fecho(logfilename,\verb+"\n"+,<start>)

  \keyw{end} LoggingWebServer
\end{alltt}

\subsection{VDMUtilライブラリ}\index{VDMUtil}

VDMUtilライブラリは、\ifthenelse{\boolean{VDMsl}}{{\tt VDMUtil.vdm}}{{\tt VDMUtil.vpp}}ファイルに定義され、
\verb+$TOOLBOXHOME/stdlib/+に配置されている。
VDMUtilライブラリは、以下のリストにあるようなVDMのユーティリティを関数や操作として提供する。

\begin{description}
\item[\texttt{set2seq[@T]:set of @T +> seq of @T}] \mbox{}\\
この関数は、任意の型を持つ集合を簡単に列に変換することができる。

\item[\texttt{get\_file\_pos: () +> [seq of char * nat
* nat * seq of char * seq of char]}] \mbox{}\\
この関数は、ソースの特定部分のコンテキスト情報（ファイル名、行番号、クラス名、関数・操作名）を抽出することができる。

\item[\texttt{P: () +> [seq of char * nat
* nat * seq of char * seq of char]}] \mbox{}\\
この関数は、get\_file\_pos関数と同じで、関数名が短い点だけが異なる。

\item[\texttt{val2seq\_of\_char[@T]: @T +> seq of char}] \mbox{}\\
この関数は、任意の値を文字列に変換することができる。

\item[\texttt{seq\_of\_char2val[@p]:seq1 of char -> bool * [@p]}] \mbox{}\\
この関数は、文字列をVDMの任意の値に変換することができる。

\item[\texttt{cast[@T1, @T2]: @T1 -> [@T2]}] \mbox{}\\
この関数は、narrow式と同じ型変換を行う。
過去の版との互換性のために存在し、今後、新たに使用する必要はない。


\item[\texttt{classname[@T]: @T -> [seq1 of char]}] \mbox{}\\
インスタンス・オブジェクトのクラス名を得る。

\item[\texttt{char2code: char -> nat}] \mbox{}\\
文字から、そのUTF16コードの値を得る。

\item[\texttt{code2char: nat -> char}] \mbox{}\\
UTF16コードの値から、文字を得る。

\item[\texttt{current\_time: () ==> nat}] \mbox{}\\
1970年1月1日からのミリ秒形式で、現在時間を得る。

\end{description}
% #ifdef VDMPP
% 
% \begin{alltt}
% class VDMUtil
% 
% -- 	VDMTools STANDARD LIBRARY: MiscUtils
% --      --------------------------------------------
% -- 
% -- Standard library for the VDMTools Interpreter. When the interpreter
% -- evaluates the preliminary functions/operations in this file,
% -- corresponding internal functions is called instead of issuing a run
% -- time error. Signatures should not be changed, as well as name of
% -- module (VDM-SL) or class (VDM++). Pre/post conditions is 
% -- fully user customisable. 
% -- Dont care's may NOT be used in the parameter lists.
% 
% functions
% -- Converts a set argument into a sequence in non-deterministic order.
% static public
% set2seq[@T] : set of @T +> seq of @T
% set2seq(x) == is not yet specified;
% 
% -- Returns a context information tuple which represents
% -- (file_name * line_num * column_num * module_name * fnop_name) of corresponding source text
% static public
% get_file_pos : () +> [ seq of char * nat * nat * seq of char * seq of char ]
% get_file_pos() == is not yet specified;
% 
% -- (file_name * line_num * column_num * module_name * fnop_name) of corresponding source text
% static public
% P : () +> [ seq of char * nat * nat * seq of char * seq of char ]
% P() == is not yet specified;
% 
% -- Converts a VDM value into a seq of char.
% static public
% val2seq_of_char[@T] : @T +> seq of char
% val2seq_of_char(x) == is not yet specified;
% 
% -- Converts VDM value in ASCII format into a VDM value
% -- RESULT.#1 = false implies a conversion failure
% static public
% seq_of_char2val[@p]:seq1 of char -> bool * [@p]
% seq_of_char2val(s) ==
%   is not yet specified
%   post let mk_(b,t) = RESULT in not b => t = nil;
% 
% -- Cast value 
% static public
% cast[@T1, @T2] : @T1 -> @T2
% cast(s) == is not yet specified
%   pre is_(s, @T2);
% 
% -- Clone value 
% static public
% clone[@T] : @T -> @T
% clone(s) == is not yet specified;
% 
% -- Get class name
% static public
% classname[@T] : @T -> [seq1 of char]
% classname(s) == is not yet specified;
% 
% -- Convert a char into a UTF16 code value.
% static public
% char2code: char -> nat
% char2code(c) == is not yet specified;
% 
% -- Convert a UTF16 code value into a char.
% static public
% code2char: nat -> char
% code2char(c) == is not yet specified;
% 
% operations
% -- Get current time in miliseconds since Jan. 1, 1970
% static public
% current_time: () ==> nat
% current_time() == is not yet specified;
% end VDMUtil
% \end{alltt}
% #endif VDMPP
% 
% #ifdef 
% \begin{alltt}
% module VDMUtil
% exports all
% definitions
% 
% -- 	VDMTools STANDARD LIBRARY: MiscUtils
% --      --------------------------------------------
% -- 
% -- Standard library for the VDMTools Interpreter. When the interpreter
% -- evaluates the preliminary functions/operations in this file,
% -- corresponding internal functions is called instead of issuing a run
% -- time error. Signatures should not be changed, as well as name of
% -- module (VDM-SL) or class (VDM++). Pre/post conditions is 
% -- fully user customisable. 
% -- Dont care's may NOT be used in the parameter lists.
% 
% functions
% -- Converts a set argument into a sequence in non-deterministic order.
% set2seq[@T] : set of @T +> seq of @T
% set2seq(x) == is not yet specified;
% 
% -- Returns a context information tuple which represents
% -- (file_name * line_num * column_num * module_name * fnop_name) of corresponding source text
% get_file_pos : () +> [ seq of char * nat * nat * seq of char * seq of char ]
% get_file_pos() == is not yet specified;
% 
% -- (file_name * line_num * column_num * module_name * fnop_name) of corresponding source text
% P : () +> [ seq of char * nat * nat * seq of char * seq of char ]
% P() == is not yet specified;
% 
% -- Converts a VDM value into a seq of char.
% val2seq_of_char[@T] : @T +> seq of char
% val2seq_of_char(x) == is not yet specified;
% 
% -- Converts VDM value in ASCII format into a VDM value
% -- RESULT.#1 = false implies a conversion failure
% seq_of_char2val[@p]:seq1 of char -> bool * [@p]
% seq_of_char2val(s) ==
%   is not yet specified
%   post let mk_(b,t) = RESULT in not b => t = nil;
% 
% -- Cast value 
% cast[@T1, @T2] : @T1 -> @T2
% cast(s) == is not yet specified
%   pre is_(s, @T2);
% 
% -- Convert a char into a UTF16 code value.
% char2code: char -> nat
% char2code(c) == is not yet specified;
% 
% -- Convert a UTF16 code value into a char.
% code2char: nat -> char
% code2char(c) == is not yet specified;
% 
% operations
% -- Get current time in miliseconds since Jan. 1, 1970
% current_time: () ==> nat
% current_time() == is not yet specified;
% end VDMUtil\end{alltt}
% #endif 

\newpage
\addcontentsline{toc}{section}{Index}
\printindex

\end{document}


