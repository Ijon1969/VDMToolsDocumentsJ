{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}{\f6\fmodern\fcharset0\fprq1{\*\panose 00000000000000000000}Courier;}{\f16\froman\fcharset238\fprq2 Times New Roman CE;}{\f17\froman\fcharset204\fprq2 Times New Roman Cyr;}
{\f19\froman\fcharset161\fprq2 Times New Roman Greek;}{\f20\froman\fcharset162\fprq2 Times New Roman Tur;}{\f21\froman\fcharset186\fprq2 Times New Roman Baltic;}{\f22\fswiss\fcharset238\fprq2 Arial CE;}{\f23\fswiss\fcharset204\fprq2 Arial Cyr;}
{\f25\fswiss\fcharset161\fprq2 Arial Greek;}{\f26\fswiss\fcharset162\fprq2 Arial Tur;}{\f27\fswiss\fcharset186\fprq2 Arial Baltic;}{\f28\fmodern\fcharset238\fprq1 Courier New CE;}{\f29\fmodern\fcharset204\fprq1 Courier New Cyr;}
{\f31\fmodern\fcharset161\fprq1 Courier New Greek;}{\f32\fmodern\fcharset162\fprq1 Courier New Tur;}{\f33\fmodern\fcharset186\fprq1 Courier New Baltic;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;
\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;
\red192\green192\blue192;}{\stylesheet{\nowidctlpar\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}{\s1\sb240\sa60\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 1;}{\*\cs10 \additive 
Default Paragraph Font;}{\s15\nowidctlpar\widctlpar\adjustright \shading2000 \f2\fs20\lang1024\cgrid \snext15 VDM;}{\*\cs16 \additive \f6\chshdng2000\chcfpat0\chcbpat0 \sbasedon10 VDM_COV;}{\*\cs17 \additive \f6\cf6\chshdng2000\chcfpat0\chcbpat0 
\sbasedon10 VDM_NCOV;}{\s18\nowidctlpar\widctlpar\adjustright \shading2000 \f2\fs20\lang1024\cgrid \sbasedon15 \snext18 VDM_TC_TABLE;}}{\info{\title A Sorting Example Illustrating Statements}{\author Peter Gorm Larsen}{\operator Peter Gorm Larsen}
{\creatim\yr2000\mo10\dy26\hr10\min5}{\revtim\yr2000\mo10\dy26\hr10\min6}{\version2}{\edmins0}{\nofpages4}{\nofwords568}{\nofchars3243}{\*\company SCSK}{\nofcharsws3982}{\vern71}}
\widowctrl\ftnbj\aenddoc\formshade\viewkind4\viewscale100\pgbrdrhead\pgbrdrfoot \fet0{\*\template C:\\Programmer\\Microsoft Office\\Templates\\VDM.dot}\sectd \linex0\headery709\footery709\colsx709\endnhere\sectdefaultcl {\*\pnseclvl1
\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5
\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang
{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \s1\sb240\sa60\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\kerning28\cgrid {A Sorting Example Illustrating Statements
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading2000 \f2\fs20\lang1024\cgrid {class St
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading2000 \f2\fs20\lang1024\cgrid {values
\par 
\par v15 = selection_sort([3,2,9,1,3]);
\par st1 = mk_(1,6,[3,2,-9,11,5,3])
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading2000 \f2\fs20\lang1024\cgrid {instance variables
\par   x:nat;
\par   y:nat;
\par   l:seq1 of nat;
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par 
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading2000 \f2\fs20\lang1024\cgrid {functions
\par 
\par min_index : seq1 of nat -> nat
\par min_index(l) ==
\par   if len l = 1
\par   then 1
\par   else let mi = min_index(tl l)
\par        in if l(mi+1) < hd l
\par           then mi+1
\par           else 1;
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading2000 \f2\fs20\lang1024\cgrid {permutation : seq of nat * seq of nat -> bool
\par permutation (l1,l2) ==
\par   exists m : inmap nat to nat &
\par     dom m = inds l1 and
\par     rng m = inds l2;
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading2000 \f2\fs20\lang1024\cgrid {-- convoluted example of let .. be .. st
\par --   forward ref to subsequence notation
\par remove : nat * seq of nat -> seq of nat
\par remove (x,l) ==
\par   let i in set inds l be st l(i) = x
\par   in l(1,...,i-1)^l(i+1,...,len l)
\par pre x in set elems l;
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading2000 \f2\fs20\lang1024\cgrid {selection_sort : seq of nat -> seq of nat
\par selection_sort (l) ==
\par   if l = []
\par   then []
\par   else let m in set elems l be st
\par          forall x in set elems l & m <= x
\par        in [m]^(selection_sort (remove(m,l)));
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading2000 \f2\fs20\lang1024\cgrid {-- conditional expressions
\par lmerge : seq of nat * seq of nat -> seq of nat
\par lmerge (s1,s2) ==
\par   if s1 = []
\par   then s2
\par   elseif s2 = []
\par   then s1
\par   elseif (hd s1) < (hd s2)
\par   then [hd s1]^(lmerge (tl s1, s2))
\par   else [hd s2]^(lmerge (s1, tl s2));
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading2000 \f2\fs20\lang1024\cgrid {mergesort : seq of nat -> seq of nat
\par mergesort (l) ==
\par   cases l:
\par     [] -> [],
\par     l1^l2 -> lmerge (mergesort(l1), mergesort(l2))
\par   end;
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading2000 \f2\fs20\lang1024\cgrid {quicksort : seq of nat -> seq of nat
\par quicksort (l) ==
\par   cases l:
\par     [] -> [],
\par     -^[x]^- -> quicksort ([y | y in set elems l & y < x]) ^ [x] ^
\par                quicksort ([y | y in set elems l & y > x])
\par   end
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading2000 \f2\fs20\lang1024\cgrid {-- see also print_Expr (lang.vdm) for record patterns
\par operations
\par 
\par setup : nat * nat * seq1 of nat ==> ()
\par setup (x',y',l') ==
\par   ( x := x';
\par     y := y';
\par     l := l'
\par   );
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading2000 \f2\fs20\lang1024\cgrid {Swap : () ==> ()
\par Swap () ==
\par   (dcl temp: nat := x;
\par    x := y;
\par    y := temp
\par   );
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading2000 \f2\fs20\lang1024\cgrid {-- assignment to state designator
\par SelectionSort : nat ==> ()
\par SelectionSort (i) ==
\par   if i < len l
\par   then (dcl temp: nat;
\par         dcl mi : nat := min_index(l(i,...,len l)) + i - 1;
\par        
\par         temp := l(mi);
\par         l(mi) := l(i);
\par         l(i) := temp;
\par         SelectionSort(i+1)
\par        );
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading2000 \f2\fs20\lang1024\cgrid {-- for loops
\par BubbleSort : seq of nat ==> seq of nat
\par BubbleSort (k) ==
\par   (dcl sorted_list : seq of nat := k;
\par    for i = len k to 1 by -1 do
\par      for j = 1 to i-1 do
\par        if sorted_list(j) > sorted_list(j+1)
\par        then (dcl temp:nat := sorted_list(j);
\par              sorted_list(j) := sorted_list(j+1);
\par              sorted_list(j+1) := temp
\par             );
\par    return sorted_list
\par    );
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading2000 \f2\fs20\lang1024\cgrid {Remove : (seq of nat) * nat ==> seq of nat
\par Remove (k,z) ==
\par   (dcl nk : seq of nat := [];
\par    for i in k do
\par      if i <> z
\par      then nk := nk^[i];
\par    return nk
\par   );
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading2000 \f2\fs20\lang1024\cgrid {-- non-deterministic statement
\par BubbleMin : () ==> ()
\par BubbleMin () ==
\par   (dcl z:nat := x;
\par    dcl m:nat := l(z);
\par    for i = x to y do
\par      if l(i) < m
\par      then ( m := l(i);
\par             z := i
\par           );
\par    (dcl temp:nat;
\par     temp := l(x);
\par     l(x) := l(z);
\par     l(z) := temp;
\par     x := x+1
\par    )
\par   );
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading2000 \f2\fs20\lang1024\cgrid {BubbleMax : () ==> ()
\par BubbleMax () ==
\par   (dcl z:nat := x;
\par    dcl m:nat := l(z);
\par    for i = x to y do
\par      if l(i) > m
\par      then ( m := l(i);
\par             z := i
\par           );
\par    (dcl temp:nat;
\par     temp := l(y);
\par     l(y) := l(z);
\par     l(z) := temp;
\par     y := y-1
\par    )
\par   );
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading2000 \f2\fs20\lang1024\cgrid {Sort: () ==> ()
\par Sort () ==
\par   while x < y do
\par     ||(BubbleMin(), BubbleMax());
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading2000 \f2\fs20\lang1024\cgrid {-- identity statement
\par Remove2 : (seq of nat) * nat ==> seq of nat
\par Remove2 (k,z) ==
\par   (dcl nk : seq of nat := [];
\par    for i in k do
\par      if i <> z
\par      then nk := nk^[i]
\par      else skip;
\par    return nk
\par   );
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading2000 \f2\fs20\lang1024\cgrid {-- specification statement
\par Sort2 : () ==> ()
\par Sort2 () ==
\par   while x < y do
\par     || (BubbleMin(),
\par         [ext wr l : seq1 of nat
\par              wr y : nat
\par              rd x : nat
\par          pre x < y
\par          post y < y~ and 
\par               permutation (l~(x,...,y~),l(x,...,y~)) and
\par               forall i in set \{x,...,y\} & l(i) < l(y~)]
\par        );
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading2000 \f2\fs20\lang1024\cgrid {o1 : () ==> ()
\par o1 () == is not yet specified;
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading2000 \f2\fs20\lang1024\cgrid {o2 : () ==> ()
\par o2 () == is not yet specified
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs20\cgrid {   
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading2000 \f2\fs20\lang1024\cgrid {end St
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }{\lang1030 
\par }}
