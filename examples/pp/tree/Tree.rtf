{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}{\f6\fmodern\fcharset0\fprq1{\*\panose 00000000000000000000}Courier;}{\f16\froman\fcharset238\fprq2 Times New Roman CE;}{\f17\froman\fcharset204\fprq2 Times New Roman Cyr;}
{\f19\froman\fcharset161\fprq2 Times New Roman Greek;}{\f20\froman\fcharset162\fprq2 Times New Roman Tur;}{\f21\froman\fcharset186\fprq2 Times New Roman Baltic;}{\f22\fswiss\fcharset238\fprq2 Arial CE;}{\f23\fswiss\fcharset204\fprq2 Arial Cyr;}
{\f25\fswiss\fcharset161\fprq2 Arial Greek;}{\f26\fswiss\fcharset162\fprq2 Arial Tur;}{\f27\fswiss\fcharset186\fprq2 Arial Baltic;}{\f28\fmodern\fcharset238\fprq1 Courier New CE;}{\f29\fmodern\fcharset204\fprq1 Courier New Cyr;}
{\f31\fmodern\fcharset161\fprq1 Courier New Greek;}{\f32\fmodern\fcharset162\fprq1 Courier New Tur;}{\f33\fmodern\fcharset186\fprq1 Courier New Baltic;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;
\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;
\red192\green192\blue192;}{\stylesheet{\nowidctlpar\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}{\s1\sb240\sa60\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 1;}{\*\cs10 \additive 
Default Paragraph Font;}{\s15\nowidctlpar\widctlpar\adjustright \shading2000 \f2\fs20\lang1024\cgrid \snext15 VDM;}{\*\cs16 \additive \f6\chshdng2000\chcfpat0\chcbpat0 \sbasedon10 VDM_COV;}{\*\cs17 \additive \f6\cf6\chshdng2000\chcfpat0\chcbpat0 
\sbasedon10 VDM_NCOV;}{\s18\nowidctlpar\widctlpar\adjustright \shading2000 \f2\fs20\lang1024\cgrid \sbasedon15 \snext18 VDM_TC_TABLE;}{\s19\qj\nowidctlpar\widctlpar\adjustright \f2\fs20\lang2057\cgrid \sbasedon0 \snext19 Plain Text;}}{\info
{\title The Tree Class}{\author Peter Gorm Larsen}{\operator Peter Gorm Larsen}{\creatim\yr2000\mo10\dy26\hr10\min11}{\revtim\yr2000\mo10\dy26\hr10\min12}{\version1}{\edmins1}{\nofpages2}{\nofwords328}{\nofchars1870}{\*\company SCSK}{\nofcharsws2296}
{\vern71}}\paperw11900\paperh16840\margl1149\margr1149\margt1138\margb1138 \widowctrl\ftnbj\aenddoc\formshade\viewkind4\viewscale100\pgbrdrhead\pgbrdrfoot \fet0{\*\template C:\\Programmer\\Microsoft Office\\Templates\\VDM.dot}\sectd 
\linex0\headery709\footery709\colsx709\endnhere\sectdefaultcl {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4
\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}
{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \s1\sb240\sa60\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright 
\b\f1\fs28\kerning28\cgrid {The Tree Class
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading2000 \f2\fs20\lang1024\cgrid {class Tree
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading2000 \f2\fs20\lang1024\cgrid {  types
\par 
\par     protected 
\par     tree = <Empty> | node;
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs20\cgrid {    
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading2000 \f2\fs20\lang1024\cgrid {    public
\par     node :: lt: Tree
\par             nval : int
\par             rt : Tree
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading2000 \f2\fs20\lang1024\cgrid {  instance variables
\par     protected
\par     root: tree := <Empty>;
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par 
\par 
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading2000 \f2\fs20\lang1024\cgrid {  operations
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading2000 \f2\fs20\lang1024\cgrid {    protected
\par     nodes : () ==> set of node
\par     nodes () ==
\par       cases root:
\par         <Empty> -> return (\{\}),
\par         mk_node(lt,v,rt) -> return(lt.nodes() union \{v\} union rt.nodes())
\par       end ;
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading2000 \f2\fs20\lang1024\cgrid {    protected
\par     addRoot : int ==> ()
\par     addRoot (x) ==
\par       root := mk_node(new Tree(),x,new Tree());
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading2000 \f2\fs20\lang1024\cgrid {    protected
\par     rootval : () ==> int
\par     rootval () == return root.nval
\par     pre root <> <Empty>;
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading2000 \f2\fs20\lang1024\cgrid {    protected
\par     gettree : () ==> tree
\par     gettree () == return root;
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading2000 \f2\fs20\lang1024\cgrid {    protected
\par     leftBranch : () ==> Tree
\par     leftBranch () == return root.lt
\par     pre not isEmpty();
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading2000 \f2\fs20\lang1024\cgrid {    protected
\par     rightBranch : () ==> Tree
\par     rightBranch () == return root.rt
\par     pre not isEmpty();
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading2000 \f2\fs20\lang1024\cgrid {    protected
\par     isEmpty : () ==> bool
\par     isEmpty () == return (root = <Empty>);
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading2000 \f2\fs20\lang1024\cgrid {    breadth_first_search : () ==> seq of int 
\par     breadth_first_search () ==
\par        if isEmpty()
\par        then return []
\par        else 
\par          (dcl to_visit: Queue := new Queue();
\par           dcl visited : seq of int := [];
\par 
\par           to_visit.Enqueue(gettree());
\par   
\par           while (not to_visit.isEmpty()) do
\par             def curr_node = to_visit.Dequeue()
\par             in ( visited := visited^[curr_node.nval];
\par                  if not curr_node.lt.isEmpty()
\par                  then to_visit.Enqueue(curr_node.lt.gettree());
\par                  if not curr_node.lt.isEmpty()
\par                  then to_visit.Enqueue(curr_node.rt.gettree());
\par                );
\par           return (visited));
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading2000 \f2\fs20\lang1024\cgrid {    depth_first_search : () ==> seq of int
\par     depth_first_search () ==
\par       cases root:
\par          <Empty> -> return [],
\par          mk_node(lt,v,rt) -> let ln = lt.depth_first_search(),
\par                                  rn = rt.depth_first_search()
\par                              in return [v]^ln^rn
\par       end;
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading2000 \f2\fs20\lang1024\cgrid {    inorder : () ==> seq of int
\par     inorder () ==
\par       cases root:
\par         <Empty> -> return [],
\par         mk_node(lt,v,rt) -> let ln = lt.inorder(),
\par                                 rn = rt.inorder()
\par                             in return ln^[v]^rn
\par       end
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading2000 \f2\fs20\lang1024\cgrid {end Tree
\par }\pard\plain \s19\qj\nowidctlpar\widctlpar\adjustright \f2\fs20\lang2057\cgrid {    
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }{\lang1030 
\par }}
