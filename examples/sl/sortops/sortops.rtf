{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}{\f6\fmodern\fcharset0\fprq1{\*\panose 00000000000000000000}Courier;}{\f28\froman\fcharset238\fprq2 Times New Roman CE;}{\f29\froman\fcharset204\fprq2 Times New Roman Cyr;}
{\f31\froman\fcharset161\fprq2 Times New Roman Greek;}{\f32\froman\fcharset162\fprq2 Times New Roman Tur;}{\f33\froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\f34\froman\fcharset178\fprq2 Times New Roman (Arabic);}
{\f35\froman\fcharset186\fprq2 Times New Roman Baltic;}{\f36\fswiss\fcharset238\fprq2 Arial CE;}{\f37\fswiss\fcharset204\fprq2 Arial Cyr;}{\f39\fswiss\fcharset161\fprq2 Arial Greek;}{\f40\fswiss\fcharset162\fprq2 Arial Tur;}
{\f41\fswiss\fcharset177\fprq2 Arial (Hebrew);}{\f42\fswiss\fcharset178\fprq2 Arial (Arabic);}{\f43\fswiss\fcharset186\fprq2 Arial Baltic;}{\f44\fmodern\fcharset238\fprq1 Courier New CE;}{\f45\fmodern\fcharset204\fprq1 Courier New Cyr;}
{\f47\fmodern\fcharset161\fprq1 Courier New Greek;}{\f48\fmodern\fcharset162\fprq1 Courier New Tur;}{\f49\fmodern\fcharset177\fprq1 Courier New (Hebrew);}{\f50\fmodern\fcharset178\fprq1 Courier New (Arabic);}
{\f51\fmodern\fcharset186\fprq1 Courier New Baltic;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;
\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext0 Normal;}{\s1\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\adjustright\rin0\lin0\itap0 \b\f1\fs28\lang1033\langfe1033\kerning28\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext0 heading 1;}{\*
\cs10 \additive Default Paragraph Font;}{\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \shading1000 \f2\fs20\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 \snext15 VDM;}{\*\cs16 \additive \f6 \sbasedon10 VDM_COV;}{\*\cs17 
\additive \f6\cf6 \sbasedon10 VDM_NCOV;}{\s18\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \shading1000 \f2\fs20\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 \sbasedon15 \snext18 VDM_TC_TABLE;}{
\s19\qj \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \f2\fs20\lang2057\langfe1033\cgrid\langnp2057\langfenp1033 \sbasedon0 \snext19 Plain Text;}}{\info{\title More sorting algorithms}{\author peter}{\operator Peter Gorm Larsen }
{\creatim\yr1998\mo10\dy5\hr10\min19}{\revtim\yr2001\mo10\dy10\hr13\min14}{\version2}{\edmins47}{\nofpages4}{\nofwords635}{\nofchars3622}{\*\company SCSK}{\nofcharsws0}{\vern8247}}
\widowctrl\ftnbj\aenddoc\noxlattoyen\expshrtn\noultrlspc\dntblnsbdb\nospaceforul\hyphcaps0\formshade\horzdoc\dghspace120\dgvspace120\dghorigin1701\dgvorigin1984\dghshow0\dgvshow3\jcompress\viewkind4\viewscale100\pgbrdrhead\pgbrdrfoot\nolnhtadjtbl \fet0
\sectd \linex0\endnhere\sectdefaultcl {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4
\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}
{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain 
\s1\ql \li0\ri0\sb240\sa60\keepn\widctlpar\faauto\outlinelevel0\adjustright\rin0\lin0\itap0 \b\f1\fs28\lang1033\langfe1033\kerning28\cgrid\langnp1033\langfenp1033 {More sorting algorithms
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\fs20 
This file contains a number of alternative sorting examples primarily expressed using explicit operations. In contains examples for all different kinds of statements in VDM-SL.
\par }\pard\plain \s19\qj \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \f2\fs20\lang2057\langfe1033\cgrid\langnp2057\langfenp1033 {
\par }\pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \shading1000 \f2\fs20\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {values
\par 
\par v15 = selection_sort([3,2,9,1,3]);
\par st1 = mk_St(1,6,[3,2,-9,11,5,3])
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\fs20 
\par }\pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \shading1000 \f2\fs20\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {state St of
\par   x:nat
\par   y:nat
\par   l:seq1 of nat
\par init s == s =mk_St(0,0,[1])
\par end
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\fs20 
\par }\pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \shading1000 \f2\fs20\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {functions
\par 
\par min_index : seq1 of nat -> nat
\par min_index(l) ==
\par   if len l = 1
\par   then 1
\par   }{\lang1024\langfe1024\langnp1030 else let mi = min_index(tl l)
\par        }{in if l(mi+1) < hd l
\par           then mi+1
\par           else 1;
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\fs20 
\par }\pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \shading1000 \f2\fs20\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {permutation : seq of nat * seq of nat -> bool
\par permutation (l1,l2) ==
\par   exists m : inmap nat to nat &
\par     dom m = inds l1 and
\par     rng m = inds l2;
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\fs20 
\par This contains a convoluted example of let .. be .. st  forward ref to subsequence notation.
\par 
\par }\pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \shading1000 \f2\fs20\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {remove : nat * seq of nat -> seq of nat
\par remove (x,l) ==
\par   let i in set inds l be st l(i) = x
\par   in l(1,...,i-1)^l(i+1,...,len l)
\par pre x in set elems l;
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\fs20 
\par }\pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \shading1000 \f2\fs20\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {selection_sort : seq of nat -> seq of nat
\par selection_sort (l) ==
\par   if l = []
\par   then []
\par   else let m in set elems l be st
\par          forall x in set elems l & m <= x
\par        in [m]^(selection_sort (remove(m,l)));
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\fs20 
\par }\pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \shading1000 \f2\fs20\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {-- conditional expressions
\par lmerge : seq of nat * seq of nat -> seq of nat
\par lmerge (s1,s2) ==
\par   if s1 = []
\par   then s2
\par   elseif s2 = []
\par   then s1
\par   elseif (hd s1) < (hd s2)
\par   then [hd s1]^(lmerge (tl s1, s2))
\par   else [hd s2]^(lmerge (s1, tl s2));
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\fs20 
\par }\pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \shading1000 \f2\fs20\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {mergesort : seq of nat -> seq of nat
\par mergesort (l) ==
\par   cases l:
\par     }{\lang1024\langfe1024\langnp1030 [] -> [],
\par     l1^l2 -> lmerge (mergesort(l1), mergesort(l2))
\par   }{end;
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\fs20 
\par }\pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \shading1000 \f2\fs20\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {quicksort : seq of nat -> seq of nat
\par quicksort (l) ==
\par   cases l:
\par     [] -> [],
\par     -^[x]^- -> quicksort ([y | y in set elems l & y < x]) ^ [x] ^
\par                quicksort ([y | y in set elems l & y > x])
\par   end
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\fs20 
\par see also print_Expr (lang.vdm) for record patterns.
\par 
\par }\pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \shading1000 \f2\fs20\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {operations
\par 
\par setup : nat * nat * seq1 of nat ==> ()
\par setup (x',y',l') ==
\par   ( x := x';
\par     y := y';
\par     l := l'
\par   );
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\fs20 
\par }\pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \shading1000 \f2\fs20\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {Swap : () ==> ()
\par Swap () ==
\par   (dcl temp: nat := x;
\par    x := y;
\par    y := temp
\par   );
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\fs20 
\par }\pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \shading1000 \f2\fs20\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {-- assignment to state designator
\par SelectionSort : nat ==> ()
\par SelectionSort (i) ==
\par   if i < len l
\par   then (dcl temp: nat;
\par         }{\lang1024\langfe1024\langnp1030 dcl mi : nat := min_index(l(i,...,len l)) + i - 1;
\par        
\par         temp := l(mi);
\par         l(mi) := l(i);
\par         l(i) := temp;
\par         }{SelectionSort(i+1)
\par        );
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\fs20 
\par }\pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \shading1000 \f2\fs20\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {-- for loops
\par BubbleSort : seq of nat ==> seq of nat
\par BubbleSort (k) ==
\par   (dcl sorted_list : seq of nat := k;
\par    for i = len k to 1 by -1 do
\par      for j = 1 to i-1 do
\par        if sorted_list(j) > sorted_list(j+1)
\par        then (dcl temp:nat := sorted_list(j);
\par              sorted_list(j) := sorted_list(j+1);
\par              sorted_list(j+1) := temp
\par             );
\par    return sorted_list
\par    );
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\fs20 
\par }\pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \shading1000 \f2\fs20\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {Remove : (seq of nat) * nat ==> seq of nat
\par Remove (k,z) ==
\par   (dcl nk : seq of nat := [];
\par    for i in k do
\par      if i <> z
\par      then nk := nk^[i];
\par    return nk
\par   );
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\fs20 
\par }\pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \shading1000 \f2\fs20\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {-- non-deterministic statement
\par }{\lang1024\langfe1024\langnp1030 BubbleMin : () ==> ()
\par BubbleMin () ==
\par   (dcl z:nat := x;
\par    dcl m:nat := l(z);
\par    }{for i = x to y do
\par      if l(i) < m
\par      then ( m := l(i);
\par             }{\lang1024\langfe1024\langnp1030 z := i
\par           );
\par    (dcl temp:nat;
\par     }{temp := l(x);
\par     l(x) := l(z);
\par     l(z) := temp;
\par     x := x+1
\par    )
\par   );
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\fs20 
\par }\pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \shading1000 \f2\fs20\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {BubbleMax : () ==> ()
\par }{\lang1024\langfe1024\langnp1030 BubbleMax () ==
\par   (dcl z:nat := x;
\par    dcl m:nat := l(z);
\par    }{for i = x to y do
\par      if l(i) > m
\par      then ( m := l(i);
\par             }{\lang1024\langfe1024\langnp1030 z := i
\par           );
\par    (dcl temp:nat;
\par     }{temp := l(y);
\par     l(y) := l(z);
\par     l(z) := temp;
\par     y := y-1
\par    )
\par   );
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\fs20 
\par }\pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \shading1000 \f2\fs20\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {Sort: () ==> ()
\par Sort () ==
\par   while x < y do
\par     ||(BubbleMin(), BubbleMax());
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\fs20 
\par }\pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \shading1000 \f2\fs20\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {-- identity statement
\par Remove2 : (seq of nat) * nat ==> seq of nat
\par Remove2 (k,z) ==
\par   (dcl nk : seq of nat := [];
\par    for i in k do
\par      if i <> z
\par      then nk := nk^[i]
\par      else skip;
\par    return nk
\par   );
\par }\pard\plain \ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\fs20 
\par }\pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \shading1000 \f2\fs20\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1033 {-- specification statement
\par Sort2 : () ==> ()
\par Sort2 () ==
\par   while x < y do
\par     || (BubbleMin(),
\par         [ext wr l : seq1 of nat
\par              wr y : nat
\par              rd x : nat
\par          pre x < y
\par          post y < y~ and 
\par               permutation (l~(x,...,y~),l(x,...,y~)) and
\par               forall i in set \{x,...,y\} & l(i) < l(y~)]
\par        )
\par }\pard\plain \s19\qj \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \f2\fs20\lang2057\langfe1033\cgrid\langnp2057\langfenp1033 {   
\par }}
