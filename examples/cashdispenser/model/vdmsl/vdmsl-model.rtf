{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}{\f6\fmodern\fcharset0\fprq1{\*\panose 00000000000000000000}Courier;}
{\f34\froman\fcharset238\fprq2 Times New Roman CE;}{\f35\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f37\froman\fcharset161\fprq2 Times New Roman Greek;}{\f38\froman\fcharset162\fprq2 Times New Roman Tur;}
{\f39\froman\fcharset186\fprq2 Times New Roman Baltic;}{\f40\fswiss\fcharset238\fprq2 Arial CE;}{\f41\fswiss\fcharset204\fprq2 Arial Cyr;}{\f43\fswiss\fcharset161\fprq2 Arial Greek;}{\f44\fswiss\fcharset162\fprq2 Arial Tur;}
{\f45\fswiss\fcharset186\fprq2 Arial Baltic;}{\f46\fmodern\fcharset238\fprq1 Courier New CE;}{\f47\fmodern\fcharset204\fprq1 Courier New Cyr;}{\f49\fmodern\fcharset161\fprq1 Courier New Greek;}{\f50\fmodern\fcharset162\fprq1 Courier New Tur;}
{\f51\fmodern\fcharset186\fprq1 Courier New Baltic;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;
\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\nowidctlpar\widctlpar\adjustright \fs22\cgrid \snext0 
Normal;}{\s1\sb240\sa60\keepn\nowidctlpar\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 1;}{\*\cs10 \additive Default Paragraph Font;}{\s15\nowidctlpar\widctlpar\adjustright \shading1500\cbpat8 \f2\fs20\lang1024\cgrid 
\snext15 VDM;}{\*\cs16 \additive \f6 \sbasedon10 VDM_COV;}{\*\cs17 \additive \f6\cf16 \sbasedon10 VDM_NCOV;}{\s18\nowidctlpar\widctlpar\adjustright \shading1500\cbpat8 \f2\fs20\lang1024\cgrid \sbasedon15 \snext18 VDM_TC_TABLE;}}{\*\listtable
{\list\listtemplateid-752481470\listsimple{\listlevel\levelnfc23\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'01\u-4051 ?;}{\levelnumbers;}\f3\fbias0 \fi-360\li360\jclisttab\tx360 }{\listname ;}\listid1324620909}
{\list\listtemplateid-752481470\listsimple{\listlevel\levelnfc23\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'01\u-4051 ?;}{\levelnumbers;}\f3\fbias0 \fi-360\li360\jclisttab\tx360 }{\listname ;}\listid1724937575}}
{\*\listoverridetable{\listoverride\listid1724937575\listoverridecount0\ls1}{\listoverride\listid1324620909\listoverridecount0\ls2}}{\info{\title Default Rose-VDM++ Link forward engineering file}{\author VDM Tools}{\operator Demo}
{\creatim\yr1999\mo9\dy10\hr14\min55}{\revtim\yr1999\mo9\dy23\hr12\min9}{\printim\yr1999\mo9\dy8\hr13\min46}{\version10}{\edmins30}{\nofpages4}{\nofwords806}{\nofchars4597}{\*\company CSK}{\nofcharsws0}{\vern71}}
\widowctrl\ftnbj\aenddoc\linkstyles\hyphcaps0\formshade\viewkind1\viewscale100\pgbrdrhead\pgbrdrfoot \fet0\sectd \linex0\headery709\footery709\colsx709\endnhere\sectdefaultcl {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2
\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6
\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang
{\pntxtb (}{\pntxta )}}\pard\plain \s1\sb240\sa60\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\kerning28\cgrid {\lang2057 VDM-SL Model 
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs22\cgrid {In this model we assume there is one central resource and one till. Hence, there i
s no concurrency related to tills, but, for example, it is possible to report a card is illegal in the central resource while the card is in use at a till. This situation is handled using preconditions on operations. The purpose of the model is to analyze
 the main data and functional aspects of the system, e.g. ensuring that the daily limit is not exceeded and that cards are properly validated. 
\par 
\par The state of the model holds accounts and illegal cards associated with the central resource and current card and retained cards associated with the till. The cardOk variable records whether or not a card has been validated successfully. 
\par 
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading1500\cbpat8 \f2\fs20\lang1024\cgrid {state System of
\par   accounts : map AccountId to Account
\par   illegalCards : set of CardId
\par   curCard : [Card]
\par   cardOk : bool
\par   retainedCards : set of Card
\par inv mk_System(accs,-,curCard,cardOk,-) == 
\par       (curCard = nil => not cardOk) and 
\par       (forall id1, id2 in set dom accs &
\par         id1 <> id2 =>
\par         dom accs(id1).cards inter dom accs(id2).cards = \{\})
\par init s == s = mk_System(\{|->\},\{\},nil,false,\{\})
\par end
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs22\cgrid {
\par The invariant on the state ensures that card ids are unique across accounts. The main data values of the model are defined as the following types.
\par 
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading1500\cbpat8 \f2\fs20\lang1024\cgrid {types
\par   Account :: cards : map CardId to Cardholder
\par              balance : nat
\par              transactions : seq of Transaction
\par   inv account == TransactionsInvariant(account.transactions);
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs22\cgrid {
\par The invariant on account ensures that the daily limit is not exceeded. Due to the use of a mapping type for cards, it is ensured that card ids are uni
que for each account. We assume that it should not be possible to have a negative balance on an account, and the withdrawal operation below ensures that this does not happen.
\par 
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading1500\cbpat8 \f2\fs20\lang1024\cgrid {  Transaction :: date : Date
\par                  cardId : CardId
\par                  amount : nat;
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs22\cgrid {
\par A transaction is modeled as a record structure, holding a date of the transaction, the card used to perform the transaction and the amount withdrawn.
\par 
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading1500\cbpat8 \f2\fs20\lang1024\cgrid {  Card :: code : Code
\par           cardId : CardId
\par           accountId : AccountId;
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs22\cgrid {
\par A card has a code, a card id and an account id. Below some of the simpler data types are defined.
\par 
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading1500\cbpat8 \f2\fs20\lang1024\cgrid {  Cardholder :: name : Name;
\par 
\par   AccountId = nat;
\par   Address = seq of char;
\par   Name = seq of char;
\par   CardId = nat;
\par   Code = nat;
\par   PinCode = nat;
\par   Date = seq of char;
\par 
\par functions
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs22\cgrid {
\par The following definition introduces the auxiliary function for the invariant on account.
\par 
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading1500\cbpat8 \f2\fs20\lang1024\cgrid {  TransactionsInvariant : seq of Transaction +> bool
\par   TransactionsInvariant(ts) ==
\par     forall date in set \{ts(i).date | i in set inds ts\} &
\par       DateTotal(date,ts) <= dailyLimit;
\par 
\par   DateTotal : Date * seq of Transaction +> nat
\par   DateTotal(date,ts) ==
\par     Sum([ts(i).amount | i in set inds ts & ts(i).date = date]);
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs22\cgrid {
\par The daily limit on withdrawals is a constant value, which in this model is set to an arbitrary value.
\par  
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading1500\cbpat8 \f2\fs20\lang1024\cgrid {values
\par   dailyLimit : nat = 2000;
\par 
\par operations
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs22\cgrid {
\par The InsertCard operation models the activity of inserting a card into the till. This cannot be done if the till holds a card already. This is documented in the precondition.
\par 
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading1500\cbpat8 \f2\fs20\lang1024\cgrid {  InsertCard : Card ==> ()
\par   InsertCard(c) ==
\par     curCard := c
\par   pre curCard = nil;
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs22\cgrid {
\par The operation Validate is used to validate a PIN code and to check that a card is not illegal. The precondition ensures that the till 
currently holds a card that has not already been validated. If a card turns out to be illegal, the machine retains the card. 
\par 
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading1500\cbpat8 \f2\fs20\lang1024\cgrid {  Validate : PinCode ==> <PinOk> | <PinNotOk> | <Retained>        
\par   Validate(pin) ==
\par     let codeOk = curCard.code = Encode(pin),
\par         cardLegal = IsLegalCard(curCard) 
\par     in
\par       (if not cardLegal then 
\par         (retainedCards := retainedCards union \{curCard\};
\par          cardOk := false;
\par          curCard := nil;
\par          return <Retained>)
\par        else
\par          cardOk := codeOk;
\par        return if cardOk
\par               then <PinOk>
\par               else <PinNotOk>)
\par   pre curCard <> nil and not cardOk;
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs22\cgrid {
\par The ReturnCard operation is useful to end user sessions, though it is not mentioned in the requirements. It allows the user to perform more than one transaction in each session, e.g. to first view the balance and then make a withdrawal.
\par 
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading1500\cbpat8 \f2\fs20\lang1024\cgrid {  ReturnCard : () ==> ()
\par   ReturnCard() ==
\par     (cardOk := false;
\par      curCard:= nil)
\par   pre curCard <> nil;
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs22\cgrid {
\par The following three operations correspond to the required functions listed in the competition description. They all require that the till holds a card which has been validated successfully and not reported illegal.
\par 
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading1500\cbpat8 \f2\fs20\lang1024\cgrid {  GetBalance : () ==> nat
\par   GetBalance() ==
\par     return accounts(curCard.accountId).balance
\par   pre curCard <> nil and cardOk and IsLegalCard(curCard);
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs22\cgrid {
\par The withdrawal operation checks two things, that accounts are not overdrawn and that the daily limit is not exceeded. 
\par 
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading1500\cbpat8 \f2\fs20\lang1024\cgrid {  MakeWithdrawal : nat * Date ==> bool
\par   MakeWithdrawal(amount,date) ==
\par     let mk_Card(-,cardId,accountId) = curCard,
\par         transaction = mk_Transaction(date,cardId,amount)        
\par     in
\par       if accounts(accountId).balance \endash  amount >= 0 and 
\par         DateTotal(date,accounts(accountId).transactions^[transaction])
\par         <= dailyLimit
\par       then
\par         (accounts(accountId).balance := 
\par            accounts(accountId).balance \endash  amount;
\par          accounts(accountId).transactions := 
\par            accounts(accountId).transactions ^ [transaction];
\par          return true)
\par      else 
\par        return false
\par   pre curCard <> nil and cardOk and IsLegalCard(curCard);
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs22\cgrid {
\par The following operation returns a simple account statement, which can be sent to a cardholder.
\par 
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading1500\cbpat8 \f2\fs20\lang1024\cgrid {  RequestStatement : () ==> Name * seq of Transaction * nat
\par   RequestStatement() ==
\par     let mk_Card(-,cardId,accountId) = curCard,
\par         mk_Account(cards,balance,transactions) = accounts(accountId)
\par     in
\par       return mk_(cards(cardId).name,transactions,balance)
\par   pre curCard <> nil and cardOk and IsLegalCard(curCard);
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs22\cgrid {
\par A card is legal if it has not been reported illegal, its account id is valid, and its card id is valid.
\par 
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading1500\cbpat8 \f2\fs20\lang1024\cgrid {  IsLegalCard : Card ==> bool
\par   IsLegalCard(mk_Card(-,cardId,accountId)) ==
\par     return cardId not in set illegalCards and 
\par            accountId in set dom accounts and
\par            cardId in set dom accounts(accountId).cards;
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs22\cgrid {
\par The following operations are provided to update the accounts and illegal cards.
\par  
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading1500\cbpat8 \f2\fs20\lang1024\cgrid {  ReportIllegalCard : CardId ==> ()
\par   ReportIllegalCard(cardId) ==
\par     illegalCards := illegalCards union \{cardId\};
\par 
\par   AddAccount : AccountId * Account ==> ()
\par   AddAccount(accountId,account) ==
\par     accounts := accounts munion \{accountId |-> account\}
\par   pre accountId not in set dom accounts;
\par }\pard\plain \nowidctlpar\widctlpar\adjustright \fs22\cgrid {
\par Finally we define two auxiliary functions. Note that we have not decided on a concrete encoding function.
\par 
\par }\pard\plain \s15\nowidctlpar\widctlpar\adjustright \shading1500\cbpat8 \f2\fs20\lang1024\cgrid {functions
\par   Encode: PinCode +> Code
\par   Encode(pin) ==
\par     pin; -- NB! The actual encoding procedure has not yet been chosen
\par 
\par   Sum: seq of real +> real
\par   Sum(rs) ==
\par     if rs = [] then 0
\par     else
\par       hd rs + Sum(tl rs);
\par 
\par }}
